# 10장 렌더링 엔진

## 10.1 깊이 버퍼를 이용한 삼각형 래스터화의 기초

> 렌더링 과정 요약

* 수학적 형태로 표현된 3차원의 가상 장면을 구성하기
* 가상 카메라의 위치 방향 잡기
* 광원 정의
* 빛이 표면들과 어떻게 상호작용할 것인가 결정
* 가상 카메라 초점으로 빛의 색과 강도 계산

실시간 렌더링 엔진은 위의 단계를 계속 반복한다. 그려진 이미지를 초당 30~60번씩 보여주면서 움직이는 효과를 만든다.

### 10.1.1 장면 구성

장면은 다양한 물체들로 이루어진다. 불투명한 물체를 그릴 때는 물체의 표면만 고려해도 되지만 투명하거나 반투명한 물체들은 빛의 반산, 굴절, 산란,흡수 등을 고려해야 한다. 이를 표현하기 위해서는 물체 내부의 구조와 특성들도 알아야 한다.

하지만 대부분 게임 엔진은 이를 정밀하게 표현하기 보다는 단순하게 알파 값을 조정해서 물체의 투명도만을 조절한다. 이상하게 보일 수도 있지만 어느 정도는 그럴 듯하게 보이는 효과를 만들 수 있다.

연기 등 일정한 형상이 없는 것들은 반투명한 사각형 판들로 파티클을 만들어 구현하는 경우가 일반적이다.

#### 10.1.1.1 고성능 렌더링 프로그램에서 쓰이는 형식

이론적으로 표면이란 3차원 공간에 있는 무한히 많은 점들로 이루어진 2차원 평면이다. 이 정의를 그대로 사용할 수 없기 때문에 단순한 수식으로 표현해야 한다.

> 표면 방정식
* 이 방법은 임의 형상을 모델링하는데 효과적이지 않다.

> 사각현 Patch
* 영화의 컴퓨터 그래픽(CG)에 주로 사용된다.
* Patch는 적은 수의 컨트롤 포인트에 의해 정의 되는 2차원 스플라인(질문1)으로 구성된다.

> 분할 표면 (subdivision surface)
* 픽사의 렌더링 엔진 RenderMan이 사용하는 방식이다.
* 모든 표면은 컨트롤 다각형으로 표현한다.
* Catmull-Clark 알고리즘을 이용하면 다각형을 계속 더 작은 다각형으로 재분할 할 수 있다.
* 재분할은 한 픽셀보다 작아질 때까지 반복한다.
* 이 방식을 사용하면 카메라가 아무리 표면 가까이 다가가도 계속 재분할 하기 때문에 표면을 매끄럽게 표현할 수 있다.

#### 10.1.1.2 삼각형 메시

이전부터 게임 개발자들은 삼각형 메시를 이용해 표면을 표현했다.

삼각형 표면을 조각적 선형 근사(piecewise linear approximation)해서 표현한다.

> 삼각형을 사용하는 이유
* 삼각형은 가장 단순한 다각형이다.
* 삼각형은 언제나 평평하다.
* 삼각형은 대부분 변환을 거치더라도 삼각형이다.
  * 선분이 될 때도 있지만 그 외의 경우는 모두 삼각형을 유지한다.
* 시중에 존재하는 거의 모든 그래픽 가속 하드웨어의 핵심 개념은 삼각형 래스터화(질문2)다.

> Tessellation
* 표면을 여러 개의 다각형(사변형 또는 삼각형)으로 쪼개는 과정이다.

게임에서 사용하는 삼각형 메시는 얼마나 Tessellation 할 것인지 아티스트가 만들 때 고정 된다. 이상적인 해법은 카메라가 가까워짐에 따라 표면을 Tessellation해서 한 픽셀에 일정한 삼각형 밀도를 유지하는 방법이다.

위와 같이 삼각형의 밀도를 균등하게 유지하기 위해 삼각형 메시를 여러 벌 만드는 방법을 주로 사용한다. 이런 각 메시를 LOD(Level Of Detail)이라고 부른다. 이렇게 하면 렌더링 엔진은 카메라에 가까운 물체의 정점들의 변환과 조명에 집중할 수 있다.

동적 Tessellation과 LOD를 구현하는 다른 방법은 Progressive mesh(점진적 메시)가 있다. 고밀도 메시(LOD0)를 하나 만들고 물체가 멀어지면 메시의 모서리들을 하나씩 없애는 방법으로 Tessellation을 자동으로 낮춘다. 이 방법을 사용하면 연속적인 LOD를 자동으로 만들 수 있다.

#### 10.1.1.3 삼각형 메시 만들기

> 감기 순서
* 삼각형 정점 위치 벡터
  * (p1, p2, p3)
* 삼각형의 모서리
  * e12 = p2 - p1
  * e13 = p3 - p1
  * e23 = p3 - p2
* 삼각형의 단위 법선
  * 임의 모서리 두 개를 외적한 후 정규화
  * N = e12 X e13 / |e12 X e13|
  * 삼각형의 법선 방향을 알기 위해서는 삼각형의 어느 쪽이 전면이고 어느 쪽이 후면인지를 정해야 한다.
  * 감기 순서를 통해서 정해진다.
  * 스크린 공간에서 삼각형이 후면이면 보이지 않는 삼각형이기 때문에 그리지 않는다.

> 삼각형 리스트(Triangle List)
* 메시를 정의하는 제일 단순한 방법은 각 삼각형을 나타내는 정점을 세개씩 묶어 리스트로 나타내는 것이다.
* Triangle List 단점
  * 정점들이 중복된다.
    * 정점에 많은 메타 데이터들을 저장해야 하기 때문에 정점이 중복 되면 메모리를 낭비하게 된다.
    * 중복된 정점마다 변환과 조명 계산을 따로 해주어야 하기 때문에 GPU의 성능도 저하 시킨다.
    
> 인덱스 삼각형 리스트
* 대부분 렌더링 엔진은 인덱스 삼각형 리스트라는 자료 구조를 사용한다.
* 정점들을 중복 없이 나열한 후 어떤 정점드이 삼각형을 이루는지 인덱스로 나타낸다.
* 정점들은 Vertex Buffer에 저장 되고 인덱스들은 Index Buffer에 저장 된다.

특수한 메시 자료 구조인 스트립과 팬을 사용하는 경우도 있다. 둘 다 Index Buffer가 필요 없지만 정점 중복을 줄이는 효과를 준다.

> 스트립
* 첫 정점 3개가 삼각형 하나를 만든다.
* 다음 정점은 앞의 두 정점과 함께 새로운 삼각형을 만든다.
* 유의 사항은 감기 순서를 일관 되도록 하려면 앞의 두 정점은 다음 삼각형에서는 순서를 바꿔야 한다.

> 팬
* 첫 정점 3개가 하나의 삼각형을 만든다.
* 다음 정점은 바로 앞 정점과 제일 처음 정점으로 삼각형을 만든다.

> 정점 캐시 최적화
* GPU가 인덱스 삼각형 리스트를 처리할 때 각 삼각형의 정점은 버퍼 안에서 순차적으로 위치하지 않을 수도 있다.
* 정점은 삼각형 순서대로 있는 것이 좋은데 이유는 Rasterization 할 때 삼각형이 넘어가는데 정점이 순차적으로 있다면 캐시 히트가 더 커지기 때문이다.
* 이 이유 때문에 스트립과 팬을 쓰기도 한다. 스트립과 팬은 Index Buffer를 사용하지 않아 메모리 절약도 되지만 캐시 일관성을 더 향상 시킬 수 있다.
* 오프라인 도구인 정점 캐시 최적화 도구(Vertex Cache Optimizer)를 사용해서 정점 캐시 재사용성이 최대가 되도록 재배열 할 수 있다.

#### 10.1.1.4 모델 공간

삼각형 메시의 위치 벡터들을 나타낼 때 사용하기 편한 좌표계를 기준으로 삼는다. 이 편한 좌표계를 모델 공간, "로컬 공간", 물체 공간 등으로 부른다. 모델 공간의 축은 임의로 설정할 수 있지만 보통 모델의 축과 맞춘다.

#### 10.1.1.5 월드 공간과 메시 인스턴스

각각의 메시들은 "월드 공간"이라고 불리는 **공통 좌표계**를 기준으로 자리와 방향을 잡고 장면을 구성한다.

이 때 각 매시를 **메시 인스턴스**라고 부른다. 메시 인스턴스는 메시 데이터의 참조와 메시의 정점들을 모델 공간에서 월드 공간으로 변환하는 변환 행렬도 포함한다.

(질문3)

메시 렌더링할 때 메시의 표면 법선도 모델 월드 행렬를 적용해야 한다. 만약 모델 월드 행렬에 Scale 변환이 있었다면 모델 월드 행렬을 그대로 사용하는 것이 아니라 법선에는 모델 월드 행렬의 역전치 행렬을 곱해야 한다.

빌딩이나 지형등 배경 요소를 나타내는 메시는 정적이고 반복해서 사용되지 않는다. 이 경우 정점들은 월드 공간에 직접 표현 되는 경우가 많다. 이 때는 모델 월드 행렬은 단위 행렬이고 무시해도 된다.

## 10.2 렌더링 파이프라인

파이프라인의 각 단계는 대부분 다른 단계들에 무관하게 독립적으로 동작한다. 따라서 병렬화에 유리하다. 또한 특정 단계를 처리하는 하드웨어를 여러 개 배치하면 한 단계 안에서도 병렬 진행 할 수 있다.

파이프라인 처리량은 초당 처리 가능한 데이터 아이템 수로 측정한다.

파이프라인 지연시간은 한 데이터 아이템이 모든 파이프라인을 통과하는데 걸리는 시간이다.

전체 처리량은 가장 느린 단계에 좌우된다. 설계 잘 된 파이프라인은 모든 단계가 동시에 동작하면서도 다른 단계가 끝나기를 오래 기다리고 있는 단계가 없어야 한다.

### 10.2.1 렌더링 파이프라인 개괄

> 렌더링 파이프라인 단계
* 툴 단계(오프라인) - 모양, 메테리얼 정의
* 자원 다듬기 단계(오프라인) - 툴에서 정의한 모양/메테리얼을 엔진에서 사용할 수 있는 형태로 변환 (질문4)
* 애플리케이션 단계(CPU) - 보일 가능성인 메시 인스턴스 판별 후 메테리얼과 함께 GPU로 전달
* 기하 형상 처리 단계(GPU) - 정점을 변환하고 조명을 적용한 뒤 투영 시킨다.
* 레스터화 단계(GPU) - 삼각형을 단편들로 쪼갠 뒤 색을 결정하고 z테스트/알파테스트/스텐실테스트를 거친 후 플레임 버퍼에 블랜딩 한다.

#### 10.2.1.1 렌더링 파이프라인이 처리하는 데이터 형식

렌더링 파이프라인을 거치면서 기하 형상 데이터는 계속 변하게 된다.

> 데이터 형식의 변화
* 툴과 자원 다듬기 단계 - 메시와 메테리얼을 다룬다.
* 애플리케이션 단계 - 각각 메테리얼과 연결된 메시 인스턴스와 하부 메시 단위로 처리한다.
* 기하 형상 단계 - 하부 메시들을 정점 단위로 쪼개서 병렬로 처리한다.
* 레스터화 단계 - 단계에서는 삼각형을 단편으로 분해한다.

### 10.2.2 툴 단계

메시를 제작할 때는 디지털 콘텐츠 생성 프로그램(마야/3DS 맥스)에 있는 3D 모델러를 사용한다.

모델의 표면을 정의하는 형식은 넙스/쿼드/삼각형 등이 있다. 파이프라인 런타임 단계에서 렌더링하려면 반드시 삼각형으로 테셀레이션해야 한다.

# 질문들
> 1.스플라인(Spline)
* https://wonjayk.tistory.com/95
* 뭥가 보간법 같음
> 2.래스터화(Rasterization)
* https://lifeisforu.tistory.com/27
* Vertex 표현을 Pixel 표현으로 바꾸는 과정
> 3. 월드 행렬 표현
* 월드 행렬이 식과 같이 표현 되는 이유는?
> 4. ACP
* ??
