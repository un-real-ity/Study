## 렌더링 엔진

### 깊이 버퍼 삼각형 레스터화 기초

삼차원 화면을 렌더링하는 건 아래의 스텝들로 구성된다.

- 수학적인 형태로 표현되는 3차원 가상의 화면을 기술한다.
- 화면에서 원하는 장면을 보여줄 수 있는 가상의 카메라를 위치시킨다.
- 다양한 광원을 정의한다.
- 화면에 나타난 표면들이 빛과 어떻게 상호작용할 지를 나타내는 가상 특성을 기술한다.
- 화면의 각 픽셀에 대해 색깔과 빛의 강도를 계산한다.

보통 가끔 카툰 렌더링 등의 비실사 그래픽이 사용되긴 하지만 게임 렌더링에서 가장 우선적인 목표는 일반적으로 실사 렌더링이다. 이런 실사 렌더링 기술은 실사 이미지의 정확도를 희생하는 대신 리얼타임 퍼포먼스를 얻기 위한 기술부터 리얼타임에 동작하지 않더라도 아주 사실적으로 보이게 하는 기술까지 넓게 걸쳐 있다.

리얼타임 렌더링은 물체의 움직임을 나타내기 위해 위에서 기술한 단계들을 매 초 30~60 프레임 정도의 속도로 반복해서 수행한다. 따라서 렌더링 엔진은 각 이미지를 생성하는데 33.3ms 정도의 시간밖에 사용할 수 없다(30FPS 기준). 일반적으론 다른 시스템들도 같이 수행되어야 하므로 더 적은 시간밖에 쓸 수 없다.

### 씬 정의

real world scene은 여러 가지 오브젝트들로 구성된다. 몇몇 오브젝트들은 벽돌과 같은 강체(solid)이고, 몇몇은 연기나 구름과 같은 기체이다. 모든 오브젝트는 3차원 공간에서 어떤 부피를 차지한다. 오브젝트는 불투명하거나 투명할 수 있고 혹은 translucent(투명하지만 빛을 산란시킴)할 수 있다. 

불투명한 오브젝트를 렌더링할 때는 그 물체의 표면만 신경쓰면 된다. 그 외의 경우에는 빛이 그 물체를 통과할 때 어떻게 반사되고 산란되는지를 전부 모델링할 필요가 있다. 이는 해당 물체의 성질과 내부 구조에 대한 지식을 필요로 한다. 하지만 대부분의 게임 엔진은 그렇게까지 깊이 있게 다루지 않고, 불투명한 물체와 거의 유사하게 표면만을 렌더링한다.

투명 물체의 경우 alpha값을 이용한 간단한 모델이 쓰인다. 이 방법은 비쥬얼적으로 비정상적으로 보이는 경우가 있을 수 있지만, 대부분의 경우에 충분히 합리적으로 렌더링된다. 기체들은 보통 파티클 이펙트(보통 많은 개수의 반투명한 삼각형으로 표현되는)를 이용해서 렌더링된다. 따라서 게임 엔진은 표면을 주로 고려한다고 봐도 된다.

#### 고성능 렌더링 패키지에서 쓰이는 표현법

이론적으로 표면은 무한한 개수의 삼차원 점으로 이루어진 이차원 시트지만 실제로 그렇게 만들 순 없기 때문에 일반적으로 수학적인 표현법을 써서 표면을 나타낸다.

영화 산업에서 표면은 보통 적은 개수의 제어점으로 정의되는 이차원 스플라인으로부터 형성되는 사각형 패치의 집합으로 표현된다.

픽사의 렌더맨과 같은 고성능 영화 렌더링 엔진은 subdivision surface를 이용한다. 각 표면은 스플라인과 비슷하게 제어 폴리곤을 이용해 표현된다. 하지만, 각 폴리곤은 catmull-clark 알고리즘을 이용해서 더 작은 폴리곤으로 분할된다. 이런 분할은 일반적으로 각각의 폴리곤들이 하나의 픽셀보다 사이즈가 작아질 때까지 반복된다. 이 방법의 가장 큰 장점은 카메라가 표면에 얼마나 가깝든 상관없이 항상 폴리곤이 한 픽셀보다 더 작은 크기까지 분할된다는 것이다. http://ubm.io/1lx6th5 에 설명이 잘 되어 있다.

#### 삼각형 메시

게임 개발자들은 보통 삼각형 메시를 이용해 물체의 표면을 나타낸다. 이차원에서 직선이 곡선의 근사(approximation)인 것처럼 삼차원에서 삼각형은 표면의 근사다.

리얼타임 렌더링에서 삼각형 메시를 쓰는 것은 아래와 같은 좋은 성질이 있기 때문이다

- 삼각형은 폴리곤의 가장 단순한 타입이다.
- 삼각형은 항상 평면이다. 4개 이상의 점을 이용할 경우 모든 점이 한 평면 위에 있지 않을 수도 있지만, 삼각형은 그렇지 않음
- 삼각형은 어파인 변환과 투영 변환을 포함한 대부분의 변환에서 그대로 삼각형을 유지한다. 최악의 경우에도 선분이 됨
- 거의 대부분의 상업 그래픽스 가속화 하드웨어는 삼각형 레스터화를 기준으로 디자인되어 있다. 

*테셀레이션*

테셀레이션은 표면을 이산적인 폴리곤(사각형 혹은 삼각형)들의 집합으로 분할하는 과정을 뜻한다.

삼각형 메시를 쓸 때 문제점 중 하나는 아티스트가 그 메시를 만들 때 쓴 테셀레이션 레벨에서 고정되는 것이다. 이는 사물의 실루엣이 각지게 보이는 문제를 일으킨다(특히 물체가 카메라에 가까울 때).

이상적으로는 물체가 카메라에 가까워질 수록 물체의 테셀레이션 레벨을 높이는 것이 좋다. 이를 위해 게임에서는 LOD(level of details) 개념을 쓴다. LOD0에서 제일 테셀레이션 레벨이 높고, LOD1, LOD2... 로 갈 수록 레벨이 낮다. 카메라와의 거리에 따라 해당 물체를 렌더링할 때 다른 LOD 레벨을 쓴다.

몇몇 엔진은 물이나 지형 같은 고비용의 메시에 다이나믹 테셀레이션 테크닉을 적용한다. 이걸 쓰면 지형은 일종의 사각형 그리드 패턴 높이 맵으로 표현되고, 카메라에 가장 가까운 부분이 제일 높은 해상도로 테셀레이션된다.

동적 테셀레이션과 LOD를 구현하는 또다른 테크닉으로 progressive mesh가 있다. 이 방법은 LOD 0 짜리 메시를 만들고 오브젝트가 멀어지면 자동으로 물체의 일부 엣지를 합쳐서 detessellate 시킨다.

#### 삼각형 메시 구성

*Winding Order*

삼각형은 세개의 정점을 나타내는 위치 벡터로 정의된다. 이를 p1, p2, p3라 하자. 삼각형의 세 엣지는 단순히 정점의 차를 이용해서 구할 수 있다.

예를 들어,

```
e12 = p2 - p1
e13 = p3 - p1
e23 = p3 - p2
```

라고 할 수 있다. 이 때 두 엣지의 외적을 정규화(normalize)하면 해당 삼각형의 법선 벡터를 구할 수 있다. 즉, 법선 벡터 N은 아래와 같이 구할 수 있다.

```
N = (e12 X e13) / (|e12 X e13|)
이때, X는 외적, |x| 는 벡터의 크기
```

법선 벡터의 방향을 정의하기 위해서는 삼각형의 어느 면을 앞면으로 할 건지를 정해야 한다. 이는 winding order를 시계 방향으로 할지, 반시계 방향으로 할지를 정의하면 쉽게 정해진다.

대부분의 저수준 그래픽스 API는 와인딩 오더에 따라 삼각형의 뒷면을 컬링하는 기능을 제공한다. 예를 들어 direct3D에서 D3DRS_CULL을 D3DCULLMODE_CW로 주면 시계방향 삼각형은 뒷면으로 간주되어 화면에 보이지 않게 된다.

*Triangle Lists*

메시를 정의하는 가장 쉬운 방법은 버텍스를 세 개씩 그룹지어서 나열하는 것이다. 한 그룹으로 묶인 세 정점이 하나의 삼각형을 구성하게 된다. 이런 자료 구조는 triangle list라고 불린다.

*Indexed Triangle Lists*

triangle list의 경우 같은 정점이 여러 번 정의된다는 문제가 있다. 이 문제를 피하기 위해, 정점 배열을 구성하고 메시를 구성할 때 해당 정점 배열에서 몇 번째 정점을 이용할 지 인덱스 배열을 따로 구성하는 방법이 있다. 이 방법을 Indexed Triangle List라고 부른다. 이때 정점 배열은 보통 vertex buffer(DirectX) 혹은 vertex array(OpenGL)라고 불린다. 인덱스 배열도 마찬가지로 index buffer 혹은 index array라고 불린다.

*Strips and Fans*

triangle strip 혹은 triangle fan이라고 불리는 특수한 메시 자료 구조도 게임 렌더링을 위해 가끔 사용될 때가 있다. 두 데이터 구조는 모두 중복된 정점의 사용을 없애면서 동시에 인덱스 버퍼도 사용하지 않는다. 

스트립의 경우, 첫 세 정점이 첫 삼각형을 정의한다. 그 다음부터는 새로 추가된 정점 + 이전 두 정점이 새로운 삼각형이 된다.

팬의 경우, 첫 세 정점이 첫 삼각형을 정의하고 그 다음부터는 새로 추가된 정점 + 그 전 정점 + 제일 첫 정점이 새로운 삼각형이 된다.

*Vertex Cache Optimization*

GPU가 Indexed Triangle list를 처리할 때, 각 트라이앵글은 버텍스 버퍼에 있는 임의의 정점을 참조할 수 있다. 레스터 화 단계를 위해 각 삼각형들의 모양이 유지되어야해서 정점들은 삼각형에서 나타난 순서를 유지한 채 처리되어야 한다. 정점 셰이더에서 처리된 정점들은 이후 활용을 위해 캐시된다. 다른 primitive가 캐시 안에 있는 처리된 정점을 사용할 경우 이 걸 다시 처리하지 않고 계산된 정보를 그냥 가져다 쓴다.

스트립과 팬은 메모리를 아끼는 것 뿐만 아니라 캐시 히트 향상을 위해서도 쓴다. 더 나아가서, 정점의 중복된 사용을 막기 위해 indexed strip 혹은 indexd fan을 쓸 수도 있다.

indexed triangle list는 vertex cache optimizer를 이용해서 캐시 최적화를 할 수 있다. 이 도구는 캐시에 최적화된 순서로 정점을 재배열해준다. 

#### 모델 공간

삼각형 메시의 각 위치 벡터들은 보통 모델 공간, 혹은 로컬 공간이나 오브젝트 공간이라고도 불리는 좌표계에 상대적인 위치로 기술된다. 모델 공간의 원점은 보통 물체의 중심 혹은 바닥 이나 캐릭터의 발밑 가운데 같은 다른 유용한 위치로 정해진다.

모델 공간의 좌표축은 이전에 다뤘던 것 처럼 임의로 정해지는데, 보통 모델의 자연스러운 전방, 좌우, 위 방향을 기준으로 정해진다.

#### 월드 공간, 메시 인스턴싱

많은 독립적인 메시들이 공통의 좌표 시스템인 월드 공간에 배치되면 하나의 완성된 씬이 된다. 이 때 하나의 메시가 한 씬에 여러 번 나타날 수 있다. 이런 오브젝트를 메시 인스턴스라고 한다.

메시 인스턴스는 공통된 메시 데이터를 참조하고, 또 각 메시의 정점들을 모델 공간에서 월드 공간으로 변환하는 변환 행렬을 포함한다. 이 행렬은 보통 model-to-word 행렬 혹은 world 행렬이라고 불린다. 4x4 크기의 이 행렬은 앞선 챕터에서 다뤘 듯 맨 위 3x3 행렬은 모델 공간에서 월드 공간으로 변환하는 크기 - 회전 변환을 포함하는 행렬이고, 맨 아래 1x3은 물체의 위치를 나타내는 translation 행렬이다.

이 행렬은 정점 뿐만 아니라 물체의 법선 벡터에도 적용이 되어야 하는데, 이 때 그냥 행렬을 곱하면 안 되고 이 행렬의 역전치 행렬을 곱해야 한다. 변환에 scale이나 shear가 포함되어 있지 않은 경우는 역전치하지 않아도 제대로 구할 수 있다.

### 표면의 시각적 특성(visual property) 기술하기

물체의 표면을 제대로 렌더링하려면 그 물체의 시각적 특성을 기술해야 한다. 사실적인 이미지를 렌더링하는 건 빛이 어떻게 동작하고 사물들과 상호작용하는지를 정하확게 설명하는 것에 달렸다. 그래서 렌더링 엔지니어는 빛이 어떻게 동작하는지 잘 알아야 할 필요가 있다

#### 빛, 색 기초

빛은 입자면서 동시에 파동이다. 빛의 색깔은 빛의 강도(Intensity)와 파동의 길이(주기)에 의해 결정된다. 

*빛과 물체 간 상호 작용*

자세하게 이야기하면 굉장히 복잡하지만 요약하자면 빛은 4가지의 동작을 할 수 있다.

- 흡수될 수 있다
- 반사될 수 있다
- 투과될 수 있다. 투과되는 과정에서 굴절될 수 있다
- 회절될 수 있다

대부분의 사실적인 렌더링 엔진은 위 목록에서 첫 세 가지만 고려한다. 마지막건 보통 끼치는 영향이 적기 때문

특정한 주파수의 빛만이 표면에 흡수되고, 나머지는 반사된다. 이게 물체 표면의 색상을 결정. 

- 흰 빛(모든 주파수가 섞인 빛) -> 붉은색만 반사하는 물질 = 붉은 색
- 붉은 빛 -> 모든 색을 반사하는 물질 = 붉은 색(구분 불가)

반사는 분산(diffuse)될 수 있다. 즉, 빛을 반사시킬 때 모든 방향으로 균등하게 쪼개서 반사시킬 수 있다(난반사). 혹은 정반사(specular)할 경우, 아주 좁은 원통 범위로만 반사될 수 있다. 혹은 anisotropic(이방성의??)할 수 있다. 표면을 보는 각도에 따라 다르게 반사될 수 있다는 뜻

빛이 물체를 투과할 때, 흐려지거나(scattered, 반투명한 물체) 일부는 흡수되거나(색유리) 굴절될 수(프리즘) 있다. 

빛은 semi-solid(물컹물컹?)한 표면과 닿을 때 이리저리 튕기다가 처음 들어온 것과 다른 위치에서 빠져나갈 수 있다. 이걸 subsurface scattering이라고 함

*색 공간과 색 모델*

색 모델(color model)은 색을 측정하기 위한 3차원 좌표계다. 색 공간(color space)은 어떤 색 모델에서 수치로 표현된 색깔이 실제 세상에서 사람들한테 어떻게 보여져야 하는지 매핑시킨 특정한 기준을 일컫는다. 우리 눈이 보통 세 가지 센서를 이용해서 색을 인식하기 때문에 색 공간도 3차원으로 기술함

가장 많이 쓰이는 색 모델은 RGB. RGB888은 각 채널마다 8비트씩 할당. RGB565는 5,6,5비트 할당... 등등

좀 더 뒤에 log-LUV 색 모델이 high dynamic range(HDR) 라이팅에서 어떻게 사용되는지 알아 볼 것

*투명도, 알파 채널*

보통 RGB에 덧붙여 투명도를 나타내는 알파 채널이 쓰임. RGBA 혹은 ARGB 같은식으로 알파값 나타내는 채널 추가

#### 정점 어트리뷰트(attribute)

표면의 시각적 특성을 기술하는 가장 간단한 방법은, 그 특성을 표면의 몇몇 서로 다른 점들에 명시해놓는 것이다. 메시의 정점은 이런 표면의 특성을 저장하기 편리한 공간이다. 이를 vertex attributes라고 부른다.

간단한 삼각형 메시는 매 정점마다 아래 어트리뷰트중 일부 혹은 전부를 포함한다. 이외에 무엇이든 정의하고 싶은 다른 특성을 더 정의할 수 있다.

- 위치 벡터. 메시의 i번째 정점의 3d 공간상에서의 위치. 보통 물체의 모델 공간(로컬 공간)기준으로 명시됨
- 법선(vertex normal). i번째 정점의 평면에 대한 법선 벡터. 정점 단위의 동적 라이팅 계산에 사용됨
- 탄젠트(vertex tangent), 바이탄젠트(bitangent). 서로 수직이면서 법선과도 수직인 두 벡터. 이 두 벡터 및 법선 벡터를 축으로 탄젠트 공간(tangent space)를 구성할수 있다. 이 공간은 노말 매핑, 환경 매핑 등의 다양한 픽셀 단위 라이팅 계산에 사용된다.
- Diffuse Color(RGBA). 표면의 diffuse color를 나타냄.
- Specular color(RGBA). 빛이 반사될 때 specular highlight의 크기를 나타냄
- Texture Coordinates(UV). 해당 정점에 매핑시킬 이차원 텍스쳐 좌표
- Skinning weights. 스켈레톤 애니메이션에서, 메시의 각 정점은 연결된 스켈레톤의 개별적인 조인트들에 붙게 된다. 이 경우 각 정점은 자신이 어떤 조인트에 어느 정도 비중으로 붙어 있는지를 명시해야 한다(k번째 조인트에 w만큼의 weight로 붙어있음). [(k,w)] 배열로 표현됨

#### 정점 포맷

정점 어트리뷰트는 보통 C struct나 C++ class형태로 저장됨. 어떻게 저장할 건지 방식을 정점 포맷이라고 한다. 서로 다른 메시는 서로 다른 정점 어트리뷰트가 필요할 것이고 따라서 서로 다른 정점 포맷이 필요할 것이다.

메시 종류가 늘어나면 이런 어트리뷰트 조합의 종류도 기하급수적으로 늘어나기 때문에 이걸 관리하는 게 골치아파진다. 그래서 실용적인 몇 가지 옵션 중에 일부 서브셋만 사용하게 제한을 걸거나 모든 정점들이 동일한 어트리뷰트 셋(모든 상황에 유용하게 쓰일 수 있고 응용하기 좋은)을 쓰도록 정해놓고 사용하거나 하는 경우가 많음

#### attribute interpolation

정점 어트리뷰트는 표면에 대한 추정값 밖에 알려주지 않는다. 실제로 그릴 때는 정점을 그리는게 아니라 픽셀 단위로 정보를 채워넣어야 함. 간단한 방법은 픽셀 단위의 값은 버텍스의 어트리뷰트 정보를 linear interpolation한 값으로 결정하는 것. 정점 색에 적용될 경우 Gouraud shading으로 널리 알려져 있다. 법선이나 텍스쳐 좌표나 깊이 등 다른 값에서도 잘 사용 가능함

*Vertex Normals and Smoothing*



#### 텍스쳐

*텍스쳐의 종류*

*텍스쳐 좌표*

*texture addressing mode*

*텍스쳐 포맷*

*텍셀 밀도(texel density), 밉맵*

*World-Space Texel Density*

*텍스쳐 필터링*

#### 메테리얼

### 라이팅 기초

#### 로컬 / 글로벌 일루미네이션 모델

#### 퐁

#### 블린-퐁

#### BRDF Plots

#### 광원 모델링

*Static Lighting*

*Ambient Lights*

*Directional Lights*

*Point Lights*

*Spot Lights*

*Area Lights*

*Emissive Objects*

### 가상 카메라

#### 뷰 공간

#### 투영

#### 뷰 볼륨, 절두체(frustum)

#### 투영, homogeneous clip space

*Perspective Projection*

*Division by Z*

*Perspective-Correct Vertex Attribute Interpolation*

*Orthographic Projection*

#### Screen Space and Aspect Ratios

#### 프레임 버퍼

*렌더 타겟*

#### 삼각형 레스터화, Fragments

#### 오클루전, 깊이 버퍼

*z-파이팅, w-buffer*


