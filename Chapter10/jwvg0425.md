## 렌더링 엔진

### 깊이 버퍼 삼각형 레스터화 기초

삼차원 화면을 렌더링하는 건 아래의 스텝들로 구성된다.

- 수학적인 형태로 표현되는 3차원 가상의 화면을 기술한다.
- 화면에서 원하는 장면을 보여줄 수 있는 가상의 카메라를 위치시킨다.
- 다양한 광원을 정의한다.
- 화면에 나타난 표면들이 빛과 어떻게 상호작용할 지를 나타내는 가상 특성을 기술한다.
- 화면의 각 픽셀에 대해 색깔과 빛의 강도를 계산한다.

보통 가끔 카툰 렌더링 등의 비실사 그래픽이 사용되긴 하지만 게임 렌더링에서 가장 우선적인 목표는 일반적으로 실사 렌더링이다. 이런 실사 렌더링 기술은 실사 이미지의 정확도를 희생하는 대신 리얼타임 퍼포먼스를 얻기 위한 기술부터 리얼타임에 동작하지 않더라도 아주 사실적으로 보이게 하는 기술까지 넓게 걸쳐 있다.

리얼타임 렌더링은 물체의 움직임을 나타내기 위해 위에서 기술한 단계들을 매 초 30~60 프레임 정도의 속도로 반복해서 수행한다. 따라서 렌더링 엔진은 각 이미지를 생성하는데 33.3ms 정도의 시간밖에 사용할 수 없다(30FPS 기준). 일반적으론 다른 시스템들도 같이 수행되어야 하므로 더 적은 시간밖에 쓸 수 없다.

### 씬 정의

real world scene은 여러 가지 오브젝트들로 구성된다. 몇몇 오브젝트들은 벽돌과 같은 강체(solid)이고, 몇몇은 연기나 구름과 같은 기체이다. 모든 오브젝트는 3차원 공간에서 어떤 부피를 차지한다. 오브젝트는 불투명하거나 투명할 수 있고 혹은 translucent(투명하지만 빛을 산란시킴)할 수 있다. 

불투명한 오브젝트를 렌더링할 때는 그 물체의 표면만 신경쓰면 된다. 그 외의 경우에는 빛이 그 물체를 통과할 때 어떻게 반사되고 산란되는지를 전부 모델링할 필요가 있다. 이는 해당 물체의 성질과 내부 구조에 대한 지식을 필요로 한다. 하지만 대부분의 게임 엔진은 그렇게까지 깊이 있게 다루지 않고, 불투명한 물체와 거의 유사하게 표면만을 렌더링한다.

투명 물체의 경우 alpha값을 이용한 간단한 모델이 쓰인다. 이 방법은 비쥬얼적으로 비정상적으로 보이는 경우가 있을 수 있지만, 대부분의 경우에 충분히 합리적으로 렌더링된다. 기체들은 보통 파티클 이펙트(보통 많은 개수의 반투명한 삼각형으로 표현되는)를 이용해서 렌더링된다. 따라서 게임 엔진은 표면을 주로 고려한다고 봐도 된다.

#### 고성능 렌더링 패키지에서 쓰이는 표현법

이론적으로 표면은 무한한 개수의 삼차원 점으로 이루어진 이차원 시트지만 실제로 그렇게 만들 순 없기 때문에 일반적으로 수학적인 표현법을 써서 표면을 나타낸다.

영화 산업에서 표면은 보통 적은 개수의 제어점으로 정의되는 이차원 스플라인으로부터 형성되는 사각형 패치의 집합으로 표현된다.

픽사의 렌더맨과 같은 고성능 영화 렌더링 엔진은 subdivision surface를 이용한다. 각 표면은 스플라인과 비슷하게 제어 폴리곤을 이용해 표현된다. 하지만, 각 폴리곤은 catmull-clark 알고리즘을 이용해서 더 작은 폴리곤으로 분할된다. 이런 분할은 일반적으로 각각의 폴리곤들이 하나의 픽셀보다 사이즈가 작아질 때까지 반복된다. 이 방법의 가장 큰 장점은 카메라가 표면에 얼마나 가깝든 상관없이 항상 폴리곤이 한 픽셀보다 더 작은 크기까지 분할된다는 것이다. http://ubm.io/1lx6th5 에 설명이 잘 되어 있다.

#### 삼각형 메시

게임 개발자들은 보통 삼각형 메시를 이용해 물체의 표면을 나타낸다. 이차원에서 직선이 곡선의 근사(approximation)인 것처럼 삼차원에서 삼각형은 표면의 근사다.

리얼타임 렌더링에서 삼각형 메시를 쓰는 것은 아래와 같은 좋은 성질이 있기 때문이다

- 삼각형은 폴리곤의 가장 단순한 타입이다.
- 삼각형은 항상 평면이다. 4개 이상의 점을 이용할 경우 모든 점이 한 평면 위에 있지 않을 수도 있지만, 삼각형은 그렇지 않음
- 삼각형은 어파인 변환과 투영 변환을 포함한 대부분의 변환에서 그대로 삼각형을 유지한다. 최악의 경우에도 선분이 됨
- 거의 대부분의 상업 그래픽스 가속화 하드웨어는 삼각형 레스터화를 기준으로 디자인되어 있다. 

*테셀레이션*

테셀레이션은 표면을 이산적인 폴리곤(사각형 혹은 삼각형)들의 집합으로 분할하는 과정을 뜻한다.

삼각형 메시를 쓸 때 문제점 중 하나는 아티스트가 그 메시를 만들 때 쓴 테셀레이션 레벨에서 고정되는 것이다. 이는 사물의 실루엣이 각지게 보이는 문제를 일으킨다(특히 물체가 카메라에 가까울 때).

이상적으로는 물체가 카메라에 가까워질 수록 물체의 테셀레이션 레벨을 높이는 것이 좋다. 이를 위해 게임에서는 LOD(level of details) 개념을 쓴다. LOD0에서 제일 테셀레이션 레벨이 높고, LOD1, LOD2... 로 갈 수록 레벨이 낮다. 카메라와의 거리에 따라 해당 물체를 렌더링할 때 다른 LOD 레벨을 쓴다.

몇몇 엔진은 물이나 지형 같은 고비용의 메시에 다이나믹 테셀레이션 테크닉을 적용한다. 이걸 쓰면 지형은 일종의 사각형 그리드 패턴 높이 맵으로 표현되고, 카메라에 가장 가까운 부분이 제일 높은 해상도로 테셀레이션된다.

동적 테셀레이션과 LOD를 구현하는 또다른 테크닉으로 progressive mesh가 있다. 이 방법은 LOD 0 짜리 메시를 만들고 오브젝트가 멀어지면 자동으로 물체의 일부 엣지를 합쳐서 detessellate 시킨다.

#### 삼각형 메시 구성

*Winding Order*

삼각형은 세개의 정점을 나타내는 위치 벡터로 정의된다. 이를 p1, p2, p3라 하자. 삼각형의 세 엣지는 단순히 정점의 차를 이용해서 구할 수 있다.

예를 들어,

```
e12 = p2 - p1
e13 = p3 - p1
e23 = p3 - p2
```

라고 할 수 있다. 이 때 두 엣지의 외적을 정규화(normalize)하면 해당 삼각형의 법선 벡터를 구할 수 있다. 즉, 법선 벡터 N은 아래와 같이 구할 수 있다.

```
N = (e12 X e13) / (|e12 X e13|)
이때, X는 외적, |x| 는 벡터의 크기
```

법선 벡터의 방향을 정의하기 위해서는 삼각형의 어느 면을 앞면으로 할 건지를 정해야 한다. 이는 winding order를 시계 방향으로 할지, 반시계 방향으로 할지를 정의하면 쉽게 정해진다.

대부분의 저수준 그래픽스 API는 와인딩 오더에 따라 삼각형의 뒷면을 컬링하는 기능을 제공한다. 예를 들어 direct3D에서 D3DRS_CULL을 D3DCULLMODE_CW로 주면 시계방향 삼각형은 뒷면으로 간주되어 화면에 보이지 않게 된다.

*Triangle Lists*

메시를 정의하는 가장 쉬운 방법은 버텍스를 세 개씩 그룹지어서 나열하는 것이다. 한 그룹으로 묶인 세 정점이 하나의 삼각형을 구성하게 된다. 이런 자료 구조는 triangle list라고 불린다.

*Indexed Triangle Lists*

triangle list의 경우 같은 정점이 여러 번 정의된다는 문제가 있다. 이 문제를 피하기 위해, 정점 배열을 구성하고 메시를 구성할 때 해당 정점 배열에서 몇 번째 정점을 이용할 지 인덱스 배열을 따로 구성하는 방법이 있다. 이 방법을 Indexed Triangle List라고 부른다. 이때 정점 배열은 보통 vertex buffer(DirectX) 혹은 vertex array(OpenGL)라고 불린다. 인덱스 배열도 마찬가지로 index buffer 혹은 index array라고 불린다.

*Strips and Fans*

triangle strip 혹은 triangle fan이라고 불리는 특수한 메시 자료 구조도 게임 렌더링을 위해 가끔 사용될 때가 있다. 두 데이터 구조는 모두 중복된 정점의 사용을 없애면서 동시에 인덱스 버퍼도 사용하지 않는다. 

스트립의 경우, 첫 세 정점이 첫 삼각형을 정의한다. 그 다음부터는 새로 추가된 정점 + 이전 두 정점이 새로운 삼각형이 된다.

팬의 경우, 첫 세 정점이 첫 삼각형을 정의하고 그 다음부터는 새로 추가된 정점 + 그 전 정점 + 제일 첫 정점이 새로운 삼각형이 된다.

*Vertex Cache Optimization*

GPU가 Indexed Triangle list를 처리할 때, 각 트라이앵글은 버텍스 버퍼에 있는 임의의 정점을 참조할 수 있다. 레스터 화 단계를 위해 각 삼각형들의 모양이 유지되어야해서 정점들은 삼각형에서 나타난 순서를 유지한 채 처리되어야 한다. 정점 셰이더에서 처리된 정점들은 이후 활용을 위해 캐시된다. 다른 primitive가 캐시 안에 있는 처리된 정점을 사용할 경우 이 걸 다시 처리하지 않고 계산된 정보를 그냥 가져다 쓴다.

스트립과 팬은 메모리를 아끼는 것 뿐만 아니라 캐시 히트 향상을 위해서도 쓴다. 더 나아가서, 정점의 중복된 사용을 막기 위해 indexed strip 혹은 indexd fan을 쓸 수도 있다.

indexed triangle list는 vertex cache optimizer를 이용해서 캐시 최적화를 할 수 있다. 이 도구는 캐시에 최적화된 순서로 정점을 재배열해준다. 

#### 모델 공간

삼각형 메시의 각 위치 벡터들은 보통 모델 공간, 혹은 로컬 공간이나 오브젝트 공간이라고도 불리는 좌표계에 상대적인 위치로 기술된다. 모델 공간의 원점은 보통 물체의 중심 혹은 바닥 이나 캐릭터의 발밑 가운데 같은 다른 유용한 위치로 정해진다.

모델 공간의 좌표축은 이전에 다뤘던 것 처럼 임의로 정해지는데, 보통 모델의 자연스러운 전방, 좌우, 위 방향을 기준으로 정해진다.

#### 월드 공간, 메시 인스턴싱

많은 독립적인 메시들이 공통의 좌표 시스템인 월드 공간에 배치되면 하나의 완성된 씬이 된다. 이 때 하나의 메시가 한 씬에 여러 번 나타날 수 있다. 이런 오브젝트를 메시 인스턴스라고 한다.

메시 인스턴스는 공통된 메시 데이터를 참조하고, 또 각 메시의 정점들을 모델 공간에서 월드 공간으로 변환하는 변환 행렬을 포함한다. 이 행렬은 보통 model-to-word 행렬 혹은 world 행렬이라고 불린다. 4x4 크기의 이 행렬은 앞선 챕터에서 다뤘 듯 맨 위 3x3 행렬은 모델 공간에서 월드 공간으로 변환하는 크기 - 회전 변환을 포함하는 행렬이고, 맨 아래 1x3은 물체의 위치를 나타내는 translation 행렬이다.

이 행렬은 정점 뿐만 아니라 물체의 법선 벡터에도 적용이 되어야 하는데, 이 때 그냥 행렬을 곱하면 안 되고 이 행렬의 역전치 행렬을 곱해야 한다. 변환에 scale이나 shear가 포함되어 있지 않은 경우는 역전치하지 않아도 제대로 구할 수 있다.

### 표면의 시각적 특성(visual property) 기술하기

물체의 표면을 제대로 렌더링하려면 그 물체의 시각적 특성을 기술해야 한다. 사실적인 이미지를 렌더링하는 건 빛이 어떻게 동작하고 사물들과 상호작용하는지를 정하확게 설명하는 것에 달렸다. 그래서 렌더링 엔지니어는 빛이 어떻게 동작하는지 잘 알아야 할 필요가 있다

#### 빛, 색 기초

빛은 입자면서 동시에 파동이다. 빛의 색깔은 빛의 강도(Intensity)와 파동의 길이(주기)에 의해 결정된다. 

*빛과 물체 간 상호 작용*

자세하게 이야기하면 굉장히 복잡하지만 요약하자면 빛은 4가지의 동작을 할 수 있다.

- 흡수될 수 있다
- 반사될 수 있다
- 투과될 수 있다. 투과되는 과정에서 굴절될 수 있다
- 회절될 수 있다

대부분의 사실적인 렌더링 엔진은 위 목록에서 첫 세 가지만 고려한다. 마지막건 보통 끼치는 영향이 적기 때문

특정한 주파수의 빛만이 표면에 흡수되고, 나머지는 반사된다. 이게 물체 표면의 색상을 결정. 

- 흰 빛(모든 주파수가 섞인 빛) -> 붉은색만 반사하는 물질 = 붉은 색
- 붉은 빛 -> 모든 색을 반사하는 물질 = 붉은 색(구분 불가)

반사는 분산(diffuse)될 수 있다. 즉, 빛을 반사시킬 때 모든 방향으로 균등하게 쪼개서 반사시킬 수 있다(난반사). 혹은 정반사(specular)할 경우, 아주 좁은 원통 범위로만 반사될 수 있다. 혹은 anisotropic(이방성의??)할 수 있다. 표면을 보는 각도에 따라 다르게 반사될 수 있다는 뜻

빛이 물체를 투과할 때, 흐려지거나(scattered, 반투명한 물체) 일부는 흡수되거나(색유리) 굴절될 수(프리즘) 있다. 

빛은 semi-solid(물컹물컹?)한 표면과 닿을 때 이리저리 튕기다가 처음 들어온 것과 다른 위치에서 빠져나갈 수 있다. 이걸 subsurface scattering이라고 함

*색 공간과 색 모델*

색 모델(color model)은 색을 측정하기 위한 3차원 좌표계다. 색 공간(color space)은 어떤 색 모델에서 수치로 표현된 색깔이 실제 세상에서 사람들한테 어떻게 보여져야 하는지 매핑시킨 특정한 기준을 일컫는다. 우리 눈이 보통 세 가지 센서를 이용해서 색을 인식하기 때문에 색 공간도 3차원으로 기술함

가장 많이 쓰이는 색 모델은 RGB. RGB888은 각 채널마다 8비트씩 할당. RGB565는 5,6,5비트 할당... 등등

좀 더 뒤에 log-LUV 색 모델이 high dynamic range(HDR) 라이팅에서 어떻게 사용되는지 알아 볼 것

*투명도, 알파 채널*

보통 RGB에 덧붙여 투명도를 나타내는 알파 채널이 쓰임. RGBA 혹은 ARGB 같은식으로 알파값 나타내는 채널 추가

#### 정점 어트리뷰트(attribute)

표면의 시각적 특성을 기술하는 가장 간단한 방법은, 그 특성을 표면의 몇몇 서로 다른 점들에 명시해놓는 것이다. 메시의 정점은 이런 표면의 특성을 저장하기 편리한 공간이다. 이를 vertex attributes라고 부른다.

간단한 삼각형 메시는 매 정점마다 아래 어트리뷰트중 일부 혹은 전부를 포함한다. 이외에 무엇이든 정의하고 싶은 다른 특성을 더 정의할 수 있다.

- 위치 벡터. 메시의 i번째 정점의 3d 공간상에서의 위치. 보통 물체의 모델 공간(로컬 공간)기준으로 명시됨
- 법선(vertex normal). i번째 정점의 평면에 대한 법선 벡터. 정점 단위의 동적 라이팅 계산에 사용됨
- 탄젠트(vertex tangent), 바이탄젠트(bitangent). 서로 수직이면서 법선과도 수직인 두 벡터. 이 두 벡터 및 법선 벡터를 축으로 탄젠트 공간(tangent space)를 구성할수 있다. 이 공간은 노말 매핑, 환경 매핑 등의 다양한 픽셀 단위 라이팅 계산에 사용된다.
- Diffuse Color(RGBA). 표면의 diffuse color를 나타냄.
- Specular color(RGBA). 빛이 반사될 때 specular highlight의 크기를 나타냄
- Texture Coordinates(UV). 해당 정점에 매핑시킬 이차원 텍스쳐 좌표
- Skinning weights. 스켈레톤 애니메이션에서, 메시의 각 정점은 연결된 스켈레톤의 개별적인 조인트들에 붙게 된다. 이 경우 각 정점은 자신이 어떤 조인트에 어느 정도 비중으로 붙어 있는지를 명시해야 한다(k번째 조인트에 w만큼의 weight로 붙어있음). [(k,w)] 배열로 표현됨

#### 정점 포맷

정점 어트리뷰트는 보통 C struct나 C++ class형태로 저장됨. 어떻게 저장할 건지 방식을 정점 포맷이라고 한다. 서로 다른 메시는 서로 다른 정점 어트리뷰트가 필요할 것이고 따라서 서로 다른 정점 포맷이 필요할 것이다.

메시 종류가 늘어나면 이런 어트리뷰트 조합의 종류도 기하급수적으로 늘어나기 때문에 이걸 관리하는 게 골치아파진다. 그래서 실용적인 몇 가지 옵션 중에 일부 서브셋만 사용하게 제한을 걸거나 모든 정점들이 동일한 어트리뷰트 셋(모든 상황에 유용하게 쓰일 수 있고 응용하기 좋은)을 쓰도록 정해놓고 사용하거나 하는 경우가 많음

#### attribute interpolation

정점 어트리뷰트는 표면에 대한 추정값 밖에 알려주지 않는다. 실제로 그릴 때는 정점을 그리는게 아니라 픽셀 단위로 정보를 채워넣어야 함. 간단한 방법은 픽셀 단위의 값은 버텍스의 어트리뷰트 정보를 linear interpolation한 값으로 결정하는 것. 정점 색에 적용될 경우 Gouraud shading으로 널리 알려져 있다. 법선이나 텍스쳐 좌표나 깊이 등 다른 값에서도 잘 사용 가능함

#### 텍스쳐

linear interpolation으로 표면의 성질을 기술하는 건 삼각형 하나의 크기가 커질 수록 조잡한 결과를 내놓게 된다. 이런 한계를 극복하기 위해서 텍스쳐를 씀. 텍스쳐는 메시 위에 색을 매핑하는 용도 뿐만 아니라 다양한 정보를 담는 용도로 쓰인다. 일반적으로 2^n * 2^n 꼴의 크기로 만들어짐.

*텍스쳐의 종류*

제일 널리 알려진 종류의 텍스쳐는 디퓨즈 맵(diffuse map) 혹은 알베도 맵(albedo map)이다. 이 텍스쳐는 각 텍셀마다 표면의 색을 저장하며 표면에 그려진 데칼 혹은 그림과 같은 역할을 한다.

일반적으로 널리 쓰이는 다른 종류의 텍스쳐로는 노말맵(normal map, 각 텍셀마다 단위 법선 벡터를 RGB 값 형태로 저장), 글로스 맵(gloss map, 각 텍셀마다 표면이 얼마나 밝게 빛나야 하는지 정보를 저장), 환경 맵(environment map, 렌더링 리플렉션의 주변 환경 그림을 포함) 등등이 있다.

텍스쳐는 라이팅 계산 과정에서 사용될 수 있는 모든 종류의 정보를 담기 위한 용도로 쓸 수있다. 

*텍스쳐 좌표*

2차원 텍스쳐를 어떻게 메시의 표면에 투영시키는지 알아보자. 텍스쳐 상에서 한 지점은 2차원 텍스쳐 좌표계(u,v)로 표현된다. 좌표계는 (0,0)에서 (1,1)사이의 실수 값을 가진다. 2차원 텍스쳐를 삼각형에 매핑시키기 위해서는 단순히 각 정점에 대해 그 정점에 대응되는 텍스쳐 좌표가 뭔지만 정해주면 된다. 

*texture addressing mode*

텍스쳐 좌표는 0~1 바깥의 범위로 확장될 수 있다. 이 때 해당 좌표를 어떻게 처리하는지 그 방법을 texture addressing mode라고 한다.

- Wrap : 0~1 단위로 같은 텍스쳐가 무한히 반복되는 형태로 보는 것. ex - (3.7, 2.4)는 (0.7,0.4)와 같다
- Mirror : Wrap이랑 같지만 벗어날 때마다 뒤집어서 반복하는 것. 0~1과 2~3이 같고, 1~2는 0~1을 거꾸로 뒤집은 형태.
- Border color : 0~1 바깥 영역은 임의의 미리 정의된 색깔 값으로 가득차있다고 보는 것 

*텍스쳐 포맷*

텍스쳐는 어느 포맷이든 게임 엔진에서 읽어들일 수만 있는 형태면 상관없다. 일반적으로는 Targa(.tga), .png, .bmp, Tagged Image File Format(.tif) 등이 쓰인다.

대부분의 현대적인 그래픽 카드와 그래픽스 API는 압축 텍스쳐를 지원한다. DirectX는 DXT 혹은 S3 Texture Compression(S3TC)로 알려진 압축 포맷들을 지원한다. 압축 텍스쳐는 메모리도 덜 쓰고 렌더링도 빠르다(인접한 4x4블록을 64비트 혹은 128비트 word로 저장하기 때문에 캐시 프렌들리함). 압축으로 인한 퀄리티 저하는 대부분의 경우 신경쓰이지 않는 수준.

*텍셀 밀도(texel density), 밉맵*

한 픽셀에 들어가는 텍셀의 개수를 텍셀 밀도(texel density)라고 한다. 텍셀의 해상도와 화면의 해상도가 같으면 1, 텍셀 해상도보다 그려지는 화면 사이즈가 작으면 밀도는 1보다 커지는 식

텍셀 밀도는 오브젝트와 카메라의 거리 등에 따라 실시간으로 바뀐다. 텍셀 밀도가 너무 낮으면 화면이 깨져 보일 것이고, 너무 높으면 살짝만 움직여도 픽셀 값이 휙휙 바뀌거나 [moire banding pattern](http://nooleanbot.blogspot.com/2014/02/playing-with-moire-patterns-and-html5.html)같은 보기 흉한 것이 나타나게 된다. 게다가 메모리 낭비이기도 함

제일 좋은 건 밀도를 항상 1에 최대한 가깝게 유지하는 것. 이를 위해 mipmapping이라는 기술을 쓴다. 각 텍스쳐에 대해 절반 사이즈의 텍스쳐, 다시 그 절반 사이즈의 텍스쳐, ... 를 전처리해두는 것 이 각각을 밉맵 혹은 밉 레벨이라고 부른다.

*World-Space Texel Density*

texel density는 월드 공간에서의 공간 대비 텍셀의 밀도를 나타내는 말로 쓰일 수도 있다. 2m짜리 길이의 큐브에 256*256 사이즈의 텍스쳐를 매핑하면 밀도는 256^2/2^2 = 16384가 되는식. 

월드 공간 텍셀 밀도는 1에 가까울 필요가 없다. 그와 별개로, 각 오브젝트들의 텍셀 밀도는 항상 일정한 값인게 좋다. 각 오브젝트마다 밀도가 다르면 서로 해상도가 다르게 보이고, 이게 부자연스러워 보일 수 있기 때문(어떤건 엄청 고밀도 텍스쳐, 어떤건 엄청 저밀도 텍스쳐 이러면 이상해 보이니까)

*텍스쳐 필터링*

텍스쳐를 입힌 삼각형의 픽셀을 그릴 때, 그래픽 하드웨어는 픽셀의 중심이 텍스쳐 공간의 어느 위치로 떨어지는지를 이용해 샘플링한다. 하지만 보통 픽셀과 텍셀은 1대1 매핑이 되지 않고, 경우에 따라 여러 텍셀의 중간 지점에 떨어지거나 할 수 있기 때문에 여러 텍셀을 샘플링해서 그 결과를 블렌딩한 값을 해당 텍셀의 색깔로 계산하곤 한다. 이 과정을 텍스쳐 필터링이라고 부른다. 보통 아래와 같은 종류의 텍스쳐 필터링을 쓴다.

- Nearest neighbor: 픽셀의 중심과 중심이 가장 가까운 텍셀이 선택된다. 밉맵을 쓰는 경우, 픽셀 해상도에 가장 가까우면서 픽셀 해상도보다는 더 해상도가 큰 밉 레벨이 쓰인다.
- Bilinear: 픽셀의 중심 주변 4개의 텍셀을 고른다. 픽셀과의 거리에 따라 weighted average를 내서 그 값을 결과로 사용한다. 밉맵 쓸 경우 가장 해상도가 가까운 밉 레벨이 쓰인다.
- Trilinear: bilinear 필터링을 해상도가 가장 가까운 두 밉 레벨(해상도 더큰것, 더 작은것)에 대해 구한다. 그리고 이 두 값을 linear interpolate한다. 이 방법은 서로 다른 밉 레벨간의 비주얼적인 경계(밉 레벨이 바뀌면 모양새가 확 바뀌는 것)를 제거한다.
- Anisotropic: bilinear와 trilinear는 모두 2x2 크기의 텍셀 블록을 사용한다. 이건 정면에서 볼 땐 괜찮은데 비스듬한 각도에 있는 물체를 그릴 때는 부정확해 보인다. anisotropic은 보는 각도에 따라 사다리꼴 모양의 공간 안에 있는 텍셀을 샘플링한다. 

#### 메테리얼

메테리얼은 메시의 시각적 특성을 완벽하게 기술한 것이다. 이건 텍스쳐를 표면에 어떻게 매핑해야 할지, 메시를 렌더링할 때 어떤 셰이더를 써야 할지, 그리고 이 셰이더에 어떤 입력값을 줘야할지 등들을 모두 포함한다. 

기술적인 측면에서 정점 어트리뷰트는 메테리얼의 일부로 보지 않는다. 이 값들은 메시 자체에 붙어서 제공되며, 따라서 메시-메테리얼 쌍이 오브젝트를 렌더링하기 위해 필요한 모든 정보를 가지게 된다. 

### 라이팅 기초

라이팅은 모든 CG 렌더링의 핵심이다. 좋은 라이팅 없이 사실적인, 고퀄리티 렌더링하는 건 불가능.

shading이라는 용어는 종종 라이팅 + 다른 시각 효과를 모두 가리키는 일반화된 용어로 쓰인다. 

#### 로컬 / 글로벌 일루미네이션 모델

렌더링 엔진은 light-volume, light-surface 상호작용을 표현하는 여러가지의 수학적 모델을 사용한다. 이를 light transport model이라고 부른다.

가장 간단한 모델은 직접적으로 상호작용하는 빛(direct righting)만 고려하는 것. 이런 모델을 로컬 일루미네이션(local illumination models)이라고 한다.

하지만 진짜 사실적인 렌더링은 간접광(indirect lighting)을 고려해야만 이뤄질 수 있다. 이런 모델을 글로벌 일루미네이션이라고 한다. 몇몇 모델은 일부 현상(그림자, 반사 표면 등)을 시뮬레이션하는 것에만 초점을 맞추고, 레이트레이싱 같은 모델은 전반적인 모든 현상을 기술할 수 있는 모델을 제공하는 것에 초점을 맞춘다.

#### 퐁

게임 렌더링 엔진에서 제일 널리 알려진 로컬 라이팅 모델. 이 모델은 표면에서 반사되는 빛을 세 가지 요소를 이용해 기술한다.

- ambient : 씬의 전반적인 라이팅 레벨. 간접광의 대략적인 묘사. 
- diffuse : 물체의 표면 색깔. 모든 방향으로 고르게 반사되는 빛
- specular : 반짝이는 표면의 하이라이트 묘사. 

자세한 수식은 생략... 구현 필요할 때 책 보고 공식 따라서 구현하면 되는 것이라 힘들게 정리할 필요성을 못 느끼겠음

간단하게만 정리한다

V = 뷰 벡터. (빛이 반사되는 지점) -> (가상 카메라의 초점)
A = ambient light 색 벡터
N = 법선 벡터
kA, kD, kS = ambient, diffuse, specular 각각의 색이 반사되는 정도(각 색깔 채널별로) - 색 벡터
alpha = specular의 반짝이는 정도를 나타내는 지수.

그리고 각각의 광원 i에 대해,
Ci = 해당 빛의 색깔과 강도
Li = 해당 빛의 방향 벡터(반사되는 지점) -> (해당 빛의 광원)

퐁 모델에서 물체 표면의 특정 지점에서 반사되는 빛의 강도 I는 아래와 같은 식으로 표현된다.

I = (kA ⦻ A) + sum for all i ((kD(N·Li) + kS(Ri·V)^alpha) ⦻ Ci)

⦻는 컴포넌트 단위 곱셈. 즉, (x1,y1,z1) ⦻ (x2,y2,z2) = (x1\*x2, y1\*y2, z1\*z2)

이 식에서 Ri는 빛의 방향 벡터 Li가 평면의 법선 벡터에 대해 반사된 벡터를 의미한다.

#### 블린-퐁

블린-퐁은 퐁이랑 거의 비슷한데 specular을 약간 다른 방식으로 표현한다. 퐁 모델에서 스펙큘러를 계산하는 부분에서, Ri·V는 빛이 반사되는 방향이 내가 보는 방향과 얼마나 일치하는지를 따져주는 식인데, 반사 벡터 Ri가 계산 코스트가 좀 있다. 그래서 이걸 쓰는 대신에 하프 벡터 H를 쓴다. H는 내가 보는 방향 V와 광원의 방향 L의 중간 벡터. 이 H와 법선 벡터 N이 얼마나 일치하는지인 N·H를 R·V 대신 사용.

정확한 표현은 아니지만, 거의 비슷한 결과를 냄. 하지만 계산 코스트가 훨씬 적다. 그리고 가끔 특정 종류의 표면에서는 퐁보다 더 보기 좋은 결과가 나옴

#### BRDF Plots

퐁 라이팅 모델의 세 가지 요소는 BRDF(bidirectional reflection distribution function)으로 알려진 일반적인 로컬 반사 모델의 특수한 케이스다.

BRDF는 입사광선이 주어진 보는 방향 V를 따라 반사되는 빛의 비율을 계산한다. 

BRDF는 반구형의 형태로 표현된다. 반지름이 빛의 강도에 따라 보이는 영역(어떤 물체의 표면이 해당 반지름 내에 있으면 빛이 반사되는게 보임)을 나타냄. 퐁 모델에서의 디퓨즈 값은 뷰 벡터랑 무관하게 입사광 L에 의해서만 영향을 받는다. 따라서 이 값은 보는 각도와 상관없이 일정하다.

반면 specular 요소는 빛의 방향 L과 보는 방향 V 둘 모두에 영향을 받는다. L과 V 차이가 벌어질 수록 값이 급격하게 작아짐.

#### 광원 모델링

빛과 표면의 상호작용에 더불어 광원에 대한 기술이 필요하다. 광원은 보통 몇 가지 단순화된 모델로 표현된다.

*Static Lighting*

가장 빠른 빛 계산은 계산을 안 하는 것이다. 라이팅을 미리 계산해놓고 그걸 갖다 쓰는게 정적 라이팅. 각 광원에 대해 그 광원이 물체에 미치는 계산의 결과를 저장하는 텍스쳐 맵을 라이트 맵(light map)이라고 한다. 런타임에는 그냥 이 텍스쳐의 값이 그대로 투영됨. 라이트 맵은 해당 빛의 영역에 들어오는 임의의 물체에 대해 대응이 가능하고 물체가 움직일 때도 광원의 효과를 계산할 수 있어서 유용함

*Ambient Lights*

퐁 모델에서 ambient값과 관련된 빛. 방향도 없고 시야각이랑도 상관 없음. 일정한 색깔로 씬의 간접광을 표현하는 요소

*Directional Lights*

표면으로부터 무한히 떨어진 곳에서 일정한 방향으로 오는 빛(태양광). 색 C와 방향 L로만 표현됨

*Point Lights*

게임 월드상에서의 위치와 강도를 가짐. 해당 위치에서 전방향으로 빛 발사. 강도는 거리의 제곱에 비례해서 작아진다. 최대 거리 넘어가면 0으로 바로 클램핑됨. 위치 P와 색/강도 C, 최대 반지름 r_max로 정의됨

*Spot Lights*

포인트 라이트랑 비슷한데 손전등처럼 콘 모양으로 뻗어나가는 광원.보통 inner / outer angle의 두 가지 콘으로 표현됨 안쪽 콘 내부에서 빛은 최대 강도고, 바깥쪽으로 갈 수록 강도가 약해진다. 여기에 추가로 광원으로부터의 거리를 고려. 위치 벡터 P와 광원의 색깔 C, 중심 방향 벡터 L, 최대 반지름 r_max, 내부 외부 각도로 정의됨

*Area Lights*

앞서 말한 건 광원의 위치가 없거나, 혹은 특정한 점으로 정의되는 것들. 하지만 현실 세계의 광원은 그렇게 딱 떨어지는 한점으로 표현되지 않는다. 이게 그림자와 반그림자를 형성함. 

area light는 제대로 모델링하기보다는 여러가지 트릭을 사용함. 여러 그림자를 만들고 그 결과를 블렌드한다거나 그림자의 엣지를 블러처리하거나 등등

*Emissive Objects*

어떤 표면들은 그 자체로 광원을 겸하기도 한다. 빛나는 유리구슬이라든가 로켓 엔진에서 분사되는 화염이라거나 등등. 이런 것들은 이미시브 텍스쳐 맵을 이용해서 모델링된다. 이 텍스쳐 맵의 색은 항상 최대 강도이며, 주변 빛에 대한 영향을 받지 않는다. 네온 사인, 자동차의 헤드라이트 등등을 표현하는데 쓰임

이런 물체들은 여러가지 테크닉을 결합해서 구현하는 경우가 많다. 예를 들어 손전등같은 것은 이미시브 텍스쳐 맵 및 스팟 라이트를 같이 쓰는 식

### 가상 카메라

컴퓨터 그래픽스에서 가상 카메라는 실제 카메라 혹은 인간의 눈을 단순화 한 것.

#### 뷰 공간

#### 투영

#### 뷰 볼륨, 절두체(frustum)

#### 투영, homogeneous clip space

*Perspective Projection*

*Division by Z*

*Perspective-Correct Vertex Attribute Interpolation*

*Orthographic Projection*

#### Screen Space and Aspect Ratios

#### 프레임 버퍼

*렌더 타겟*

#### 삼각형 레스터화, Fragments

#### 오클루전, 깊이 버퍼

*z-파이팅, w-buffer*


## 렌더링 파이프라인

### 개관

#### 렌더링 파이프라인이 데이터를 어떻게 변형하는가

#### 파이프라인의 구현

### The Tools Stage

### The Asset Conditioning Stage

### The GPU Pipeline

#### Vertex Shader

#### Geometry Shader

#### Stream Output

#### Clipping

#### Screen Mapping

#### Triangle Set-up

#### Triangle Traversal

#### Early z-Test

#### Pixel Shader

#### Merging / Raster Operations Stage

### Programmable Shaders

#### Accessing Memory

*Shader Registers*

*Textures*

#### 고수준 셰이더 언어 syntax 소개

#### Effect Files

#### 더 읽을거리

### Antialiasing

#### Full-Screen Antialiasing(FSAA)

#### Multisampled Antialiasing(MSAA)

#### Coverage Sample Antialiasing(CSAA)

#### Morphological Antialiasing(MLAA)

#### Subpixel Morphological Antialiasing(SMAA)

### The Application Stage

#### 가시성 판단

*Frustum Culling*

*Occlusion and Potentially Visible Sets*

*Portals*

*Occlusion Volumes (Antiportals)*

#### Primitive Submission

*Render State*

*State Leaks*

*The GPU Command List*

#### Geometry Sorting

*z-Prepass to the Rescue*

#### Scene Graphs

*Quadtrees and Octrees*

*Bounding Sphere Trees*

*BSP Trees*

#### Choosing a Scene Graph
