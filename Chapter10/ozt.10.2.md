# 10.2.5 GPU 파이프 라인

## 정점 쉐이더
* 입력으로 정점하나를 받는다.
* 텍스처 데이터에 접근이 자유롭다.
* 정점을 모델 공간에서 뷰 공간으로 변환.
* 원근 투영을 적용
* 정점별 조명 ,텍스쳐 계산
* 에니메이션 스키닝 처리
* 정점의 위치를 수정해 절차적 애니메이션을 수행
    * 바람에 흔들리는 수풀, 물결치는 물 표면
* 출력으로 변환과 조명이 적용된 정점
    * 정점의 위치와 법선은 동차 클립 공간의 좌표 (10.1.4.4)

## 지오메트리 쉐이더
* 동차 클립 공간에 있는 기본 단위(primitive)를 처리
* 기본단위 culling, 및 수정 / 생성
* 그림자 볼륨 extrusion (10.3.3.1)
* 큐브 맵의 여섯면 렌더링하기 (10.3.1.4)
* 메시의 실루엣 모서리를 따라 fur fin extrusion
* 파티클에서 점 데이터로 쿼드 생성(10.4.1)
* 동적 테셀레이션
* 번개 효과를 위한 선분 fractal subdivision
* 옷감 시뮬레이션

## 스트림 출력
* 파이프라인에서 지금까지 처리된 데이터를 다시 메모리에 저장하는 기능
* 머리카락 물리 시뮬레이션
    * 정정 셰이더에서 머리카락 스플라인의 제어 지점을 시뮬레이션
    * 지오메트리 셰이더에서 스플라인을 테셀레이션
    * 스트림 출력으로 테셀레이션된 정점을 다시 메모리에 저장
    * 선문들이 다시 파이프라인의 처음으로 들어가 렌더링됨

## 클리핑
* 절두체에 걸치는 삼각형의 일부를 잘라내는 것
    * 절두체 밖에 있는 정점을 찾기
    * 삼각형의 모서리가 절두체의 평면과 교차하는 지점을 찾기
    * 교차하는 지점을 새로운 정점으로, 새로운 삼각형을 구성
* 별도의 클리핑 평면을 더할 수 있음

## 스크린 매핑
* 동차 클립 공간에 있는 정점을 스크린 공간으로 스케일링 & 이동

## 삼각형 셋업
* 삼각형을 단편으로 쪼개는 과정을 효율적으로 처리하기 위해
* 레스터화 하드웨어를 초기화

## 삼각형 순회
* 삼각형을 단편들로 쪼갠다 (레스터화)
* 픽셀 하나당 단편 하나
* MSAA 하는 경우 픽셀 하나에 여러 단편을 만듬 (10.1.4.7)
* 정점 속성을 보간해서 단편 속성을 계산
* 필요한 경우 원근 보정 속성 보간도 적용
* 보간된 결과는 픽셀 셰이더에서 사용된다.

## 이른 z 테스트
* z테스트 단편의 깊이를 체크하는 기능
* 프레임 버퍼의 픽셀에 가려지는 경우 단편 버림
    * 픽셀 셰이더 하기전에 버리는 것!
* 구식 GPU는 z테스트를 알파테스트랑 같이 수행
* 그래서 이때 하는 z테스트를 이른 z 테스트라고함 (빠른 88)

## 픽셀 셰이더
* 완전 프로그래밍 가능한 단계 (완프가단)
* 입력은 단편 단위 속성의 모임
* 단편의 색을 결정하는 것
* 단편이 완전 투명하면 버림
* 여러개의 텍스처 맵을 참조
* 픽셀 단위 조명 계산
* 단편의 색을 결정하는데 필요한 온갖 작업을 진행
* 단편의 색이 될 벡터 하나를 출력

## 합치기/레스터 작업 단계
* 여러 단편에 관한 테스트를 수행
    * 깊이 테스트 (10.1.4.8)
    * 알파 테스트: 단편과 픽셀의 알파 채널을 이용해 단편을 버릴 수 있음
    * 스텐실 테스트 (10.3.3.1)
* 테스트 통과한 단편은 프레임 버퍼에 있는 픽셀의 색과 블랜딩
    * 알파 블랜딩 함수를 통해서 블렌딩 제어
    * Cd' = AsCs +(1-As)Cd
        * s for (src), d for (dst)
        * Cd: 기존 프레임의 색
        * Cs: 그려질 단편의 색
        * As: 블랜딩 가중치
        * Cd': 블랜딩 결과
* 알파 블렌딩이 제대로 보이려면 프레임 버퍼에 그리는 순서 정렬이 필요 (이부분 잘 이해 안됨)
    * 불투명한 기하 형상들을 프레임 버퍼에 기입
    * 반투명한 표면들을 순서대로 정렬
    * 뒤에서 앞으로 그려야한다.
    * 알파 블렌딩 이후의 프레임 버퍼에 있던 픽셀의 깊이는 새로운 단편의 깊이로 교체되기 때문

# 10.2.6 프로그래머블 셰이더

## 종류
* 정점 셰이더
    * 입력
        * 정점 하나
        * 정점의 위치와 법선은 모델공간이나 월드 공간으로 표현
    * 출력
        * 변환과 조명이 완전 끝난 정점
        * 동차 클립 공간으로 표현
* 지오메트리 셰이더
    * 입력
        * n개의 정점으로 이루어진 primitive
        * control point로 동작하는 최대 n개의 여분의 정점들
    * 출력
        * 0개 이상의 기본 단위
        * 입력 형식과 다른 종류가 될 수 있다.
            * 점 -> 삼각형 두개로 이루어진 쿼드
* 픽셀 셰이더
    * 입력
        * 단편 하나
        * 단편이 속한 삼각형의 세 정점으로 부터 보간해 계산된 것
    * 출력
        * 프레임버퍼에 기록될 색
        * 단편 버린경우 출력 없음

## 메모리 접근
* 셰이더 레지스터
    * 레지스터를 통해 RAM에 간접적으로 접근
    * GPU 레지스터는 모두 128비트 SIMD
    * 각 레지스터는 32 비트 부동소수/정수를 4개 담을 수 있음
        * 동차 좌표계의 4차원 벡터
        * RGBA 형식의 색 하나
        * 행렬은 여러개의 레지스터를 그룹으로 묶어서 사용
    * 32비트 스칼라값 하나만 저장하는 경우 4개가 다 같은 값을 가진다
    * 16비트를 처리하는 거는 하프라고 부름
* 레지스터의 종류
    * 입력 레지스터
        * 셰이더가 입력 데이터를 받는 주요한(유일한?) 수단
        * 모든 입력 레지스터의 값은 셰이더가 호출되기 전에 GPU가 알아서 전달해줌
    * 상수 레지스터
        * 어플리케이션이 값을 지정하고 기본 단위에 따라 그 값이 변할 수 있음
        * 셰이더 프로그램의 관점에서만 상수
        * 셰이더에 부가적인 입력을 제공할 때 사용함
        * 모델 뷰 행렬, 투영행렬, 조명 매개변수등 정점속성으로는 제공되지 않는 온갖 매개변수들이 상수 레지스터로 전달됨
    * 임시 레지스터
        * 셰이더 프로그램 안에서 사용할 수 있으며 보통 중간 계산 값을 담는데 사용됨
    * 출력 레지스터
        * 셰이더의 출력값을 채워서 전달하는 용으로 사용됨
        * 유일한 출력 방식
    * 정리
        어플리케이션은 기본 단위를 렌더링 하기 위해 넘길때 상수 레지스터의 값을 채운다. GPU는 셰이더 프로그램을 호출하기 전에 정점 혹은 단편의 속성 데이터를 비디오 램에서 적절한 입력 레지스터로 자동으로 복사하며, 셰이더 프로그램이 끝난 후에는 출력 레지스터 값을 다시 RAM에 저장해 다음 파이프라인 단계로 넘어갈 수 있게 한다.
* 캐시
    * GPU는 보통 출력 데이터를 캐시에 넣어서 다시 계산할 필요없이 재사용 할 수 있게 한다.
    * post-transform 정점 캐시는 가장 최근에 처리한 정점을 저장한다.
    * 어떤 삼각형이 이전에 처리된 정점을 참조하는 경우 가능하면 post-transform 정점 캐시에서 읽어 오려고 시도한다.

* 택스쳐
    * 셰이더는 텍스처를 읽기 전용 데이터로 직접 읽을 수 있다.
    * 텍스처 데이터는 메모리 주소가 아닌 텍스처 좌표로 접근한다.
    * 텍스처 데이터를 접근할 때 GPU의 텍스처 샘플러가 자동으로 필터링을 한다.
        * 인접한 텍셀, 인접한 밉맵 레벨을 알아서 가져와서 블랜딩한다.
        * 특정 텍셀의 원래값이 궁금하면 필터링 끄면 된다.
        * 텍스처 맵이 데이터 테이블로 쓰는경우 유용하다.
    * 셰이더가 텍스처 맵에 데이터를 기록하고 싶으면 간접적인 방법을 통해야한다.
    * 오프스크린 프레임 버퍼에 장면을 렌더링하고 이것을 다음 렌더링 패스에서 텍스처 맵드로 인식하게 하는 방식이다.
    * 이것을 텍스처에 렌더링한다고 한다.

## 하이레벨 셰이더 문법
* 선언한 변수는 레지스터에 저장됨
* 시멘틱
    * 변수를 특정한 정점 / 단편 속성에 연결하게 알려주는것
    ```c++
    struct VtcOut {
        float4 pos: POSITION; // 위치속성에 연결
        float4 color: COLOR; // 색속성에 연결
    }
    ```
* 입력값과 출력값
    * 메인함수의 인자는 입력값
    * 메인함수의 리턴은 출력값
    ```c++
    VtxOut vshaderMain(VtxIn in //입력 레지스터에 연결) {
        VtxOut out;
        return out; // 출력 레지스터에 연결
    }
    ```
* Uniform 선언
    * 상수 레지스터에 연결하는 변수 선언
    ```c++
    VtxOut vshaderMain(
        VtxIn in, 
        uniform float4x4 modelViewMatrix // 상수레지스터에 연결
    ) {
        VtxOut out;
        out.pos = mul(modelViewMatrix, in.pos); // 내장 mul 함수
        return out; // 출력 레지스터에 연결
    }
    ```
* 텍스처 참조하기
    * 텍스처 좌표로 텍셀을 읽어오는 특수한 내장 함수
    * 1차원, 2차원, 3차원 텍스처를 읽는 다양한 함수 존재
    * 필터링 ON/OFF 가능
    * 큐브맵, 그림자 맵 접근시 특수 텍스처 주소 지정모드도 사용 가능
    * 텍스처 맵 자체에 대한 참조는 texture sampler 선언을 사용
    ```c++
    struct FragmentOut {
        float4 color: COLOR;
    }
    FragmentOut pshaderMain(
            float2 uv: TEXCOORD0,
            uniform sampler2D texture
    ) {
        FragmentOut out;
        out.color = tex2D(texture, uv); // 텍스처의 uv 좌표 텍셀
        return out;
    }
    ```

## 이펙트 파일
* 셰이더 프로그램들을 엮어서 완전한 시각 효과를 만들기 위한 파일 형식
* 계층형식
    * 전역 공간에 셰이더 프로그램들과 전역변수들을 정의
    * 하나 이상의 테크닉을 정의
        * 테크닉: 특정한 시각 효과가 렌더링 되는 방식
        * 여러 품질을 구현하는 테크닉을 둬서 하드웨어 성능별로 취사 선택가능
    * 테크닉안에 하나 이상의 패스를 정의
        * 패스는 한 전체 화면 이미지가 어떻게 렌더링 되어야 하는지를 기술
        * 정점 쉐이더, 지오메트리 쉐이더, 픽셀 쉐이더의 main함수
        * 다양한 전달 인자 바인딩
        * 부가적인 렌더 상태 설정

# 10.2.7 애플리케이션 단계
* 애플리 케이션 단계의 역할
    * 가시성 결정: 보이는 물체들만 넘긴다
    * 기하 형상을 GPU에 제출한다.
        * 하부 메시와 머터리얼의 쌍을 제출
        * 기하 형상 정렬
        * 여러 패스에 렌더링하는 경우 여러번 제출하기도한다.
    * 셰이더 전달 인자와 렌더 상태를 제어
        * 셰이더 상수 레지스터에 전달할 인자를 기본단위별로 설정
        * 설정이 가능한 파이프라인들의 설정값 제어

## 가시성 결정
* 절두체 선별
    * 절두체 밖으로 벗어난 물체들을 렌더링 리스트에서 제외하기
    * 절두체의 여섯 평면과 물체의 바운딩 볼륨 검사 
    * 바운딩 볼륨을 구 형태로 체크하기
        * 절두체의 각 평면을 돌면서 반지름 만큼 안쪽으로 이동
        * 구의 중심이 평면의 어느쪽에 있는지 체크
        * 모두 앞이면 안에 있음
    * 장면 그래프를 사용하면 더 효율적이다.
* 차폐 및 잠재적 가시 그룹
    * 절두체 안에 있어도 서로 가릴 수 있음
    * 차폐선별: 다른 물체에 완전히 가려지는 물체를 제거
    * PVS: potentially visible set
        * 카메라가 바라보는 위치가 주어지면 PVS가 보일만한 물체를 반환
        * 레벨을 여러지역으로 나누어서 구현
            * 각 지역안에 카메라가 들어왔을때 보일 수 있는 다른 지역들을 리스트로 미리 계산해둠
            * 각 지역의 렌더 형상에 고유 색깔을 부여
            * 각 지역의 임의의 자리에 카메라를 두고 렌더링 수행
            * 렌더링 결과에 포함된 색깔지역을 PVS에 추가함
* 포탈
    * 창문이나 문 등의 구멍을 통해 서로 연결된 지역으로 구분
    * 카메라가 있는 지역을 먼저 렌더링
    * 카메라의 초점 -> 포탈의 폴리곤 모서리로 이어지는 평면의 집합 (절두체): 포탈 볼륨
    * 포탈 볼륨으로 인접한 지역의 물체를 선별
    * 창문이 있는 좁은 공간(ex 방) 렌더링할때 유용
* 안티포탈
    * 포탈의 가시성을 뒤집어서 어떤 물체에 가려지는 볼륨을 구성
    * 가리는 물체의 경계 모서리를 찾은후 카메라의 초점부터 모서리까지 차폐 볼륨을 생성
    * 차폐 볼륨에 완전히 들어오는 물체들을 제거
    * 넓은 실외 환경에서 가까운 물체들이 카메라 절두체를 가리는 상황에서 유용

## 기본단위 제출
* 렌더상태
    * GPU파이프라인중 설정가능한 단계에 전달할 설정값의 집합
    * 렌더상태는 어플리케이션 레벨에서 잘 전달해야한다.
        * 그려질 모든 메시 인스턴스의 리스트를 순회
        * 하부 메시 머터리얼 쌍에 기술된 렌더상태를 설정
        * 로우레벨 기본단위 제출함수를 호출
* 상태 누수
    * 기본 단위를 제출하기 전에 렌더상태를 재설정해야함
    * 만약 설정을 누락하면 다음 상태를 그리는데 영향을 미친다.
* GPU 명령 리스트
    * 어플리케이션 단계가 GPU와 통신하는 방법
    * 렌더상태 설정 + 그릴 기하 형상 지정
    * 머터리얼 1로 A, B를 그리고 머터리얼 2로, C, D, E를 그려보자
        * 렌더 상태를 머터리얼 1 에 맞게 설정
        * 기본단위 A 제출
        * 기본단위 B 제출
        * 렌더 상태를 머터리얼 2 에 맞게 설정
        * 기본단위 C 제출 ...

## 기하 형상 정렬
* 렌더 상태 설정을 최소화하는 것이 이득이다
* 기하 형상들을 그리는 순서를 잘 정렬해서 이득을 보자
* 머터리얼 순으로 정렬하는 경우
    * 픽셀 중복 그리기가 늘어서 성능이 오히려 하락할 수 있음
    * 중복 그리기를 줄이려면 삼각형을 앞에서부터 그려서 z 테스트로 제거해야함
* 해결사 Z 프리패스
    * 중복그리기 제거와 렌더상태 설정 최소화 두마리 토끼를 잡는 방법
    * z버퍼 먼저 그리고난 다음 프레임 버퍼를 채우는방법
    * 픽셀 셰이더를 패스하고 z버퍼의 내용만 업데이트
    * 불투명한 기하형상을 앞에서 뒤로 그림
    * 머터리얼에 따라 기하형상을 정렬한뒤 z버퍼에 따라 상태 변화를 최소화
    * 투명한 물체들을 뒤에서 앞의 순서로 그림 (투명은 나의 원쑤)

## 장면그래프
* 절두체 선별하기전에 절두체 근처에 있지 않은 물체를 빠르게 가려낼 자료구조
* 쿼드트리(2D)와 옥트리(3D)
    * 공간을 사분면으로 재귀적 분할
    * 대부분 수직 평면을 사용하지만 경우에 따라서 임의의 형태로 분할
    * 렌더링 가능한 기본단위는 트리의 리프에 저장된다.
    * 각 리프마다 저장하는 기본단위의 갯수가 어느정도 균등하게 만드는 것이 일반적이다.
    * 트리의 부모가 절두체와 교차하지 않으면 자식도 안함
* 경계 구 트리
    * 쿼드트리가 네모라면 구트리는 동그라미
    * 리프는 렌더링 가능한 기본단위의 바운딩스피어
    * 기본단위를 묶는 바운딩 스피어를 다시 계산
    * 모든 기본단위가 묶일때까지 반복
* BSP 트리
    * 매 반복마다 공간을 평면하나로 나눔
    * 평면에 걸친 삼각형들은 이 평면을 기준으로 두개의 삼각형으로 나눔
    * 모든 삼각형이 이 평면의 앞에 있거나 뒤에 있게됨
    * 절두체 선별은 위와 동일
    * +@ 삼각형을 뒤-앞 순으로 정렬하는데 사용될 수 있음
        * 루트에서부터 탐색
        * 카메라가 해당 노드의 분할 평면에 대해 앞에 있는지 뒤에 있는지 검사
        * 앞에 있음 뒤 노드부터, 뒤에있음 앞 노드부터
        * 카메라에서 멀리 있는 삼각형을 먼저 탐색하게됨 
