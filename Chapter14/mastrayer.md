# 14. 런타임 게임플레이 기반 시스템

## 14.1 게임플레이 기반 시스템의 컴포넌트
대부분의 게임 엔진은 게임의 고유한 규칙과 목표, 동적 월드 구성 요소들을 만드는 기반으로 쓰이는 여러 런타임 소프트웨어 컴포넌트를 제공.

게임 엔진과 게임을 나누는 선을 긋는다면, 이 시스템은 선 바로 아래에 위치함.

엔진마다 형태는 다르지만, 공통적으로 다음과 같은 주요 하위 시스템을 제공.

- 런타임 게임 객체 모델 - 게임 디자이너가 월드 에디터를 통해 가상의 게임 객체 모델을 실제로 구현하는 부분
- 레벨 관리 및 스트리밍 - 게임플레이가  벌어지는 가상 월드의 컨텐츠를 불러오고 내리는 시스템
- 실시간 객체 모델 업데이트
- 메세지와 이벤트 처리
- 스크립트
- 목적 및 게임 흐름 관리 - 플레이어의 목적과 전체적인 게임의 흐름을 관리하는 하위 시스템. 목적들을 한데 묶어서 챕터로 구성하는 경우가 많음.
- 런타임 객체 모델
  - 동적으로 게임 객체 생성/파괴
  - 로우레벨 엔진 시스템과 연동 - 물리엔진, 렌더링엔진, 애니메이션 등 다른 하위 엔진 시스템에 접근할 수 있게함.
  - 객체 행동 실시간 시뮬레이션
  - 새로운 게임 객체 타입을 정의할 수 있는 기능 - 월드 에디터에서 새로운 객체 타입을 쉽게 추가하고 사용할 수 있도록 유연한 게임 객체 모델을 갖는 것이 중요. 
  - 고유 객체 식별자(id) - 정수가 제일 효율적이지만 알아보기 난해함. 해시 식별자를 권장함.
  - 게임 객체 질의(query) - 게임 월드 내의 객체들을 찾을 수 있는 방법을 제공해야함.
  - 게임 객체에 대한 참조(reference)
  - 유한 상태 기계에 대한 지원
  - 네트워크 레플리케이션 - 네트워크 멀티플레이어 게임인 경우 기계 한 대만 게임 객체를 소유하고 관리하는 것이 보통이다(?). 그렇지만 객체의 상태는 모든 기계들에 복제되어 일관된 모습으로 볼 수 있어야 함.
  - 게임을 저장하고 불러오는 기능/객체의 영속성(persistence) - 월드 내의 객체들의 현재 상태를 디스크에 저장하고 나중에 불러올 수 있게 하기. 네트워크 레플리케이션을 구현하는 방법의 일환일 수도 있음.
  런타임 타입 식별(RTTI), 리플렉션, 추상 생성같은 언어의 기능들이 주로 쓰임.
---
## 14.2 런타임 객체 모델 구조
런타임 객체 모델은 반드시 월드 에디터에서 보이는 객체 타입과 속성, 행동을 충실하게 재현해야 한다.
다양한 디자인 방식이 쓰이지만, 대부분은 다음의 두 가지 기본적인 구조 중 한 가지를 따른다.

  - 객체 중심적
    툴 측면의 게임 객체 하나는 런타임에서 클래스 인스턴스 한 개로 표현되거나, 연관 있는 적은 숫자의 인스턴스 집합으로 표현됨.

  - 속성 중심적
    게임 객체들은 각각 고유 ID로만 표현됨. 각 게임 객체의 속성들은 속성 타입별로 데이터 테이블에 나뉘어 담겨 있으며, 접근은 객체 ID를 이용.
    게임 객체의 행동은 그 객체를 이루는 속성들의 집합에 의해 간접적으로 정의됨. (ex. Health 속성을 갖는 객체는 손상되거나 체력을 잃을 수 있다)
---
### 14.2.1 객체 중심 구조
논리적인 게임 객체 하나를 클래스 인스턴스 하나나 연관된 인스턴스들의 집합으로 구현.

- 14.2.1.1) C로 구현한 단순한 객체 기반 모델: 하이드로 썬더
  world 객체가 필요한 애들을 멤버로 다 가지고 있음.
---
- 14.2.1.2) 거대 단일 클래스 계층
  객체 타입 분류를 생물 분류학과 비슷하게 사용하려는 것은 자연스럽다.
  처음엔 작고 단순한 형태로 시작하지만, 점점 깊고 넓어지는 구조를 가지게 됨. 이걸 거대 단일 클래스 계층이라고 부른다.
  하나의 공통 베이스 클래스를 거의 모든 게임 객체들이 상속하는 경우 이런 계층이 된다. 대표적으로 언리얼.
---
- 14.2.1.3) 깊고 넓은 계층 구조의 문제점
  - 클래스들을 이해하기 힘들고 유지보수가 어려움.
    어떤 클래스를 이해하려면 그 부모들도 모두 이해해야 하기 때문. 찾기 힘든 사이드가 발생할 가능성 매우 높음.

  - 여러 계열의 분류 구조 구현 불가
    트리의 한 레벨은 오직 한 종류의 기준에 의해서만 분류된다. 
    - (색깔로 구분중인 레벨에서 다리 갯수가 다른 형질을 분류하려면 완전히 다른 트리 구조가 필요하다)

    (그림 봐)

  - 다중 상속: 죽음의 다이아몬드
    수륙양용 문제를 해결하기 위해서 다중 상속을 활용? 
      - 죽음의 다이아몬드

  - 믹스인 클래스
    제한된 형태의 다중 상속. 클래스는 여러 개의 부모를 가질 수 있지만, 오직 한 개의 조부모 클래스를 가질 수 있다.(그림봐)

    상속보단 합성, 조합임.
    
  - 버블업 효과
    클래스를 처음 설계할 때는 단순하면서 꼭 필요한 기능만 외부에 노출한다.
    하지만 기능이 하나 둘 더해짐에 따라 서로 연관없는 클래스들 사이에 불필요한 코드가 공유됨.
    (책 예시가 미쳤따. 와우)
---
- 14.2.1.4) 합성을 통해 계층 구조를 단순하게 유지
  - 클래스가 거대하고 복잡해지는 주요한 이유는 is-a 관계를 남요하기 때문.
  - has-a 관계를 합성(composition)이라고 부른다. 
    - A가 B를 직접 포함하거나 B에 대한 포인터나 참조를 포함.
    - 엄격한 의미에서 합성은, A가 B를 소유해야함. (A가 생성될 때 B도 자동으로 생성되어야 한다는 뜻)
    - 포인터나 참조를 사용해 다른 클래스의 생성과 파괴를 직접 관리하지 않게 할 수도 있는데, 이것을 조합(aggregation)이라고 부름.

  - is-a 관계를 has-a 관계로 바꾸기
    계층의 깊이와 너비를 줄이고 복잡도를 감소시키는 데 이 방법이 유용하게 쓰인다.
    (예시)
    쉽게 설명하자면, RenderableObject는 Movable이고, GameObject이다. 가 아니라
    GameObject가 필요한 클래스(컴포넌트)를 가진 허브같은 역할을 하도록 수정한다.

  - 컴포넌트 생성과 소유권
    이렇게 has-a 관계로 리팩토링하면, 허브 클래스가 컴포넌트들의 수명을 관리하게 된다.
    허브 클래스는 포인터를 전부 NULL로 설정해놓고, 이걸 상속받는 클래스가 오버라이딩해서 필요한 컴포넌트를 생성해서 쓰도록 구현.
---
- 14.2.1.5) 제네릭 컴포넌트
  허브보다 구현하기 까다롭지만 더 유연한 방법으로, 루트 클래스에 제네릭 연결 리스트를 두어 컴포넌트를 관리하는 방법이 있다.
  이렇게 하면 어떤 타입의 컴포넌트들이 있는지 크게 신경쓰지 않아도 되며, 새 타입의 컴포넌트를 만들 때 클래스 수정이 필요하지 않을 수도 있다.
---
- 14.2.1.6) 순수 컴포넌트 모델
  컴포넌트화 개념을 끝까지 밀어 붙여서 루트의 GameObject 클래스의 모든 기능을 컴포넌트로 덜어낸다고 가정.
  그러면 GameObject 클래스는 논리적인 행동이 없는 껍데기에 불과하게 될 것.
  이 때, 이 클래스를 없애도 괜찮지 않을까? 그러면 각 컴포넌트들은 해당 객체의 고유 ID를 가지고 논리적인 그룹으로 묶일 수 있다. 
  객체 ID를 가지고 컴포넌트들을 빠르게 검색할 수 있다면, 허브 클래스를 둘 필요가 없다.

  하지만 문제점도 있다.
    - 여전히 다양한 게임 객체들의 콘크리트 타입(??)을 정의할 방법이 있어야 함.
    - 허브와 다르게 컴포넌트 인스턴스 생성은 어떻게?
      - 게임 객체 타입마다 가상 함수가 있는 팩토리 클래스를 하나씩 만들어서 해결.
      - 데이터 주도 모델을 사용해서, 객체 타입들을 테긋트로 정의하고 이것을 엔진이 읽어서 인스턴스 생성할 때마다 참조.
    - 컴포넌트간 통신이 문제. 허브는 통신 중계 역할도 겸했었음.
      - 같은 객체에 속하는 다른 ㅌ컴포넌트들을 빠르게 찾아낼 방법이 있어야한다.
    - 다른 게임 객체로 메세지 보내는 일 또한 까다롭다.
      - GameObject가 없어서 어떤 컴포넌트와 통신해야하나?
---
### 14.2.2 속성 중심적 구조
1. 객체 중심 관점 - 속성과 행동을 가진 객체.
2. 속성 중심 관점 - 속성마다 테이블을 하나씩 만들고, 각자 속성마다 객체 ID를 가짐. (RDB같은 느낌)

- 가진 것이 속성들의 테이블뿐이면 어떻게 행동을 구현할까?
  - 속성들 그 자체 안에서 구현
  - 스크립트 코드를 통해서 구현
---
- 14.2.2.1) 속성 클래스를 통해 행동 구현
  각 속성 클래스는 하드코딩된 메소드를 통해 행동을 제공.
  어떤 게임 객체의 전체적인 행동은 그 객체에 포함된 모든 속성들의 행동이 합쳐져 결정됨.
---
- 14.2.2.2) 스크립트를 통해 행동 구현
  속성 값들은 그냥 DB에 있고, 객체의 행동을 스크립트로 따로 구현.
  게임 객체는 script id를 가지고 특정 스크립트가 실행될 수 있도록 매핑시킴.
---
- 14.2.2.3) 속성과 컴포넌트
  속성 객체는 컴포넌트와 밀접한 관계. 논리적 게임 객체 하나를 이루는데 여러 개의 하위 객체가 사용됨.
  여러 하위 객체에 의해 논리적 게임 객체가 구성되고, 이것들에 의해 행동이 정해지는 디자인을 속성 중심 디자인 혹은 순수 컴포넌트 모델(14.2.1.6)이라고 부름. 똑같다.
---
- 14.2.2.4) 속성 중심 디자인의 장단점
  - 정말 사용되는 속성만 저장되기 때문에 메모리를 적게 쓰는 경향이 있다.
  - 데이터 주도 방식으로 구현하기 더 쉬워서 컴파일 없이 새 속성을 쉽게 정의 가능.
  - 캐시 친화적이기도 하다.
    - array-of-structs(구조체의 배열) vs struct-of-arrays(배열의 구조체)
  - 하지만 게임 객체가 단지 속성들을 모은 덩어리에 불과하면, 속성 사이에 관계를 강제하기가 어려워진다. 
    - 자잘한 속성의 행동을 맞춘다고 해서 원하는 행동이 되도록 구현하기 힘들다.
  - 디버깅 또한 매우 힘들다.
---
## 14.3 월드 덩어리 데이터 형식
월드 덩어리(?)에는 정적 요소와 동적 요소가 같이 들어가는 것이 일반적.
동적인 부분엔 게임 객체들을 나타내는 정보가 담겨 있다.

  - 객체 속성들의 초기 값
  - 객체 타입에 대한 지정(ex. 객체 ID)
---
### 14.3.1 바이너리 객체 이미지
객체들을 저장하는 방법 중에는 런타임 메모리를 통째로 파일에 저장하는 방식이 있다. 이렇게 하면 객체를 생성하는 일이 정말로 쉽다(메모리에 불러오기만 하면 모든 객체 이미지를 바로 사용할 수 있기 때문)
하지만 사실은 굉장히 많은 예외때문에 쉽지 않다.
  - 포인터와 가상 테이블 예외 처리
  - 클래스와 인스턴스 내부 데이터의 엔디안 문제
  - 바이너리 객체 이미지는 변경이 힘들고, 변경시 문제 발생 가능성이 큼
  - 하지만 변경이 드문 자료 구조인 메시 데이터나 충돌 기하 형상을 저장하는 데는 좋을 수 있다(?????)
---
### 14.3.2 게임 객체 정보의 직렬화
바이너리로 저장하는 것보다 여러 플랫폼에 이식하기 쉽고 구현도 간편.
각 객체마다 데이터 스트림을 만들어서 반환하는 메서드를 구현하고, 이 데이터를 저장하고 불러와서 사용.

C#과 Java는 XML 형식으로 직렬화하는 기능을 언어 수준에서 지원하지만, C++은 그렇지 않다.

- 직렬화 데이터는 바이너리 이미지가 아니다.
- 더 사용하기 편하고 여러 플랫폼에 옮기기 쉬운 형태로 저장
- XML 형식을 많이 이용. 사람이 읽을 수 있고, 여러 시스템에 지원하고 표준화되어 있으며 계층구조 처리에 적합. (그렇지만 매우 느려서 자체 구현 바이너리 형식을 사용하는 게임 엔진도 있다)

직렬화 기법엔 두 가지 방법이 사용될 수 있다.
1) Base class에 SerializeOut()과 SerializeIn()등의 가상 함수 두 개를 넣고 상속받는 클래스들이 구현하도록 한다
2) 리플렉션 시스템을 구현. 리플렉션 데이터가 있는 모든 객체를 자동으로 직렬화하는 제네릭 시스템 구현
    - 리플렉션 데이터를 생성할 땐, 모든 클래스의 리플렉션 데이터를 생성해야 함.

    - 클래스 데이터 멤버를 정의할 때 매크로를 이용해 리플렉션 정보를 뽑는 가상 함수를 구현하거나, 클래스마다 리플렉션 데이터 구조를 손으로 짜는 방법도 있다.

    - 직렬화 데이터엔 어떤 객체에 대한 정보였는지 클래스나 타입을 나타내는 ID를 포함한다. 그러나 C++에선 이 ID로 클래스 인스턴스를 생성할 수 없다. 그래서 하드코딩이 필요하지만, 이런 언어적 제약을 우회하기 위해 모든 C++ 직렬화 시스템은 클래스 팩토리를 사용한다. 

    - 팩토리를 구현하는 쉬운 방법은, 이름과 인스턴스를 생성하는 함수나 Function object를 매핑시켜둔 테이블을 이용하는 것.
---
### 14.3.3 스포너와 타입 스키마
위의 두 방법은 게임 객체 타입의 런타임 구현에 따라 좌우되기 때문에 월드 에디터가 런타임 구현에 대해 상세히 알아야 한다는 단점이 있다. (??? 바이너리와 직렬화는 에디터가 아닌, 인게임 애기인 것 같다)

그렇기 때문에, 월드 에디터와 런타엠 엔진 코드 간의 결합을 끊으려면 게임 객체에 대한 정보를 구현 중립적인 방식으로 추상화하면 됨(?????)

- 월드 덩어리 데이터 파일에 있는 모든 게임 객체마다 작은 데이터 블록을 저장하는데, 이것을 보통 스포너(spawner)라고 부름 (?????)
- 스포너는 가볍고 데이터만 있는 게임 객체 표현으로, 런타임에 해당 게임 객체의 인스턴스를 생성하고  초기화하는 데 사용됨.
- 스포너에는 툴에서 쓰이는 게임 객체 타입에 대한 ID가 들어있다. 또, 객체 속성들의 초기 값을 저장한 간단한 테이블도 들어 있다. (이 테이블엔 모델-월드 변환이 포함되는 경우가 많다)
- 게임 객체를 스폰할 때, 스포너의 타입을 보고 올바른 클래스 인스턴스가 생성된다. 그 후, 테이블을 참조해 데이터 멤버들을 초기화한다.
- 스포너는 로딩되자마자 객체를 생성하게도, 생성 요청이 올 때까지 가만히 있게 할 수도 있음.
- 예시 보면 게임 객체 생성 외에도 스포너를 월드에서 중요 지점이나 좌표축들을 정의하는데에도 사용했음. (위치 스포너, 로케이터 스포너)
  - AI 캐릭터를 위한 관심 지정을 정의
  - 여러 애니메이션들이 완벽한 동기화를 이뤄 재생하는 기준이 될 좌표축들을 정의
  - 파티클 효과나 오디오 효과의 기준점이 될 위치 정의
  - 경주 트랙에서 웨이포인트 정의
---
#### 14.3.3.1 객체 타입 스키마
게임 객체의 속성들과 행동은 그 타입에 의해 결정됨.
스포너 방식의 디자인을 채용한 게임 월드 에디터에선 게임 객체 타입을 나타낼 때 데이터 기반 방식의 스키마를 사용할 수 있다.

- 스키마는 어떤 타입의 객체를 만들고 편집할 때 알아야 할 속성들을 정의한 것.
- 런타임에는 올바른 게임 객체를 생성하기 위해 툴의 객체 타입을 통해 적절한 클래스(들)을 찾아낸다(???????)
- 스키마 예시 보자

스키마는 에디터에서 어떤 편집 UI를 제공해야 하는가 등에 대한 부가적인 정보 또한 제공한다.
- min, max같이 GUI에서 쓰이는 메타 데이터도 지정 가능.
- 스키마 상속을 지원하는 엔진도 있다. (ex. ID같은건 최상위 스키마에서 정의하고 다른 애들이 상속받기)
---
#### 14.3.3.2 디폴트 속성 값
스키마에는 속성이 굉장히 많이 들어갈지도 모른다. 기본값이 없다면 에디터를 사용하기 많이 힘들겠지?

디폴트 값을 쓰면 문제점이 하나 있다. 개발 도중 디폴트 값이 변경된다면, 변경 전의 객체들이 쓰던 속성의 값은 어떻게 해야할까? -> EZEZ

---
### 14.3.4 스포너와 타입 스키마의 몇 가지 이점
스포너를 게임 객체 구현 부분과 분리해서 얻는 가장 중요한 이점은 단순성, 유연성, 안정성.
  - 데이터 관리 관점에서 키-값 쌍의 테이블을 처리하는게 포인터를 고쳐야하는 바이너리 객체 이미지나 직렬화 형식보다 훨씬 단순하다.
  - 테이블을 이용하는 방식은 데이터 형식이 유연하고 변화에 안정적
  - 예상치 못한 키-값 쌍을 만나면 무시하면 그만
  - 필요한 키-값 쌍이 없을 땐 디폴트값 쓰면 됨.

스포너를 사용하면 월드 에디터를 디자인하고 구현하는 과정도 단순화할 수 있다.
  - 에디터는 키-값 쌍의 리스트와 객체 타입 스키마를 처리하는 방법만 알고 있으면 되기 때문.
  - 런타임 엔진과 전혀 코드를 공유할 필요도 없고, 게임 엔진의 구현 세부 사황과 결합도도 낮아짐.

스포너와 아키타입(archetype 원형???)을 사용하면 게임 디자이너와 프로그래머는 유연성과 재량을 함께 누릴 수 있다.
  - 디자이너는 프로그래머의 도움을 받지 않고도 새 게임 객체 타입 스키마를 월드 에디터에서 직접 정의할 수 있다.
  - 프로그래머는 이렇게 추가된 새 객체 타입에 대한 런타임 구현을 나중에 구현해도 됨.
---
## 14.4 게임 월드의 로딩과 스트리밍

---
## 14.5 객체 참조와 월드 질의

---
## 14.6 실시간 게임 객체 업데이트

---
## 14.7 이벤트와 메시지 전달

---
## 14.8 스크립트

---
## 14.9 하이레벨 게임 흐름

---
