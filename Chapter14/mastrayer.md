# 14. 런타임 게임플레이 기반 시스템

## 14.1 게임플레이 기반 시스템의 컴포넌트
대부분의 게임 엔진은 게임의 고유한 규칙과 목표, 동적 월드 구성 요소들을 만드는 기반으로 쓰이는 여러 런타임 소프트웨어 컴포넌트를 제공.

게임 엔진과 게임을 나누는 선을 긋는다면, 이 시스템은 선 바로 아래에 위치함.

엔진마다 형태는 다르지만, 공통적으로 다음과 같은 주요 하위 시스템을 제공.

- 런타임 게임 객체 모델 - 게임 디자이너가 월드 에디터를 통해 가상의 게임 객체 모델을 실제로 구현하는 부분
- 레벨 관리 및 스트리밍 - 게임플레이가  벌어지는 가상 월드의 컨텐츠를 불러오고 내리는 시스템
- 실시간 객체 모델 업데이트
- 메세지와 이벤트 처리
- 스크립트
- 목적 및 게임 흐름 관리 - 플레이어의 목적과 전체적인 게임의 흐름을 관리하는 하위 시스템. 목적들을 한데 묶어서 챕터로 구성하는 경우가 많음.
- 런타임 객체 모델
  - 동적으로 게임 객체 생성/파괴
  - 로우레벨 엔진 시스템과 연동 - 물리엔진, 렌더링엔진, 애니메이션 등 다른 하위 엔진 시스템에 접근할 수 있게함.
  - 객체 행동 실시간 시뮬레이션
  - 새로운 게임 객체 타입을 정의할 수 있는 기능 - 월드 에디터에서 새로운 객체 타입을 쉽게 추가하고 사용할 수 있도록 유연한 게임 객체 모델을 갖는 것이 중요. 
  - 고유 객체 식별자(id) - 정수가 제일 효율적이지만 알아보기 난해함. 해시 식별자를 권장함.
  - 게임 객체 질의(query) - 게임 월드 내의 객체들을 찾을 수 있는 방법을 제공해야함.
  - 게임 객체에 대한 참조(reference)
  - 유한 상태 기계에 대한 지원
  - 네트워크 레플리케이션 - 네트워크 멀티플레이어 게임인 경우 기계 한 대만 게임 객체를 소유하고 관리하는 것이 보통이다(?). 그렇지만 객체의 상태는 모든 기계들에 복제되어 일관된 모습으로 볼 수 있어야 함.
  - 게임을 저장하고 불러오는 기능/객체의 영속성(persistence) - 월드 내의 객체들의 현재 상태를 디스크에 저장하고 나중에 불러올 수 있게 하기. 네트워크 레플리케이션을 구현하는 방법의 일환일 수도 있음.
  런타임 타입 식별(RTTI), 리플렉션, 추상 생성같은 언어의 기능들이 주로 쓰임.
---
## 14.2 런타임 객체 모델 구조
런타임 객체 모델은 반드시 월드 에디터에서 보이는 객체 타입과 속성, 행동을 충실하게 재현해야 한다.
다양한 디자인 방식이 쓰이지만, 대부분은 다음의 두 가지 기본적인 구조 중 한 가지를 따른다.

  - 객체 중심적
    툴 측면의 게임 객체 하나는 런타임에서 클래스 인스턴스 한 개로 표현되거나, 연관 있는 적은 숫자의 인스턴스 집합으로 표현됨.

  - 속성 중심적
    게임 객체들은 각각 고유 ID로만 표현됨. 각 게임 객체의 속성들은 속성 타입별로 데이터 테이블에 나뉘어 담겨 있으며, 접근은 객체 ID를 이용.
    게임 객체의 행동은 그 객체를 이루는 속성들의 집합에 의해 간접적으로 정의됨. (ex. Health 속성을 갖는 객체는 손상되거나 체력을 잃을 수 있다)
---
### 14.2.1 객체 중심 구조
논리적인 게임 객체 하나를 클래스 인스턴스 하나나 연관된 인스턴스들의 집합으로 구현.

- 14.2.1.1) C로 구현한 단순한 객체 기반 모델: 하이드로 썬더
  world 객체가 필요한 애들을 멤버로 다 가지고 있음.
---
- 14.2.1.2) 거대 단일 클래스 계층
  객체 타입 분류를 생물 분류학과 비슷하게 사용하려는 것은 자연스럽다.
  처음엔 작고 단순한 형태로 시작하지만, 점점 깊고 넓어지는 구조를 가지게 됨. 이걸 거대 단일 클래스 계층이라고 부른다.
  하나의 공통 베이스 클래스를 거의 모든 게임 객체들이 상속하는 경우 이런 계층이 된다. 대표적으로 언리얼.
---
- 14.2.1.3) 깊고 넓은 계층 구조의 문제점
  - 클래스들을 이해하기 힘들고 유지보수가 어려움.
    어떤 클래스를 이해하려면 그 부모들도 모두 이해해야 하기 때문. 찾기 힘든 사이드가 발생할 가능성 매우 높음.

  - 여러 계열의 분류 구조 구현 불가
    트리의 한 레벨은 오직 한 종류의 기준에 의해서만 분류된다. 
    - (색깔로 구분중인 레벨에서 다리 갯수가 다른 형질을 분류하려면 완전히 다른 트리 구조가 필요하다)

    (그림 봐)

  - 다중 상속: 죽음의 다이아몬드
    수륙양용 문제를 해결하기 위해서 다중 상속을 활용? 
      - 죽음의 다이아몬드

  - 믹스인 클래스
    제한된 형태의 다중 상속. 클래스는 여러 개의 부모를 가질 수 있지만, 오직 한 개의 조부모 클래스를 가질 수 있다.(그림봐)

    상속보단 합성, 조합임.
    
  - 버블업 효과
    클래스를 처음 설계할 때는 단순하면서 꼭 필요한 기능만 외부에 노출한다.
    하지만 기능이 하나 둘 더해짐에 따라 서로 연관없는 클래스들 사이에 불필요한 코드가 공유됨.
    (책 예시가 미쳤따. 와우)
---
- 14.2.1.4) 합성을 통해 계층 구조를 단순하게 유지
  - 클래스가 거대하고 복잡해지는 주요한 이유는 is-a 관계를 남요하기 때문.
  - has-a 관계를 합성(composition)이라고 부른다. 
    - A가 B를 직접 포함하거나 B에 대한 포인터나 참조를 포함.
    - 엄격한 의미에서 합성은, A가 B를 소유해야함. (A가 생성될 때 B도 자동으로 생성되어야 한다는 뜻)
    - 포인터나 참조를 사용해 다른 클래스의 생성과 파괴를 직접 관리하지 않게 할 수도 있는데, 이것을 조합(aggregation)이라고 부름.

  - is-a 관계를 has-a 관계로 바꾸기
    계층의 깊이와 너비를 줄이고 복잡도를 감소시키는 데 이 방법이 유용하게 쓰인다.
    (예시)
    쉽게 설명하자면, RenderableObject는 Movable이고, GameObject이다. 가 아니라
    GameObject가 필요한 클래스(컴포넌트)를 가진 허브같은 역할을 하도록 수정한다.

  - 컴포넌트 생성과 소유권
    이렇게 has-a 관계로 리팩토링하면, 허브 클래스가 컴포넌트들의 수명을 관리하게 된다.
    허브 클래스는 포인터를 전부 NULL로 설정해놓고, 이걸 상속받는 클래스가 오버라이딩해서 필요한 컴포넌트를 생성해서 쓰도록 구현.
---
- 14.2.1.5) 제네릭 컴포넌트
  허브보다 구현하기 까다롭지만 더 유연한 방법으로, 루트 클래스에 제네릭 연결 리스트를 두어 컴포넌트를 관리하는 방법이 있다.
  이렇게 하면 어떤 타입의 컴포넌트들이 있는지 크게 신경쓰지 않아도 되며, 새 타입의 컴포넌트를 만들 때 클래스 수정이 필요하지 않을 수도 있다.
---
- 14.2.1.6) 순수 컴포넌트 모델
  컴포넌트화 개념을 끝까지 밀어 붙여서 루트의 GameObject 클래스의 모든 기능을 컴포넌트로 덜어낸다고 가정.
  그러면 GameObject 클래스는 논리적인 행동이 없는 껍데기에 불과하게 될 것.
  이 때, 이 클래스를 없애도 괜찮지 않을까? 그러면 각 컴포넌트들은 해당 객체의 고유 ID를 가지고 논리적인 그룹으로 묶일 수 있다. 
  객체 ID를 가지고 컴포넌트들을 빠르게 검색할 수 있다면, 허브 클래스를 둘 필요가 없다.

  하지만 문제점도 있다.
    - 여전히 다양한 게임 객체들의 콘크리트 타입(??)을 정의할 방법이 있어야 함.
    - 허브와 다르게 컴포넌트 인스턴스 생성은 어떻게?
      - 게임 객체 타입마다 가상 함수가 있는 팩토리 클래스를 하나씩 만들어서 해결.
      - 데이터 주도 모델을 사용해서, 객체 타입들을 테긋트로 정의하고 이것을 엔진이 읽어서 인스턴스 생성할 때마다 참조.
    - 컴포넌트간 통신이 문제. 허브는 통신 중계 역할도 겸했었음.
      - 같은 객체에 속하는 다른 ㅌ컴포넌트들을 빠르게 찾아낼 방법이 있어야한다.
    - 다른 게임 객체로 메세지 보내는 일 또한 까다롭다.
      - GameObject가 없어서 어떤 컴포넌트와 통신해야하나?
---
### 14.2.2 속성 중심적 구조
1. 객체 중심 관점 - 속성과 행동을 가진 객체.
2. 속성 중심 관점 - 속성마다 테이블을 하나씩 만들고, 각자 속성마다 객체 ID를 가짐. (RDB같은 느낌)

- 가진 것이 속성들의 테이블뿐이면 어떻게 행동을 구현할까?
  - 속성들 그 자체 안에서 구현
  - 스크립트 코드를 통해서 구현
---
- 14.2.2.1) 속성 클래스를 통해 행동 구현
  각 속성 클래스는 하드코딩된 메소드를 통해 행동을 제공.
  어떤 게임 객체의 전체적인 행동은 그 객체에 포함된 모든 속성들의 행동이 합쳐져 결정됨.
---
- 14.2.2.2) 스크립트를 통해 행동 구현
  속성 값들은 그냥 DB에 있고, 객체의 행동을 스크립트로 따로 구현.
  게임 객체는 script id를 가지고 특정 스크립트가 실행될 수 있도록 매핑시킴.
---
- 14.2.2.3) 속성과 컴포넌트
  속성 객체는 컴포넌트와 밀접한 관계. 논리적 게임 객체 하나를 이루는데 여러 개의 하위 객체가 사용됨.
  여러 하위 객체에 의해 논리적 게임 객체가 구성되고, 이것들에 의해 행동이 정해지는 디자인을 속성 중심 디자인 혹은 순수 컴포넌트 모델(14.2.1.6)이라고 부름. 똑같다.
---
- 14.2.2.4) 속성 중심 디자인의 장단점
  - 정말 사용되는 속성만 저장되기 때문에 메모리를 적게 쓰는 경향이 있다.
  - 데이터 주도 방식으로 구현하기 더 쉬워서 컴파일 없이 새 속성을 쉽게 정의 가능.
  - 캐시 친화적이기도 하다.
    - array-of-structs(구조체의 배열) vs struct-of-arrays(배열의 구조체)
  - 하지만 게임 객체가 단지 속성들을 모은 덩어리에 불과하면, 속성 사이에 관계를 강제하기가 어려워진다. 
    - 자잘한 속성의 행동을 맞춘다고 해서 원하는 행동이 되도록 구현하기 힘들다.
  - 디버깅 또한 매우 힘들다.
