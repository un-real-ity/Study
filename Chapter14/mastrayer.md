# 14. 런타임 게임플레이 기반 시스템

## 14.1 게임플레이 기반 시스템의 컴포넌트
대부분의 게임 엔진은 게임의 고유한 규칙과 목표, 동적 월드 구성 요소들을 만드는 기반으로 쓰이는 여러 런타임 소프트웨어 컴포넌트를 제공.

게임 엔진과 게임을 나누는 선을 긋는다면, 이 시스템은 선 바로 아래에 위치함.

엔진마다 형태는 다르지만, 공통적으로 다음과 같은 주요 하위 시스템을 제공.

- 런타임 게임 객체 모델 - 게임 디자이너가 월드 에디터를 통해 가상의 게임 객체 모델을 실제로 구현하는 부분
- 레벨 관리 및 스트리밍 - 게임플레이가  벌어지는 가상 월드의 컨텐츠를 불러오고 내리는 시스템
- 실시간 객체 모델 업데이트
- 메세지와 이벤트 처리
- 스크립트
- 목적 및 게임 흐름 관리 - 플레이어의 목적과 전체적인 게임의 흐름을 관리하는 하위 시스템. 목적들을 한데 묶어서 챕터로 구성하는 경우가 많음.
- 런타임 객체 모델
  - 동적으로 게임 객체 생성/파괴
  - 로우레벨 엔진 시스템과 연동 - 물리엔진, 렌더링엔진, 애니메이션 등 다른 하위 엔진 시스템에 접근할 수 있게함.
  - 객체 행동 실시간 시뮬레이션
  - 새로운 게임 객체 타입을 정의할 수 있는 기능 - 월드 에디터에서 새로운 객체 타입을 쉽게 추가하고 사용할 수 있도록 유연한 게임 객체 모델을 갖는 것이 중요. 
  - 고유 객체 식별자(id) - 정수가 제일 효율적이지만 알아보기 난해함. 해시 식별자를 권장함.
  - 게임 객체 질의(query) - 게임 월드 내의 객체들을 찾을 수 있는 방법을 제공해야함.
  - 게임 객체에 대한 참조(reference)
  - 유한 상태 기계에 대한 지원
  - 네트워크 레플리케이션 - 네트워크 멀티플레이어 게임인 경우 기계 한 대만 게임 객체를 소유하고 관리하는 것이 보통이다(?). 그렇지만 객체의 상태는 모든 기계들에 복제되어 일관된 모습으로 볼 수 있어야 함.
  - 게임을 저장하고 불러오는 기능/객체의 영속성(persistence) - 월드 내의 객체들의 현재 상태를 디스크에 저장하고 나중에 불러올 수 있게 하기. 네트워크 레플리케이션을 구현하는 방법의 일환일 수도 있음.
  런타임 타입 식별(RTTI), 리플렉션, 추상 생성같은 언어의 기능들이 주로 쓰임.
---
## 14.2 런타임 객체 모델 구조
런타임 객체 모델은 반드시 월드 에디터에서 보이는 객체 타입과 속성, 행동을 충실하게 재현해야 한다.
다양한 디자인 방식이 쓰이지만, 대부분은 다음의 두 가지 기본적인 구조 중 한 가지를 따른다.

  - 객체 중심적
    툴 측면의 게임 객체 하나는 런타임에서 클래스 인스턴스 한 개로 표현되거나, 연관 있는 적은 숫자의 인스턴스 집합으로 표현됨.

  - 속성 중심적
    게임 객체들은 각각 고유 ID로만 표현됨. 각 게임 객체의 속성들은 속성 타입별로 데이터 테이블에 나뉘어 담겨 있으며, 접근은 객체 ID를 이용.
    게임 객체의 행동은 그 객체를 이루는 속성들의 집합에 의해 간접적으로 정의됨. (ex. Health 속성을 갖는 객체는 손상되거나 체력을 잃을 수 있다)
---
### 14.2.1 객체 중심 구조
논리적인 게임 객체 하나를 클래스 인스턴스 하나나 연관된 인스턴스들의 집합으로 구현.

- 14.2.1.1) C로 구현한 단순한 객체 기반 모델: 하이드로 썬더
  world 객체가 필요한 애들을 멤버로 다 가지고 있음.
---
- 14.2.1.2) 거대 단일 클래스 계층
  객체 타입 분류를 생물 분류학과 비슷하게 사용하려는 것은 자연스럽다.
  처음엔 작고 단순한 형태로 시작하지만, 점점 깊고 넓어지는 구조를 가지게 됨. 이걸 거대 단일 클래스 계층이라고 부른다.
  하나의 공통 베이스 클래스를 거의 모든 게임 객체들이 상속하는 경우 이런 계층이 된다. 대표적으로 언리얼.
---
- 14.2.1.3) 깊고 넓은 계층 구조의 문제점
  - 클래스들을 이해하기 힘들고 유지보수가 어려움.
    어떤 클래스를 이해하려면 그 부모들도 모두 이해해야 하기 때문. 찾기 힘든 사이드가 발생할 가능성 매우 높음.

  - 여러 계열의 분류 구조 구현 불가
    트리의 한 레벨은 오직 한 종류의 기준에 의해서만 분류된다. 
    - (색깔로 구분중인 레벨에서 다리 갯수가 다른 형질을 분류하려면 완전히 다른 트리 구조가 필요하다)

    (그림 봐)

  - 다중 상속: 죽음의 다이아몬드
    수륙양용 문제를 해결하기 위해서 다중 상속을 활용? 
      - 죽음의 다이아몬드

  - 믹스인 클래스
    제한된 형태의 다중 상속. 클래스는 여러 개의 부모를 가질 수 있지만, 오직 한 개의 조부모 클래스를 가질 수 있다.(그림봐)

    상속보단 합성, 조합임.
    
  - 버블업 효과
    클래스를 처음 설계할 때는 단순하면서 꼭 필요한 기능만 외부에 노출한다.
    하지만 기능이 하나 둘 더해짐에 따라 서로 연관없는 클래스들 사이에 불필요한 코드가 공유됨.
    (책 예시가 미쳤따. 와우)
---
- 14.2.1.4) 합성을 통해 계층 구조를 단순하게 유지
  - 클래스가 거대하고 복잡해지는 주요한 이유는 is-a 관계를 남요하기 때문.
  - has-a 관계를 합성(composition)이라고 부른다. 
    - A가 B를 직접 포함하거나 B에 대한 포인터나 참조를 포함.
    - 엄격한 의미에서 합성은, A가 B를 소유해야함. (A가 생성될 때 B도 자동으로 생성되어야 한다는 뜻)
    - 포인터나 참조를 사용해 다른 클래스의 생성과 파괴를 직접 관리하지 않게 할 수도 있는데, 이것을 조합(aggregation)이라고 부름.

  - is-a 관계를 has-a 관계로 바꾸기
    계층의 깊이와 너비를 줄이고 복잡도를 감소시키는 데 이 방법이 유용하게 쓰인다.
    (예시)
    쉽게 설명하자면, RenderableObject는 Movable이고, GameObject이다. 가 아니라
    GameObject가 필요한 클래스(컴포넌트)를 가진 허브같은 역할을 하도록 수정한다.

  - 컴포넌트 생성과 소유권
    이렇게 has-a 관계로 리팩토링하면, 허브 클래스가 컴포넌트들의 수명을 관리하게 된다.
    허브 클래스는 포인터를 전부 NULL로 설정해놓고, 이걸 상속받는 클래스가 오버라이딩해서 필요한 컴포넌트를 생성해서 쓰도록 구현.
---
- 14.2.1.5) 제네릭 컴포넌트
  허브보다 구현하기 까다롭지만 더 유연한 방법으로, 루트 클래스에 제네릭 연결 리스트를 두어 컴포넌트를 관리하는 방법이 있다.
  이렇게 하면 어떤 타입의 컴포넌트들이 있는지 크게 신경쓰지 않아도 되며, 새 타입의 컴포넌트를 만들 때 클래스 수정이 필요하지 않을 수도 있다.
---
- 14.2.1.6) 순수 컴포넌트 모델
  컴포넌트화 개념을 끝까지 밀어 붙여서 루트의 GameObject 클래스의 모든 기능을 컴포넌트로 덜어낸다고 가정.
  그러면 GameObject 클래스는 논리적인 행동이 없는 껍데기에 불과하게 될 것.
  이 때, 이 클래스를 없애도 괜찮지 않을까? 그러면 각 컴포넌트들은 해당 객체의 고유 ID를 가지고 논리적인 그룹으로 묶일 수 있다. 
  객체 ID를 가지고 컴포넌트들을 빠르게 검색할 수 있다면, 허브 클래스를 둘 필요가 없다.

  하지만 문제점도 있다.
    - 여전히 다양한 게임 객체들의 콘크리트 타입(??)을 정의할 방법이 있어야 함.
    - 허브와 다르게 컴포넌트 인스턴스 생성은 어떻게?
      - 게임 객체 타입마다 가상 함수가 있는 팩토리 클래스를 하나씩 만들어서 해결.
      - 데이터 주도 모델을 사용해서, 객체 타입들을 테긋트로 정의하고 이것을 엔진이 읽어서 인스턴스 생성할 때마다 참조.
    - 컴포넌트간 통신이 문제. 허브는 통신 중계 역할도 겸했었음.
      - 같은 객체에 속하는 다른 ㅌ컴포넌트들을 빠르게 찾아낼 방법이 있어야한다.
    - 다른 게임 객체로 메세지 보내는 일 또한 까다롭다.
      - GameObject가 없어서 어떤 컴포넌트와 통신해야하나?
---
### 14.2.2 속성 중심적 구조
1. 객체 중심 관점 - 속성과 행동을 가진 객체.
2. 속성 중심 관점 - 속성마다 테이블을 하나씩 만들고, 각자 속성마다 객체 ID를 가짐. (RDB같은 느낌)

- 가진 것이 속성들의 테이블뿐이면 어떻게 행동을 구현할까?
  - 속성들 그 자체 안에서 구현
  - 스크립트 코드를 통해서 구현
---
- 14.2.2.1) 속성 클래스를 통해 행동 구현
  각 속성 클래스는 하드코딩된 메소드를 통해 행동을 제공.
  어떤 게임 객체의 전체적인 행동은 그 객체에 포함된 모든 속성들의 행동이 합쳐져 결정됨.
---
- 14.2.2.2) 스크립트를 통해 행동 구현
  속성 값들은 그냥 DB에 있고, 객체의 행동을 스크립트로 따로 구현.
  게임 객체는 script id를 가지고 특정 스크립트가 실행될 수 있도록 매핑시킴.
---
- 14.2.2.3) 속성과 컴포넌트
  속성 객체는 컴포넌트와 밀접한 관계. 논리적 게임 객체 하나를 이루는데 여러 개의 하위 객체가 사용됨.
  여러 하위 객체에 의해 논리적 게임 객체가 구성되고, 이것들에 의해 행동이 정해지는 디자인을 속성 중심 디자인 혹은 순수 컴포넌트 모델(14.2.1.6)이라고 부름. 똑같다.
---
- 14.2.2.4) 속성 중심 디자인의 장단점
  - 정말 사용되는 속성만 저장되기 때문에 메모리를 적게 쓰는 경향이 있다.
  - 데이터 주도 방식으로 구현하기 더 쉬워서 컴파일 없이 새 속성을 쉽게 정의 가능.
  - 캐시 친화적이기도 하다.
    - array-of-structs(구조체의 배열) vs struct-of-arrays(배열의 구조체)
  - 하지만 게임 객체가 단지 속성들을 모은 덩어리에 불과하면, 속성 사이에 관계를 강제하기가 어려워진다. 
    - 자잘한 속성의 행동을 맞춘다고 해서 원하는 행동이 되도록 구현하기 힘들다.
  - 디버깅 또한 매우 힘들다.
---
## 14.3 월드 덩어리 데이터 형식
월드 덩어리(?)에는 정적 요소와 동적 요소가 같이 들어가는 것이 일반적.
동적인 부분엔 게임 객체들을 나타내는 정보가 담겨 있다.

  - 객체 속성들의 초기 값
  - 객체 타입에 대한 지정(ex. 객체 ID)
---
### 14.3.1 바이너리 객체 이미지
객체들을 저장하는 방법 중에는 런타임 메모리를 통째로 파일에 저장하는 방식이 있다. 이렇게 하면 객체를 생성하는 일이 정말로 쉽다(메모리에 불러오기만 하면 모든 객체 이미지를 바로 사용할 수 있기 때문)
하지만 사실은 굉장히 많은 예외때문에 쉽지 않다.
  - 포인터와 가상 테이블 예외 처리
  - 클래스와 인스턴스 내부 데이터의 엔디안 문제
  - 바이너리 객체 이미지는 변경이 힘들고, 변경시 문제 발생 가능성이 큼
  - 하지만 변경이 드문 자료 구조인 메시 데이터나 충돌 기하 형상을 저장하는 데는 좋을 수 있다(?????)
---
### 14.3.2 게임 객체 정보의 직렬화
바이너리로 저장하는 것보다 여러 플랫폼에 이식하기 쉽고 구현도 간편.
각 객체마다 데이터 스트림을 만들어서 반환하는 메서드를 구현하고, 이 데이터를 저장하고 불러와서 사용.

C#과 Java는 XML 형식으로 직렬화하는 기능을 언어 수준에서 지원하지만, C++은 그렇지 않다.

- 직렬화 데이터는 바이너리 이미지가 아니다.
- 더 사용하기 편하고 여러 플랫폼에 옮기기 쉬운 형태로 저장
- XML 형식을 많이 이용. 사람이 읽을 수 있고, 여러 시스템에 지원하고 표준화되어 있으며 계층구조 처리에 적합. (그렇지만 매우 느려서 자체 구현 바이너리 형식을 사용하는 게임 엔진도 있다)

직렬화 기법엔 두 가지 방법이 사용될 수 있다.
1) Base class에 SerializeOut()과 SerializeIn()등의 가상 함수 두 개를 넣고 상속받는 클래스들이 구현하도록 한다
2) 리플렉션 시스템을 구현. 리플렉션 데이터가 있는 모든 객체를 자동으로 직렬화하는 제네릭 시스템 구현
    - 리플렉션 데이터를 생성할 땐, 모든 클래스의 리플렉션 데이터를 생성해야 함.

    - 클래스 데이터 멤버를 정의할 때 매크로를 이용해 리플렉션 정보를 뽑는 가상 함수를 구현하거나, 클래스마다 리플렉션 데이터 구조를 손으로 짜는 방법도 있다.

    - 직렬화 데이터엔 어떤 객체에 대한 정보였는지 클래스나 타입을 나타내는 ID를 포함한다. 그러나 C++에선 이 ID로 클래스 인스턴스를 생성할 수 없다. 그래서 하드코딩이 필요하지만, 이런 언어적 제약을 우회하기 위해 모든 C++ 직렬화 시스템은 클래스 팩토리를 사용한다. 

    - 팩토리를 구현하는 쉬운 방법은, 이름과 인스턴스를 생성하는 함수나 Function object를 매핑시켜둔 테이블을 이용하는 것.
---
### 14.3.3 스포너와 타입 스키마
위의 두 방법은 게임 객체 타입의 런타임 구현에 따라 좌우되기 때문에 월드 에디터가 런타임 구현에 대해 상세히 알아야 한다는 단점이 있다.

그렇기 때문에, 월드 에디터와 런타엠 엔진 코드 간의 결합을 끊으려면 게임 객체에 대한 정보를 구현 중립적인 방식으로 추상화하면 됨(?????)

- 월드 덩어리 데이터 파일에 있는 모든 게임 객체마다 작은 데이터 블록을 저장하는데, 이것을 보통 스포너(spawner)라고 부름 (?????)
- 스포너는 가볍고 데이터만 있는 게임 객체 표현으로, 런타임에 해당 게임 객체의 인스턴스를 생성하고  초기화하는 데 사용됨.
- 스포너에는 툴에서 쓰이는 게임 객체 타입에 대한 ID가 들어있다. 또, 객체 속성들의 초기 값을 저장한 간단한 테이블도 들어 있다. (이 테이블엔 모델-월드 변환이 포함되는 경우가 많다)
- 게임 객체를 스폰할 때, 스포너의 타입을 보고 올바른 클래스 인스턴스가 생성된다. 그 후, 테이블을 참조해 데이터 멤버들을 초기화한다.
- 스포너는 로딩되자마자 객체를 생성하게도, 생성 요청이 올 때까지 가만히 있게 할 수도 있음.
- 예시 보면 게임 객체 생성 외에도 스포너를 월드에서 중요 지점이나 좌표축들을 정의하는데에도 사용했음. (위치 스포너, 로케이터 스포너)
  - AI 캐릭터를 위한 관심 지정을 정의
  - 여러 애니메이션들이 완벽한 동기화를 이뤄 재생하는 기준이 될 좌표축들을 정의
  - 파티클 효과나 오디오 효과의 기준점이 될 위치 정의
  - 경주 트랙에서 웨이포인트 정의
---
#### 14.3.3.1 객체 타입 스키마
게임 객체의 속성들과 행동은 그 타입에 의해 결정됨.
스포너 방식의 디자인을 채용한 게임 월드 에디터에선 게임 객체 타입을 나타낼 때 데이터 기반 방식의 스키마를 사용할 수 있다.

- 스키마는 어떤 타입의 객체를 만들고 편집할 때 알아야 할 속성들을 정의한 것.
- 런타임에는 올바른 게임 객체를 생성하기 위해 툴의 객체 타입을 통해 적절한 클래스(들)을 찾아낸다(???????)
- 스키마 예시 보자

스키마는 에디터에서 어떤 편집 UI를 제공해야 하는가 등에 대한 부가적인 정보 또한 제공한다.
- min, max같이 GUI에서 쓰이는 메타 데이터도 지정 가능.
- 스키마 상속을 지원하는 엔진도 있다. (ex. ID같은건 최상위 스키마에서 정의하고 다른 애들이 상속받기)

---
#### 14.3.3.2 디폴트 속성 값
스키마에는 속성이 굉장히 많이 들어갈지도 모른다. 기본값이 없다면 에디터를 사용하기 많이 힘들겠지?

디폴트 값을 쓰면 문제점이 하나 있다. 개발 도중 디폴트 값이 변경된다면, 변경 전의 객체들이 쓰던 속성의 값은 어떻게 해야할까? -> EZEZ

---
### 14.3.4 스포너와 타입 스키마의 몇 가지 이점
스포너를 게임 객체 구현 부분과 분리해서 얻는 가장 중요한 이점은 단순성, 유연성, 안정성.
  - 데이터 관리 관점에서 키-값 쌍의 테이블을 처리하는게 포인터를 고쳐야하는 바이너리 객체 이미지나 직렬화 형식보다 훨씬 단순하다.
  - 테이블을 이용하는 방식은 데이터 형식이 유연하고 변화에 안정적
  - 예상치 못한 키-값 쌍을 만나면 무시하면 그만
  - 필요한 키-값 쌍이 없을 땐 디폴트값 쓰면 됨.

스포너를 사용하면 월드 에디터를 디자인하고 구현하는 과정도 단순화할 수 있다.
  - 에디터는 키-값 쌍의 리스트와 객체 타입 스키마를 처리하는 방법만 알고 있으면 되기 때문.
  - 런타임 엔진과 전혀 코드를 공유할 필요도 없고, 게임 엔진의 구현 세부 사황과 결합도도 낮아짐.

스포너와 아키타입(archetype 원형???)을 사용하면 게임 디자이너와 프로그래머는 유연성과 재량을 함께 누릴 수 있다.
  - 디자이너는 프로그래머의 도움을 받지 않고도 새 게임 객체 타입 스키마를 월드 에디터에서 직접 정의할 수 있다.
  - 프로그래머는 이렇게 추가된 새 객체 타입에 대한 런타임 구현을 나중에 구현해도 됨.

---
## 14.4 게임 월드의 로딩과 스트리밍
오프라인 월드 에디터(???)와 런타임 게임 객체 모델을 연결시키려면 월드 덩어리를 메모리에 불러오고 필요 없어지면 다시 내릴 방법이 있어야 함.

게임 월드 로딩 시스템은 두 가지 중요한 역할.
  - 게임 월드 덩어리와 기타 필요한 자원을 디스크에서 메모리로 불러오는 파일 I/O 관리
  - 이 자원들에 필요한 메모리를 할당하고 해제하는 것을 관리

---
### 14.4.1 단순한 레벨 로딩
가장 직관적이며, 모든 초창기 게임들이 선택했던 방식.
한 번에 오직 하나의 게임 월드 덩어리(레벨)만 로딩함.
6.2.2.7에서 본 스택 기반 할당자가 무척 잘 어울린다.
- 게임이 처음 시작할 때, 모든 레벨에 걸쳐 공통적으로 사용되는 자원들이 스택의 맨 아래에 불러짐. (이것을 load-and-stay-resident LSR 데이터 라고 부르자)
- LSR 데이터가 완전히 올라오면 스택 포인터의 위치를 기록.
- 월드 덩어리와 그에 부속된 메시, 텍스쳐, 오디오 등 레벨 리소스는 스택에서 LSR 데이터 위에 불러옴.
- 레벨이 바뀔 때, 메모리를 해제하려면 스택 포인터를 LSR 데이터 블록으로 옮기기만 하면 됨.

이 방법으로는 심리스 월드를 구현할 수 없고, 월드 덩어리 한 개만 로딩할 수 있다.
또한 자원을 로딩하는 동안 메모리에 어떠한 게임 월드도 없어서 로딩이 끝나는걸 기다려야함.

---
### 14.4.2 심리스 로딩에 다가가기: 에어 락
다음 레벨을 로딩하는 동안 플레이어가 계속 게임을 즐기게 할 순 없을까?

- 첫 번째 방법
  - 게임 월드를 위한 메모리를 똑같은 두 블록으로 나눈다.
  - 한 쪽 블록엔 플레이할 A 레벨을, 그리고 나머지 블록엔 다음 레벨인 B를 별도의 스레드에서 스트리밍 I/O를 이용해 로딩해놓는다.
  - 이 방법은 한 레벨의 최대 크기가 이전에 비해 절반밖에 안된다는 점.
- 두 번째 방법
  - 월드 메모리를 크기가 다른 두 개의 블록으로 나눔
  - 큰 블록에 '온전한' 게임 월드 덩어리가 들어감. 작은 블록(Air Locks)은 아주 작은 월드 덩어리가 겨우 들어갈 정도.
  - 게임이 시작되면 큰 덩어리와 에어락 덩어리가 로딩.
  - 플레이어는 큰 덩어리를 진행하면서 결국 에어락에 들어가게 됨.
    - 문이나 다른 장애물로 인해 이전의 큰 월드를 보거나 다시 돌아가지 못함.
  - 큰 덩어리는 내려오고 새로운 레벨의 큰 덩어리를 로딩.
    - 로딩동안 에어락 안에서 뭔가 할 거리를 던져줘서 지루하지 않게 하기

---
### 14.4.3 게임 월드 스트리밍
에어락도 싫다. 그냥 스무스하게 광활한 월드를 로딩하게 하는게 제일 좋다.

스트리밍을 구현하는 방법은 여러 가지가 있지만, 주 목적은 동일하다.
- 게임 플레이를 하는 동안 데이터를 로딩하기
- 메모리 단편화를 최소화하도록 메모리를 관리하지만 동시에 필요한 데이터를 로딩하고 해제할 수 있어야 함

최신 하드웨어는 이전에 비해 훨씬 큰 메모리를 가지고 있기 때문에 여러 개의 월드 덩어리를 동시에 메모리에 올려놓을 수 있다.
- A, B, C 월드를 버퍼에 로딩 후, A 월드를 플레이
- B 월드에 진입 후, A가 충분히 멀어져 보이지 않을 때 A를 내리고 D를 로딩
- 반복반복

위의 방법이 가진 단점으론, 각 월드들은 크기에 심한 제약을 가짐. (모든 월드의 크기가 비슷해야함)
그래서 메모리를 나눌 때 더 잘개 쪼개면 조금 낫다.
- 크기가 큰 월드 덩어리를 스트리밍하는 대신, 전경, 메시, 텍스쳐, 애니메이신 등 모든 게임 자원을 같은 크기의 블록이 되도록 쪼갠다.
- 6.2.2.7에 나오는 덩어리가 큰 풀 기반 메모리 할당 시스템을 사용하면 메모리 단편화 걱정 없이 리소스를 올리고 내리는게 가능.

---
#### 14.4.3.1 불러올 자원 결정
잘개 쪼개는 스트리밍을 구현할 때, 어떤 자원을 로딩해야 하는가 라는 문제를 먼저 생각해봐야 한다.
'언차티드: 엘도라도의 보물(UDF)'에서는 단순한 레벨 로드 지역 시스템을 이용함.

- UDF의 배경은 지리적으로 분명히 구분되면서, 연속적인 게임 월드임.
- 각 월드는 하나의 일관된 월드 공간에 위치하지만, 지형적으로 인접한 수많은 덩어리로 나뉨.
- 지역이라 불리는 단순 볼록 볼륨이 각 덩어리를 감싸며, 지역은 서로 약간씩 겹침.
- 지역마다 필요한 리소스를 가지고 있는데, 플레이어가 현재 속한 지역에 따라 필요한 리소스를 올리고 내림.
- 내려간 리소스는 절대 볼 수 없어야하고, 올라오는 중인 리소스는 보이지 않도록 지역을 잘 설계해야함.

---
### 14.4.4 객체 생성을 위한 메모리 관리
월드가 메모리에 올라가면, 동적인 객체들을 생성하는 과정을 처리해야함.
거의 대부분의 엔진은 객체를 인스턴싱하고 파괴하는 스포닝 시스템이 있다.
- 동적 할당은 느린 과정이라 최대한 효울적으로 만드는 것이 이슈.
- 또한 메모리 단편화에 따른 OOM을 방지하는 것도 이슈

---
#### 14.4.4.1 객체 생성을 위한 오프라인 메모리 할당 사용
매우 과격한 방법으로, 월드 로딩 직후에만 동적 할당을 한다. (플레이 도중에 객체 생성이나 파괴가 안됨)

무식한 방법같지만, 메모리 단편화를 방지할 수 있다.
- 메모리 사용량을 미리 계산할 수 있다
- 일정한 양의 메모리만을 사용

이 말은, 게임 객체들이 사용할 메모리를 월드 에디터가 오프라인에 할당할 수 있고(??????????), 이것을 월드 덩어리 데이터 안에 포함시킬 수 있다는 뜻.
- 모든 게임 객체들은 월드와 리소스를 로딩할 때 사용했던 메모리를 사용하게 되고, 단편화를 일으키지 않는다.
- 하지만 게임 디자이너의 재량에 상당한 지장을 준다. 
  - 동적 객체를 흉내내기 위해, 처음 객체를 로딩했을 땐 보이지 않는 상태로 잠자게 만듬.
  - 사용할 때 보이게 만들면 스폰된 것처럼 보임.

---
#### 14.4.4.2 객체 생성을 위한 동적인 메모리 관리
주된 문제는 메모리 단편화.
- 크기가 다른 여러 타입의 객체들이 있을 수 있고, 같은 타입의 객체라도 인스턴스 크기가 다를 수 있기 때문에 풀 할당자를 사용할 수 없음.
- 생성과 파괴는 순서가 없기 때문에 스택 할당자도 사용할 수 없음
- 단편화에 취약한 힙 할당자뿐.... 이지만 대응 방법이 있긴 함.
  - 객체 타입마다 하나의 메모리 풀 사용
    - 정확히는 객체 타입이 아닌, 객체 크기마다 풀을 따로 관리하면 됨.
    - 메모리 단편화는 해결되더라도..
    - 크기에 비례해 늘어나는 풀 관리는 어떻게?
    - 풀의 크기는 어떻게 하냐
    - 하지만 성공한 엔진들이 여럿 있ㄲ다.

  - 작은 메모리 할당자
    - 게임 객체의 크기보다 조금 큰 할당 단위의 메모리 풀을 사용.
    - 풀마다 잠재적으로 낭비하는 메모리가 있다는 단점
    - 풀 갯수를 상당히 줄일 수 있다는 장점
    - ex) 풀의 할당 크기를 8, 16, 32, 64, 128, 256, ... 등으로 만든다.
    - 낭비되는 메모리가 있어도 단편화를 해결할 수 있어서 꽤 괜찮은 방법이다.

  - 메모리 재배치
    - 단편화를 처리하는 다른 방법으로, 핵심을 직접 공략하는 방법.
    - 5.2.2.2

---
### 14.4.5 게임 저장
디스크나 메모리에서 게임 월드의 상태를 불러올 수 있다는 점에서 게임 저장 시스템은 월드 덩어리 로딩 시스템과 비슷하다고 볼 수 있다.
하지만 저장 시스템과 월드 로딩 시스템은 요구 조건이 서로 다르기 때문에 따로 구현되는 경우가 대부분.
- 월드 덩어리 로딩 시스템
  - 월드 안 모든 동적 객체의 초기 상태를 담고 있다.
  - 이에 더해 모든 정적 월드 요소에 대한 완전한 정보를 담고 있기도 함.
  - 배경 메시와 충돌 데이터 등의 정적 정보는 크기 때문에 월드 덩어리는 여러 파일로 구성되는 경우도 있고, 크기가 큼.
- 게임 저장 시스템
  - 월드 안 게임 객체의 현재 상태를 저장해야 함은 비슷하다.
  - 하지만 월드 덩어리를 읽어서 알 수 있는 데이터를 중복 저장할 필요는 없다(ex. 게임 저장 파일에 정적 기하 형상을 담을 필요가 없다)
  - 모든 객체가 아닌, 필요한 객체에 대한 정보만 저장하면 됨.

---
#### 14.4.5.1 체크 포인트
체크 포인트라고 부르는 특정한 지점에서만 저장할 수 있게 하는 방식.
- 게임의 상태 대부분이 각 체크포인트 주변의 월드 덩어리에 저장됨.
- 어떤 상황이어도 데이터가 거의 항상 똑같기 때문에 저장 파일에 담을 필요가 없다(????)

---
#### 14.4.5.2 자유 저장
체크포인트에 비해 저장 파일의 크기가 상당히 크다.
게임 플레이에 영향이 있는 모든 게임 객체의 현재 위치와 내부 상태를 저장해야하고, 다시 시작할 때 원래대로 복원되어야 함.

근본적으로 월드 덩어리 데이터와 비슷하지만, 정적인 구성 요소만 빠질 뿐이다.
파일의 용량을 줄이기 위해 근사치를 쓰거나 생략을 많이 함.

---
## 14.5 객체 참조와 월드 질의

---
## 14.6 실시간 게임 객체 업데이트

---
## 14.7 이벤트와 메시지 전달

---
## 14.8 스크립트

---
## 14.9 하이레벨 게임 흐름

---
