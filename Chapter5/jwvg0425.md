# Engine Support Systems

## Subsystem Start-up and Shut-down

게임 엔진은 여러 서브시스템으로 구성되는데, 이 서브시스템들의 초기화 순서를 정해줘야 한다.

문제는 C++에서 전역, 스태틱 클래스 인스턴스들의 생성자, 소멸자 실행 순서는 예측이 불가능하다는 것. 이 때문에 그냥 이렇게 구현하면 안 된다.

```C++
class RenderManager
{
public:
  static RenderManager& get()
  {
    static RenderManager sSingleton;
    return sSingleton;
  }

  RenderManager()
  {
    // 이런 식으로 생성자에서 이 서브시스템이 의존성을 갖고 있는 다른 서브시스템을 초기화시켜준다.
    VideoManager::get();
    TextureManager::get();
  }
};
```

내부에서 포인터 써서 동적할당 하는 경우도 있는데, 이건 1. 소멸자 순서 제어가 안 된다 2. get 첫 호출이 언제일지 모르는데 이 때 비용이 큰 동적 할당을 하는 건 문제가 될 수 있다 때문에 안하는게 좋음

## 단순한 접근법

static 이런거 안 쓰고 그냥 단순무식하게 하는게 제일 나을 수도 있음

```C++
class RenderManager
{
public:
  RenderManager()
  {
  }
  
  ~RenderManager()
  {
  }

  void startUp()
  {
  }

  void shutDown()
  {
  }
};

RenderManager gRenderManager;
PhysicsManager gPhysicsManager;
Animationmanager gAnimationManager;

int main()
{
  gRenderManager.startUp();
  gPhysicsManager.startUp();
  gAnimationManager.startUp();

  game.run();

  gaAnimationManager.shutDown();
  gPhysicsManager.shutDown();
  gRenderManager.shutDown();
}

```

이런 식으로 그냥 main함수에서 필요한 서브시스템 호출 순서랑 해제 순서 다 적어놓고 필요할때마다 추가하는게 오히려 관리하기 편하다~

## 메모리 관리

메모리는 다음 두 가지 측면에서 성능에 영향을 끼친다.

1. 동적 메모리 할당: malloc이나 new연산은 기본적으로 매우 느리다. 동적 할당을 피하든 커스텀 메모리 할당자를 만들든 해서 할당 비용을 낮춰야 함
2. 현대적인 CPU들의 성능은 종종 메모리 접근 패턴에 의해 결정된다. 데이터가 작고 연속된 공간에 배치되어 있다면 CPU가 훨씬 빠르게 동작함(캐시 히트)

### 동적 할당 최적화

malloc이나 free는 유저 모드와 커널 모드간의 컨텍스트 스위칭을 필요로 하는데, 이건 엄청나게 비용이 크다. 따라서 힙에 할당하는 건 항상 최소화하고 타이트한 루프 내부에서 할당은 반드시 피해야한다.

하지만 동적 할당을 아예 안할 수는 없고, 그래서 커스텀한 메모리 할당자를 만드는게 좋다.

커스텀 메모리 할당자는 미리 할당된 메모리 블록에서 메모리를 가져오게 구현할 수 있고 이는 컨텍스트 스위칭을 동반하지 않으니 비용이 훨씬 싸다.  또, 커스텀 메모리 할당자는 게임에 특화된 몇몇 패턴에 대해 빠르게 동작하도록 최적화를 할 수 있기 때문에 제너럴하게 동작하게 설계된 메모리 할당자에 비해 훨씬 높은 성능을 기대할 수 있다.

#### Stack-based allocator

많은 게임들이 메모리를 stack같은 느낌으로 할당하고 사용한다.

stack-based allocator는 구현하기도 쉽고 강력하다. 말 그대로 메모리를 큰 덩어리로 할당받은 다음에 메모리 할당 요청이 들어오면 이 덩어리를 이용해서 스택 형태로 할당하고 해제해주면 됨.

중요한 건 스택 기반으로 할당할 경우 메모리 할당 해제를 마음대로 할 수 없고, 할당한 순서의 반대 방향으로만 할 수 있다는 것.

스택에서 양쪽 끝부터 할당하는 방식의 Double-Ended Stack Allocator로 구현할 수도 있다. 이렇게 할 경우 양쪽 방향에서 할당이 가능하므로 좀 더 유연한 할당이 가능함.

#### Pool Allocator

크기가 동일한 메모리 객체들을 할당하고 해제해줄 때는 Pool Allocator가 유용하다. pool allocator는 큰 덩어리를 할당 받은 다음 그걸 동일한 크기의 메모리 사이즈로 분할해서 할당한다.

할당 / 해제는 단순히 사용되지 않고 있는 블록들을 관리하는 링크드 리스트에서 하나를 꺼내서 쓰고, 다시 링크드 리스트에 집어넣고 하는 과정으로 O(1)에 간단하게 수행 가능.

이 때 링크드 리스트 관리를 객체 메모리 크기 >= 포인터 크기인 경우 사용되지않고 있는 블록(이하 free block)에 다음 free block의 위치를 기록해두면 별도의 할당 없이 관리가 가능하다.

만약에 객체 메모리 크기가 포인터 크기보다 작다면, 그 바이트수에 맞춰서 다음 free block의 인덱스를 기록하는 방식으로 하면 객체 메모리 크기가 k바이트일 때 2^k개의 원소까지 추가적인 공간 없이 관리가능하다.

#### Aligned Allocation

변수들은 그 크기에 따라 address align 조건이 필요하다. 따라서 메모리를 할당할 때에도 이 align 조건을 고려해서 할당해주어야한다. 구현하긴 어렵지 않은데, 단순히 원래 요청받은 양보다 좀 더 많은 양을 할당해준 다음 align조건에 맞게 주소를 shift해주면 된다. 널널하게 align - 1 바이트 만큼 값을 추가로 할당해주면 항상 shift해줄 수 있다.

이건 align 사이즈가 `align`일 때 `(addr + align - 1) & ~(align - 1)` 으로 쉽게 계산 가능.

이제 이렇게 align한 주소를 다시 할당 해제해줄 땐 어떻게 하면 될까? 기존 주소 위치를 다시 찾아야하는데 그냥 shifted된 값만 보고 이걸 찾긴 어렵다. 간단한 방법은 shift된 값을 메모리 할당자가 찾을 수 있는 위치에 기록해두는 것이다. align-1 바이트만큼의 추가 공간을 할당하니까 이 추가 공간에 잘 기록해두면 찾을 수 있을 것이다. 1바이트만 있어도 0~255까지의 값을 기록할 수 있으므로 aligned 값 256까지도 1바이트로 커버가 가능하다. 따라서, 주소 p에 대해 p-1 위치에 shifted된 크기가 얼마인지 기록해두면 이 정보를 바탕으로 원래 주소를 복구해서 할당 해제해주면 된다.

문제는, 이미 주소가 align되어있는 상황이면 p-1번 위치를 사용할 수가 없게 된다. 그러니 p-1번 위치를 쓰기 위해서, 항상 추가로 1바이트를 더 할당해주자. align-1 바이트만큼이 아니라 align바이트만큼을 할당해주고, shift값이 0~align-1이 아니라 1~align이 되게 만들어주는 것이다. 그러면 p-1번째 위치를 통해 항상 복구 가능하다. 만약 align값을 256보다 더 크게도 가능하게 하려면 이보다 더 많은 추가 공간을 할당해주면 된다.

#### Single-Frame and Double-Buffered Memory Allocators

게임은 한 프레임에만 할당해서 사용하고 해제하는 패턴이 흔히 사용된다. 이런 임시 데이터 할당에는 Single-frame Allocator가 유용하다. single-frame allocator는 stack allocator랑 똑같이 할당하는데 매 프레임마다 그냥 초기화 시켜주는 방식으로 동작하는 것. 할당받은 메모리를 다음 프레임까지 참조하는 실수만 안 하면 효율적이고 좋다. free 신경 안써도 자동으로 잘 되고 좋음.

Double-buffered는 frame i에 할당된게 frame (i+1)까지 사용되게 해줌. 이것도 간단한데 그냥 stack allocator 두 개 만들어놓고 매 프레임마다 이번 할당에 사용할 순서 핑퐁해가면서 쓰는 것임

### 메모리 파편화

메모리 할당 해제하다 보면 파편화가 생긴다. 파편화는 메모리가 할당될 때 연속된 공간을 부여받아야한다는 것 때문에 사용가능한 메모리 공간은 많이 있음에도 불구하고 그게 연속해있지 않아서 할당할 수 없는 상황에 빠지는 걸 말함.

#### Avoiding Fragmentation with Stack and Pool Allocators

stack, pool 할당자는 당연히 파편화 이슈로부터 자유롭다. stack은 애초에 연속한 형태로만 할당을 하고, pool은 할당하는 크기가 동일한 고정 크기의 블록이기 때문에 파편화가 생길 수 없기 때문.

#### Defragmentation and Relocation

stack, pool 할당자를 쓸 수 없는 상황(할당 크기도, 순서도 제멋대로)에서는 어떻게 해결하면 좋을까? 이렇땐 주기적인 Defragmentation을 이용한다. 간단한 방법은 그냥 띄엄띄엄 존재하는 할당된 블록들 위치를 연속한 위치에 오게 잡아당겨주는(shift) 것. 이렇게 하면 할당 안 된 덩어리들이 뭉쳐서 존재하게 되니까 파편화가 해결된다.

다만, 이렇게 Defragmentatiton을 하고 나면 포인터 위치가 전부 바뀌게 되는데, 기존에 메모리 위치를 가리키고 있는 포인터들을 찾아서 갱신해주는 작업이 쉽지 않다.

몇 가지 선택지가 있다.

1. 기존 메모리 위치 가리키던 포인터 전부 다 찾아서 새 위치로 변경해준다. 근데 특정 주소 가리키는 raw pointer를 다 찾는다는게 힘들다.

2. 스마트 포인터 같은 개념을 사용한다. 즉, 가리키고 있는 위치를 감싼 클래스를 만들어서 이 클래스 내부의 값을 수정해주는 형태. 이건 클래스 생성하거나 할때 전역 링크드 리스트에 이 포인터 등록해두거나 하면 defragmentation 과정에서 값을 수정해주기 쉽다.

3. handle을 사용. handle과 pointer 관계를 나타내는 table을 생성해두고 table을 고친다. 사용하는 쪽에서는 handle을 이용해 접근한다. 이렇게 하면 마찬가지로 사용자는 영향을 받지 않는다.

하지만 서드파티 라이브러리를 사용하는 경우는 할당해준 메모리 위치를 마음대로 바꿀 수 없는 경우가 있다. 이런 경우에 대응해주기 위해 서드파티용으로 위치 변경을 하지 않는 메모리 블록과 위치 변경이 일어날 수 있는 메모리 블록을 구분해서 할당해주는 방법이 있다.


#### Amortizing Defragmentation Costs

한 프레임에 이걸 전부 수행하는 건 너무 느리고 비싼 연산이다. 꼭 이렇게 해줄 필요가 없기 때문에, 매 프레임마다 8블록 혹은 16블록 정도의 메모리만 shift해줘도 충분하다. 이런 식으로 나눠서 해도 어지간해서는 파편화되는 속도가 이걸 다시 모아주는 속도를 넘어가서 문제가 생기는 일이 발생하지 않기 때문.

## 컨테이너

다양한 컨테이너가 있다

- 배열: 연속된 메모리 공간, 고정된 크기, 랜덤 엑세스.
- 동적 배열: 배열이랑 같은데 크기가 바뀔 수 있다
- 링크드 리스트: 연속되지 않은 공간, 순차적 엑세스, 빠른 삽입 삭제
- 스택: LIFO
- 큐: FIFO
- 데크: 앞뒤에서 큐
- Tree: 트리 구조. 싸이클 없는 무향 그래프
- BST: 특정 조건에 맞춰서 왼쪽 자식, 오른쪽 자식 분류. 높이를 O(logn)으로 유지하기 위해 AVL Tree, splay tree, red-black tree 등의 형태로 구현한다
- Binary heap: 보통 우선순위 큐 만들 때 이용. 힙
- Priority queue: 우선순위에 따라 pop 순서가 정렬되는 큐
- Dictionary: key-value 구조
- Set: unique한 key만 저장
- Graph: 그래프. 노드와 간선의 집합
- DAG: 유향 그래프에서 싸이클 없는 것

### 연산

다양한 연산이 있다

- 삽입: 새로운 원소 추가. 컨테이너 특성에 따라 삽입 위치를 지정해줘야하거나, 아니거나.
- 삭제: 원소 제거. 보통 find 연산이 필요함. 반복자 지우는 것도 씀
- 순차 접근(iteration): 컨테이너의 원소를 미리 정의된 natural한 순서에 따라 쭉 순회하는 것.
- 임의 접근: 컨테이너의 임의 위치의 원소에 접근하는 것.
- 검색: 컨테이너 안에 특정 조건을 만족하는 원소가 있는지 찾는 것.
- 정렬: 특정 조건에 맞춰서 원소들 정렬

### 반복자

반복자는 컨테이너의 각 원소에 접근하는 방법을 추상화한 것. 컨테이너의 구조를 몰라도 일관된 패턴으로 컨테이너의 각 요소에 접근할 수 있게 만들어준다.

### 복잡도

설명이 필요한가? big-O 표기법

### 커스텀 컨테이너 만들기

이런 컨테이너 클래스를 직접 만들면 몇 가지 장점이 있다

- Total Control: 내 입맛대로
- 최적화: 내가 사용하고자 하는 상황에 맞춰서 좀 더 고성능으로 튜닝할 수 있다
- Customizability: 표준이나 서드파티 라이브러리에 없는 알고리즘도 원하는 거 마음대로 추가할 수 있다
- 외부 의존성 제거: 외부의 개발 환경 / 상태에 영향 받지 않음
- 병렬 데이터 구조: 병렬성을 고려한 컨테이너 같은 것

세 가지 선택지가 있다

1. 모든 자료구조 다 직접 만들기
2. C++ STL 가져다 쓰기
3. boost 같은 서드파티 쓰기

### Dynamic Arrays and Chunky Allocation

동적 배열은 일반적으로 더블링을 많이 쓴다(n개 꽉차면 새로 n개 할당, 다시 꽉차면 2n개 할당, ...). 근데 결국 이거 다 비용이라서, 개발중엔 동적 배열 쓰고 끝나면 적절한 사이즈의 고정 배열로 fix해주면 성능 향상됨

### Dictionaries and Hash Tables

딕셔너리에서 중요한건 키값 탐색이다. 적절한 BST 구현체를 이용할 경우 O(logN) 시간에 찾을 수 있다. 해시를 쓰면, 충돌을 무시할 경우 O(1)에 탐색이 가능하다.

#### Collisions: Open and Close Hash Tables

두 개 이상의 키가 같은 값으로 해싱될 경우 키값 충돌이 발생할 수 있다. 이런 경우를 해결하는 방법엔 두 가지가 있다.

- Open: 오픈 해시 테이블은 각 인덱스에 같은 해싱 값을 가지는 키-값 쌍을 링크드리스트 형태로 모두 관리한다. 이건 구현하기도 쉽고 할당량에 한계가 없다는 장점이 있는데, 동적 메모리 할당이 필요해서 비용이 비싸다.
- Closed: 적당한 탐색 규칙에 따라 빈공간을 찾아서 끼워넣는다. 고정된 크기의 bucket만을 사용하고, 구현하긴 좀 까다로운데 동적 할당 안 해도 돼서 메모리 할당 비용이 싸다. 콘솔 게임에 적합

#### Hashing

간단하게는 모듈러 쓰면 된다. 문자열인 경우 string hashing function을 이용함. 이 함수의 퀄리티는 해시값이 균등하게 분포될 수록, 충돌 확률이 적을 수록 좋다. 또 계산이 빠르면 좋고, 결정적이어야 한다.

문자열이 일반적으로 키값으로 많이 쓰이기 때문에 잘 알려진 문자열 해싱 알고리즘 중에 뭐가 좋은지 판단해서 쓰자

#### Implementing a Closed Hash Table

이 경우 충돌이 발생했을 때 어느 위치를 찾을 건지 규칙을 정해야 한다. 가장 간단한 것은 순차 탐색. 충돌 발생한 위치를 i라고 하면 (i+1), (i+2) ... 쭉쭉 찾는 것.

이렇게 하면 한 곳에 몰리는 문제가 생길 수 있기 때문에 i부터 시작해서 i+1^2, i-1^2, i+2^2, i-2^2, ... 하는식으로 찾는 방법도 있다

closed hash table 만들 때는 테이블 크기를 소수로 정하는게 좋다. 

#### Robin Hood Hashing

이거 쓰면 거의 꽉 찬 closed hash table에서도 성능이 괜찮게 나온다고 한다 

https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/

읽기는 귀찮으니 패스

## Strings

문자열은 아주 간단하고 기초적인 데이터 타입이지만 실제로 만들려고 해보면 아주 많은 디자인 이슈와 제약 조건들이 있다는 것을 알 게 된다.

### 문자열과 관련한 문제

제일 간단한 건 문자열을 어떻게 관리하고 저장할 것이냐 하는 문제이다.

문자열에서 중요한 문제 중 하나는 국제화(i18n)다. 이걸 지원하려면 각종 글자체를 표현할 수 있는 폰트, 언어 방향(오른쪽->왼쪽, 위->아래 등등...) 등까지도 고려해야 함. 

또 다른 중요한 이슈는 게임 엔진 내부에서 문자열이 각조 링소스 파일 이름이나 오브젝트 id를 관리하는 용도로도 사용된다는 것이다. 그래서 문자열 성능은 게임 엔진의 성능에 영향을 많이 끼칠 수 있다. 문자열 복사 / 비교 등의 개선만으로 성능이 엄청 좋아진 케이스가 더러 있음.

### 문자열 클래스

C++에선 보통 std::string을 쓴다. 근데 이 클래스는 찾기 힘든 성능상의 이슈를 불러올 수있음(의도치 않은 복사로 인한 동적 메모리 할당 등). 그래서 런타임 성능의 특성에 맞게 구현을 해야한다. 모든 문자열 버퍼를 read only로 처리해도 되는가, 혹은 copy on write(실제 쓰기가 발생할 때 복사하는 것) 최적화를 할 수 있는가 등등

아무튼 문자열은 레퍼런스로 넘기고 자주 성능 체크하면서 문자열이 성능 깎아먹고 있지 않는지 봐줘야 함

파일 시스템 관리할 때 path 지정에 특화된 문자열 클래스 구현하는게 도움이 될 수 있다. UNIX 스타일이랑 Window s스타일에서 경로 표시하는 거 방법 다른 거 자동으로 처리해주는 기능 등등

### Unique Identifiers

게임 내의 오브젝트들은 모두 유일하게 판별가능해야 한다. (거의 당연한 말이지만) 이런 판별자 용도로 문자열을 보통 쓴다(GUID같은 걸로 다 표시해버리면 사용자가 이해하기 너무 힘들다). 하지만 이 판별자끼리의 비교를 그냥 쌩 문자열 비교해버리면 성능에 지대한 영향을 끼치게 되니 이 부분을 신경써야 함.

#### Hashed String Ids

가능한 방법 중 하나는 스트링을 해시해서 쓰는 것. 미리 해시해서 숫자로 만들어두면 숫자끼리 비교하는 걸로 빠르게 체크가 가능하다. 적당한 해시 함수를 쓰면 게임에서 쓸만한 가능성이 있는 문자열들에 대해 충돌이 일어나지 않음을 보장할 수도 있다. 충돌 문제는 생길 일도 잘 없고 생겨도 문자열 아주 살짝만 고쳐주면 됨

#### 몇 가지 구현 아이디어

개념적으로는 그냥 해시 값 쓰자인데, 실제로는 언제 그 해시 값을 계산할 건지를 고민해볼 필요가 있다. 대부분의 게임 엔진이 해시값을 런타임에 계산한다. 하지만 너티독은 C++ 11의 user-defined literal을 이용해서 ""_sid 형태의 문자열을 컴파일 타임에 바로 해싱된 정수로 변경해서 썼다. 이렇게 하면 string id를 모든 상황에서 정수 상수처럼 사용 가능하다(심지어 switch case에서 라벨로 쓰는 것도 가능)

string id(해시값)를 생성하는 과정을 보통 interning이라고 부른다. 이 과정은 글로벌 해시 테이블에 문자열을 추가하는 과정을 포함한다. 이렇게 하면 해시값으로부터 원래 문자열을 복구하기가 쉽다는 장점이 있는데, 문제는 느리다는 것.

그래서 각 문자열에 대해 string id를 한 번만 생성해두고 그걸 저장해뒀다가 쓰는게 비용을 많이 줄여줄 수 있다.

```C++
static StringID sid_foo = internString("foo");
static StringID sid_bar = internString("bar");

void f(StringID id)
{
  if (id == sid_foo)
    // handle case of id == "foo"
  else if (id == sid_bar)
    // handle case of id == "bar"
}
```

언리얼 엔진에서는 StringID와 그 ID가 나타내는 원본 문자열의 포인터를 한 클래스에 같이 저장하는 FName을 구현하는 식으로 만들었다. 

#### Using Debug Memory for Strings

shipping 모드에서는 string 자체는 필요 없다(string ID 쓸 때). 그러니 string table 메모리는 디버깅할 때만 유지하고 shipping에서는 제거하자

### Localization

Localization은 프로젝트 시작 초기부터 고려하는 게 좋다. 

#### Unicode

unicode는 모든 문자를 16진수 하나(code point)와 일대일 매핑하는 시스템이다. UTF-8과 UTF-16이 일반적으로 쓰이는 유니코드 인코딩 방식이다. 

이거 읽으라고 합니다: [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)

- UTF-32 : 제일 단순한 방식. 모든 유니코드 code point값을 32비트 정수 하나에 대응한다. 제일 큰 code point도 21비트 밖에 안쓰는데(심지어 자주 쓰이는 문자 대부분은 16비트도 안씀) 32비트 통째 할당이라 메모리 낭비가 심하지만 심플한게 장점. 문자열 길이로부터 문자 개수를 바로 파악 가능하다는 것도 장점.

- UTF-8 : 8비트 단위로 저장하지만 몇몇 문자는 8비트 문자 여러 개를 필요로 하는 방식. multibyte character set(MBCS)로도 알려짐. ANSI와의 호환성이 있다는 것이 장점. multi byte 문자의 경우 MSB(최상단 비트)를 1로 둬서 구분한다(이 값들은 ANSI에는 포함이 안 되니 1바이트 짜리 ANSI문자와 쉽게 구분할 수 있다)

- UTF-16 : UTF-16 문자열의 각 글자는 하나 혹은 두개의 16비트 문자로 이루어진다. wide character set(WCS)로도 알려짐. UTF-16에는 유니코드 코드 포인트를 2^16개 문자로 이루어진 17개의 plane으로 구분해서 생각한다. 첫번째 plane은 basic multilingual plane(BMP)이다. 이 영역은 모드 언언에서 제일 많이 쓰이는 code point들을 모아놓은 것이다. 대부분의 UTF-16 문자열이 이 BMP 영역만 가지고도 표현이 가능하다. 다른 영역이 더 필요한 경우 2개의 이상의 16비트 문자가 필요. UCS-2 인코딩은 UTF-16 인코딩의 서브셋이다(BMP만 쓰는 인코딩). UTF-16은 CPU에 따라 little-endian으로도 big-endian으로도 저장될 수 있어서 보통 byte order mark(BOM)을 텍스트 데이터에 같이 포함해서 저장한다. UTF-32 같은 것도 마찬가지.


#### char VS wchar_t

C/C++에서 char은 ANSI와 UTF-8을 포함하는 MBCS 호환 용도이다. wchar_t는 정수하나로 모든 code point를 대응하기 위한 용도이다. 근데 컴파일러, 시스템 따라 크기가 달라 항상 만족하지 않을 수 있음.

특정 플랫폼 / 시스템 지향이면 그냥 거기 맞춰서 쉽게 써도 되고, 그게 아니면 직접 호환 잘 되게 짜는게 좋다


#### Unicode under Windows

윈도우즈에서 wchar_t는 UTF-16 용이다. 윈도우즈 API에서 w, wcs, W 등으로 시작하는 애들은 UTF-16 인코딩임. mb로 시작하거나 끝나는 애들은 MBCS, a 혹은 A로 시작하거나 끝나거나 혹은 어디에도 해당되지 않는다면 ANSI / Windows code pages 인코딩임.

C++ 표준 라이브러리도 비슷한 컨벤션을 따른다. std::string은 ansi, std::wstring은 WCS. 근데 이게 항상 일관성 있는 건 아니라서 혼동을 준다.

윈도우즈 API는 매크로를 이용한 트릭을 제공한다. TCHAR / _T 같은 매크로 써서 환경 설정에 따라 어떤 거 쓸지 골라서 컴파일하게 해줌


#### other Localization Concerns

게임에서 사람이 읽을 수 있는 문자열들은 모두 별도 DB로 관리해줘야 번역이 용이하다. 이 시스템 만드는데 중요한 건 당연히 문자열 ID로부터 각 언어에 해당하는 문자열을 불러오고 저장하는 부분. 간단하게 만들 수도 있고 매우 복잡하게 만들 수도 있는데 구현은 하기 나름. 정확한 구현 사항은 게임 엔진 개발에 별로 중요하지 않다(실무적인 영역에서, 팀 구조에 따른 영향이 오히려 크다)

런타임에는 현재 언어 설정에 맞는 문자열을 문자열 ID로부터 읽어오는 기능이 있으면 됨. 중요한건 raw string을 절대 직접 유저에게 노출하지 말고, 항상 string id를 통해 특정 언어의 문자열을 표시하게 구현하는 것

## Engine Configuration

게임엔진은 매우 복잡하기 때문에 아주 많은 양의 설정 옵션이 필요하다. 이 중에 일부는 게임 메뉴를 통해 유저에게 노출됨.

### Loading and Saving Options

이런 옵션 값들은 보통 전역 변수나 싱글톤 클래스의 멤버 변수로 구현된다. 이런 설정 값들은 하드 디스크에 저장했다가 다시 불러올 수 있어야 가치가 있다. 이 구현에는 다양한 간단한 방법들이 있음

- Text Configuration files: 제일 간단한 건 그냥 설정용으로 한두개의 텍스트 파일을 두는 것. 포맷은 엔진마다 다르지만 보통 아주 간단함. 윈도우즈의 INI 파일, 혹은 JSON 포맷이나 XML 포맷이라든가 다양하게 있다
- 압축된 바이너리 파일: 옛날 콘솔들은 하드디스크가 없었어서 메모리 카드에 압축된 바이너리 형태로 설정값을 저장했음
- 윈도우즈 레지스트리: 윈도우즈의 레지스트리 키 값을 쓰는 것. 근데 이건 다른 프로그램이 마음대로 접근해서 덮어쓰거나 지우거나 하는게 가능하므로 매우 취약함
- 커맨드라인 옵션: 커맨드라인에서 실행했을 때 옵션 값 주는 걸로 컨트롤 하는 것.
- 환경 변수: 환경 변수값도 설정값으로 쓰는 경우가 있다
- 온라인 유저 프로필: 중앙 서버에서 특정 플레이어 정보를 저장하는 경우

### Per-User Options

대부분의 게임엔진들이 전역 설정 옵션과 유저별 설정 옵션을 구분한다. 유저별 옵션은 각각의 플레이어가 자기 옵션만 볼 수 있게 잘 관리되어야 한다. 윈도우즈에서는 AppData 폴더를 많이 씀. HKEY_CURRENT_USER 레지스트리 키 값을 쓰기도 함
