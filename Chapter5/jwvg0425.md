# Engine Support Systems

## Subsystem Start-up and Shut-down

게임 엔진은 여러 서브시스템으로 구성되는데, 이 서브시스템들의 초기화 순서를 정해줘야 한다.

문제는 C++에서 전역, 스태틱 클래스 인스턴스들의 생성자, 소멸자 실행 순서는 예측이 불가능하다는 것. 이 때문에 그냥 이렇게 구현하면 안 된다.

```C++
class RenderManager
{
public:
  static RenderManager& get()
  {
    static RenderManager sSingleton;
    return sSingleton;
  }

  RenderManager()
  {
    // 이런 식으로 생성자에서 이 서브시스템이 의존성을 갖고 있는 다른 서브시스템을 초기화시켜준다.
    VideoManager::get();
    TextureManager::get();
  }
};
```

내부에서 포인터 써서 동적할당 하는 경우도 있는데, 이건 1. 소멸자 순서 제어가 안 된다 2. get 첫 호출이 언제일지 모르는데 이 때 비용이 큰 동적 할당을 하는 건 문제가 될 수 있다 때문에 안하는게 좋음

## 단순한 접근법

static 이런거 안 쓰고 그냥 단순무식하게 하는게 제일 나을 수도 있음

```C++
class RenderManager
{
public:
  RenderManager()
  {
  }
  
  ~RenderManager()
  {
  }

  void startUp()
  {
  }

  void shutDown()
  {
  }
};

RenderManager gRenderManager;
PhysicsManager gPhysicsManager;
Animationmanager gAnimationManager;

int main()
{
  gRenderManager.startUp();
  gPhysicsManager.startUp();
  gAnimationManager.startUp();

  game.run();

  gaAnimationManager.shutDown();
  gPhysicsManager.shutDown();
  gRenderManager.shutDown();
}

```

이런 식으로 그냥 main함수에서 필요한 서브시스템 호출 순서랑 해제 순서 다 적어놓고 필요할때마다 추가하는게 오히려 관리하기 편하다~

## 메모리 관리

메모리는 다음 두 가지 측면에서 성능에 영향을 끼친다.

1. 동적 메모리 할당: malloc이나 new연산은 기본적으로 매우 느리다. 동적 할당을 피하든 커스텀 메모리 할당자를 만들든 해서 할당 비용을 낮춰야 함
2. 현대적인 CPU들의 성능은 종종 메모리 접근 패턴에 의해 결정된다. 데이터가 작고 연속된 공간에 배치되어 있다면 CPU가 훨씬 빠르게 동작함(캐시 히트)

### 동적 할당 최적화

malloc이나 free는 유저 모드와 커널 모드간의 컨텍스트 스위칭을 필요로 하는데, 이건 엄청나게 비용이 크다. 따라서 힙에 할당하는 건 항상 최소화하고 타이트한 루프 내부에서 할당은 반드시 피해야한다.

하지만 동적 할당을 아예 안할 수는 없고, 그래서 커스텀한 메모리 할당자를 만드는게 좋다.

커스텀 메모리 할당자는 미리 할당된 메모리 블록에서 메모리를 가져오게 구현할 수 있고 이는 컨텍스트 스위칭을 동반하지 않으니 비용이 훨씬 싸다.  또, 커스텀 메모리 할당자는 게임에 특화된 몇몇 패턴에 대해 빠르게 동작하도록 최적화를 할 수 있기 때문에 제너럴하게 동작하게 설계된 메모리 할당자에 비해 훨씬 높은 성능을 기대할 수 있다.

#### Stack-based allocator

많은 게임들이 메모리를 stack같은 느낌으로 할당하고 사용한다.

stack-based allocator는 구현하기도 쉽고 강력하다. 말 그대로 메모리를 큰 덩어리로 할당받은 다음에 메모리 할당 요청이 들어오면 이 덩어리를 이용해서 스택 형태로 할당하고 해제해주면 됨.

중요한 건 스택 기반으로 할당할 경우 메모리 할당 해제를 마음대로 할 수 없고, 할당한 순서의 반대 방향으로만 할 수 있다는 것.

스택에서 양쪽 끝부터 할당하는 방식의 Double-Ended Stack Allocator로 구현할 수도 있다. 이렇게 할 경우 양쪽 방향에서 할당이 가능하므로 좀 더 유연한 할당이 가능함.

#### Pool Allocator

크기가 동일한 메모리 객체들을 할당하고 해제해줄 때는 Pool Allocator가 유용하다. pool allocator는 큰 덩어리를 할당 받은 다음 그걸 동일한 크기의 메모리 사이즈로 분할해서 할당한다.

할당 / 해제는 단순히 사용되지 않고 있는 블록들을 관리하는 링크드 리스트에서 하나를 꺼내서 쓰고, 다시 링크드 리스트에 집어넣고 하는 과정으로 O(1)에 간단하게 수행 가능.

이 때 링크드 리스트 관리를 객체 메모리 크기 >= 포인터 크기인 경우 사용되지않고 있는 블록(이하 free block)에 다음 free block의 위치를 기록해두면 별도의 할당 없이 관리가 가능하다.

만약에 객체 메모리 크기가 포인터 크기보다 작다면, 그 바이트수에 맞춰서 다음 free block의 인덱스를 기록하는 방식으로 하면 객체 메모리 크기가 k바이트일 때 2^k개의 원소까지 추가적인 공간 없이 관리가능하다.

#### Aligned Allocation

변수들은 그 크기에 따라 address align 조건이 필요하다. 따라서 메모리를 할당할 때에도 이 align 조건을 고려해서 할당해주어야한다. 구현하긴 어렵지 않은데, 단순히 원래 요청받은 양보다 좀 더 많은 양을 할당해준 다음 align조건에 맞게 주소를 shift해주면 된다. 널널하게 align - 1 바이트 만큼 값을 추가로 할당해주면 항상 shift해줄 수 있다.

이건 align 사이즈가 `align`일 때 `(addr + align - 1) & ~(align - 1)` 으로 쉽게 계산 가능.

이제 이렇게 align한 주소를 다시 할당 해제해줄 땐 어떻게 하면 될까? 기존 주소 위치를 다시 찾아야하는데 그냥 shifted된 값만 보고 이걸 찾긴 어렵다. 간단한 방법은 shift된 값을 메모리 할당자가 찾을 수 있는 위치에 기록해두는 것이다. align-1 바이트만큼의 추가 공간을 할당하니까 이 추가 공간에 잘 기록해두면 찾을 수 있을 것이다. 1바이트만 있어도 0~255까지의 값을 기록할 수 있으므로 aligned 값 256까지도 1바이트로 커버가 가능하다. 따라서, 주소 p에 대해 p-1 위치에 shifted된 크기가 얼마인지 기록해두면 이 정보를 바탕으로 원래 주소를 복구해서 할당 해제해주면 된다.

문제는, 이미 주소가 align되어있는 상황이면 p-1번 위치를 사용할 수가 없게 된다. 그러니 p-1번 위치를 쓰기 위해서, 항상 추가로 1바이트를 더 할당해주자. align-1 바이트만큼이 아니라 align바이트만큼을 할당해주고, shift값이 0~align-1이 아니라 1~align이 되게 만들어주는 것이다. 그러면 p-1번째 위치를 통해 항상 복구 가능하다. 만약 align값을 256보다 더 크게도 가능하게 하려면 이보다 더 많은 추가 공간을 할당해주면 된다.

#### Single-Frame and Double-Buffered Memory Allocators

게임은 한 프레임에만 할당해서 사용하고 해제하는 패턴이 흔히 사용된다. 이런 임시 데이터 할당에는 Single-frame Allocator가 유용하다. single-frame allocator는 stack allocator랑 똑같이 할당하는데 매 프레임마다 그냥 초기화 시켜주는 방식으로 동작하는 것. 할당받은 메모리를 다음 프레임까지 참조하는 실수만 안 하면 효율적이고 좋다. free 신경 안써도 자동으로 잘 되고 좋음.

Double-buffered는 frame i에 할당된게 frame (i+1)까지 사용되게 해줌. 이것도 간단한데 그냥 stack allocator 두 개 만들어놓고 매 프레임마다 이번 할당에 사용할 순서 핑퐁해가면서 쓰는 것임

### 메모리 파편화

메모리 할당 해제하다 보면 파편화가 생긴다. 파편화는 메모리가 할당될 때 연속된 공간을 부여받아야한다는 것 때문에 사용가능한 메모리 공간은 많이 있음에도 불구하고 그게 연속해있지 않아서 할당할 수 없는 상황에 빠지는 걸 말함.

#### Avoiding Fragmentation with Stack and Pool Allocators

stack, pool 할당자는 당연히 파편화 이슈로부터 자유롭다. stack은 애초에 연속한 형태로만 할당을 하고, pool은 할당하는 크기가 동일한 고정 크기의 블록이기 때문에 파편화가 생길 수 없기 때문.

#### Defragmentation and Relocation

stack, pool 할당자를 쓸 수 없는 상황(할당 크기도, 순서도 제멋대로)에서는 어떻게 해결하면 좋을까? 이렇땐 주기적인 Defragmentation을 이용한다. 간단한 방법은 그냥 띄엄띄엄 존재하는 할당된 블록들 위치를 연속한 위치에 오게 잡아당겨주는(shift) 것. 이렇게 하면 할당 안 된 덩어리들이 뭉쳐서 존재하게 되니까 파편화가 해결된다.

다만, 이렇게 Defragmentatiton을 하고 나면 포인터 위치가 전부 바뀌게 되는데, 기존에 메모리 위치를 가리키고 있는 포인터들을 찾아서 갱신해주는 작업이 쉽지 않다.

몇 가지 선택지가 있다.

1. 기존 메모리 위치 가리키던 포인터 전부 다 찾아서 새 위치로 변경해준다. 근데 특정 주소 가리키는 raw pointer를 다 찾는다는게 힘들다.

2. 스마트 포인터 같은 개념을 사용한다. 즉, 가리키고 있는 위치를 감싼 클래스를 만들어서 이 클래스 내부의 값을 수정해주는 형태. 이건 클래스 생성하거나 할때 전역 링크드 리스트에 이 포인터 등록해두거나 하면 defragmentation 과정에서 값을 수정해주기 쉽다.

3. handle을 사용. handle과 pointer 관계를 나타내는 table을 생성해두고 table을 고친다. 사용하는 쪽에서는 handle을 이용해 접근한다. 이렇게 하면 마찬가지로 사용자는 영향을 받지 않는다.

하지만 서드파티 라이브러리를 사용하는 경우는 할당해준 메모리 위치를 마음대로 바꿀 수 없는 경우가 있다. 이런 경우에 대응해주기 위해 서드파티용으로 위치 변경을 하지 않는 메모리 블록과 위치 변경이 일어날 수 있는 메모리 블록을 구분해서 할당해주는 방법이 있다.


#### Amortizing Defragmentation Costs

한 프레임에 이걸 전부 수행하는 건 너무 느리고 비싼 연산이다. 꼭 이렇게 해줄 필요가 없기 때문에, 매 프레임마다 8블록 혹은 16블록 정도의 메모리만 shift해줘도 충분하다. 이런 식으로 나눠서 해도 어지간해서는 파편화되는 속도가 이걸 다시 모아주는 속도를 넘어가서 문제가 생기는 일이 발생하지 않기 때문.

## 컨테이너

다양한 컨테이너가 있다

- 배열: 연속된 메모리 공간, 고정된 크기, 랜덤 엑세스.
- 동적 배열: 배열이랑 같은데 크기가 바뀔 수 있다
- 링크드 리스트: 연속되지 않은 공간, 순차적 엑세스, 빠른 삽입 삭제
- 스택: LIFO
- 큐: FIFO
- 데크: 앞뒤에서 큐
- Tree: 트리 구조. 싸이클 없는 무향 그래프
- BST: 특정 조건에 맞춰서 왼쪽 자식, 오른쪽 자식 분류. 높이를 O(logn)으로 유지하기 위해 AVL Tree, splay tree, red-black tree 등의 형태로 구현한다
- Binary heap: 보통 우선순위 큐 만들 때 이용. 힙
- Priority queue: 우선순위에 따라 pop 순서가 정렬되는 큐
- Dictionary: key-value 구조
- Set: unique한 key만 저장
- Graph: 그래프. 노드와 간선의 집합
- DAG: 유향 그래프에서 싸이클 없는 것

### 연산

다양한 연산이 있다

- 삽입: 새로운 원소 추가. 컨테이너 특성에 따라 삽입 위치를 지정해줘야하거나, 아니거나.
- 삭제: 원소 제거. 보통 find 연산이 필요함. 반복자 지우는 것도 씀
- 순차 접근(iteration): 컨테이너의 원소를 미리 정의된 natural한 순서에 따라 쭉 순회하는 것.
- 임의 접근: 컨테이너의 임의 위치의 원소에 접근하는 것.
- 검색: 컨테이너 안에 특정 조건을 만족하는 원소가 있는지 찾는 것.
- 정렬: 특정 조건에 맞춰서 원소들 정렬

### 반복자

반복자는 컨테이너의 각 원소에 접근하는 방법을 추상화한 것. 컨테이너의 구조를 몰라도 일관된 패턴으로 컨테이너의 각 요소에 접근할 수 있게 만들어준다.

### 복잡도

설명이 필요한가? big-O 표기법

### 커스텀 컨테이너 만들기

이런 컨테이너 클래스를 직접 만들면 몇 가지 장점이 있다

- Total Control: 내 입맛대로
- 최적화: 내가 사용하고자 하는 상황에 맞춰서 좀 더 고성능으로 튜닝할 수 있다
- Customizability: 표준이나 서드파티 라이브러리에 없는 알고리즘도 원하는 거 마음대로 추가할 수 있다
- 외부 의존성 제거: 외부의 개발 환경 / 상태에 영향 받지 않음
- 병렬 데이터 구조: 병렬성을 고려한 컨테이너 같은 것

세 가지 선택지가 있다

1. 모든 자료구조 다 직접 만들기
2. C++ STL 가져다 쓰기
3. boost 같은 서드파티 쓰기

### Dynamic Arrays and Chunky Allocation

동적 배열은 일반적으로 더블링을 많이 쓴다(n개 꽉차면 새로 n개 할당, 다시 꽉차면 2n개 할당, ...). 근데 결국 이거 다 비용이라서, 개발중엔 동적 배열 쓰고 끝나면 적절한 사이즈의 고정 배열로 fix해주면 성능 향상됨

### Dictionaries and Hash Tables

딕셔너리에서 중요한건 키값 탐색이다. 적절한 BST 구현체를 이용할 경우 O(logN) 시간에 찾을 수 있다. 해시를 쓰면, 충돌을 무시할 경우 O(1)에 탐색이 가능하다.

#### Collisions: Open and Close Hash Tables

두 개 이상의 키가 같은 값으로 해싱될 경우 키값 충돌이 발생할 수 있다. 이런 경우를 해결하는 방법엔 두 가지가 있다.

- Open: 오픈 해시 테이블은 각 인덱스에 같은 해싱 값을 가지는 키-값 쌍을 링크드리스트 형태로 모두 관리한다. 이건 구현하기도 쉽고 할당량에 한계가 없다는 장점이 있는데, 동적 메모리 할당이 필요해서 비용이 비싸다.
- Closed: 적당한 탐색 규칙에 따라 빈공간을 찾아서 끼워넣는다. 고정된 크기의 bucket만을 사용하고, 구현하긴 좀 까다로운데 동적 할당 안 해도 돼서 메모리 할당 비용이 싸다. 콘솔 게임에 적합

#### Hashing

간단하게는 모듈러 쓰면 된다. 문자열인 경우 string hashing function을 이용함. 이 함수의 퀄리티는 해시값이 균등하게 분포될 수록, 충돌 확률이 적을 수록 좋다. 또 계산이 빠르면 좋고, 결정적이어야 한다.

문자열이 일반적으로 키값으로 많이 쓰이기 때문에 잘 알려진 문자열 해싱 알고리즘 중에 뭐가 좋은지 판단해서 쓰자

#### Implementing a Closed Hash Table

이 경우 충돌이 발생했을 때 어느 위치를 찾을 건지 규칙을 정해야 한다. 가장 간단한 것은 순차 탐색. 충돌 발생한 위치를 i라고 하면 (i+1), (i+2) ... 쭉쭉 찾는 것.

이렇게 하면 한 곳에 몰리는 문제가 생길 수 있기 때문에 i부터 시작해서 i+1^2, i-1^2, i+2^2, i-2^2, ... 하는식으로 찾는 방법도 있다

closed hash table 만들 때는 테이블 크기를 소수로 정하는게 좋다. 

#### Robin Hood Hashing

이거 쓰면 거의 꽉 찬 closed hash table에서도 성능이 괜찮게 나온다고 한다 

https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/

읽기는 귀찮으니 패스