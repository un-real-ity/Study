# 엔진 지원 시스템
- 엔진을 시작하고 끝내는 일
- 엔진과 게임을 설정하는 일
- 게임의 메모리 사용을 관리하는 일
- 파일 시스템 접근을 처리하는 일
- 온갖 종류의 게임 자원(메시, 텍스쳐, 애니메이션, 오디오 등)을 처리하게 지원하는 일
- 디버깅 툴을 제공하는 일


## C++ 정적 초기화 순서
- 는 main이 실행되기 전에 전역 객체와 정적 객체를 생성.
- 하지만 그 순서는 완전히 임의적.
- 그래서 의존성이 있는 여러 객체들간의 순서를 보장할 수 없어서 트릭을 이용.
- 함수 안에서 선언된 정적 변수는 해당 함수가 처음 호출될 때 생성됨.
```cpp
class RenderManager {
public: 
	static RenderManager& get() {
		static RenderManager sSingleton;
		return sSingleton;
	}
	RenderManager() {
		// 의존성이 있는 다른 매니저들의 get을 호출해 먼저 시작하게 함
		VideoManager::get();
		TextureManager::get();
		// RenderManager 시작
		...
	}
	~RenderManager() {
		...
	}
}
```
- 그러나... 이렇게 쓰면 어떤 부분에서 처음 초기화되는지, 그리고 병목이 생길지 예측이 불가능해서 좀 더 직접적인 접근이 필요.

```cpp
class RenderManager {
public: 
	RenderManager() { /* 아무것도 안함 */	}
	~RenderManager() { /* 아무것도 안함 */ }
	void startUp() {
		// 매니저 시작
	}
	void shutDown() {
		// 매니저 종료
	}
}

RenderManager gRenderManager;
PhysicsManager gPhysicsManager;
int main() {
	// 의존성을 고려해서 필요한 순서대로 매니저 시작
	gPhysicsManager.startUp();
	gRenderManager.startUp();
	...
	
	// 역순으료 종료
	gRenderManager.shutDown();
	gPhysicsManager.shutDown();
	
	...
}
```

- Ogre엔진은 Root라는 싱글톤 객체 하나가 있고, Root가 각종 매니저들을 포인터로 가지고 있으며 한 번에 관리함.

## 메모리 관리
1. 동적 메모리 할당은 굉장히 느림. 동적할당을 피하거나, 할당 비용을 줄일 수 있는 메모리 할당자(allocator)를 직접 만들어야 함.
2. 성능은 메모리 접근 패턴에 좌우되는 경우가 많다. 같은 데이터라도 작고 연속적인 메모리 블록이 유리함.
---
### 동적 메모리 할당 최적화
- malloc, free, new, delete 등 동적 할당은 엄청나게 느림.
- 힙 할당자는 범용적이라 1바이트부터 기가를 넘는 단위까지 처리할 수 있어야해서 관리하는데 부가적인 비용이 들기 때문에 느림.
- 그리고 malloc, free 등을 호출할 때,  커널과 유저모드간의 컨텍스트 스위칭이 일어나서 느림.
> 힙 할당은 최소화하고 타이트루프 안에서는 절대 힙 할당을 하지 말 것
- 커스텀한 할당자는 왜 더 빠르냐면..
	1. 미리 할당된 메모리 블록(처음에 동적할당하거나 전역변수로 선언)을 이용할 수 있다. (커널과의 컨텍스트 스위칭 X)
	2. 예측 가능한 사용 패턴 덕분에 훨씬 효율적으로 동작 가능
	3. http://www.swedishcoding.com/2008/08/31/are-we-out-of-memory 가 도움이된다네.

#### 스택 기반 할당자
- 새로운 레벨을 불러올 때마다, 메모리를 할당.
- 레벨 로딩이 끝나면 동적 메모리 할당은 거의 없거나 아주 적은 수만 발생.
- 레벨이 끝나면 메모리를 해제.
- 구현하기 쉽다. 크고 연속적인 메모리 블록을 할당하기만 하면 됨.
- **임의의 순서로 메모리를 해제할 수 없음**

#### 끝이 두 개인 스택 할당자
- 하나는 위에서부터 할당, 하나는 아래서부터 할당.
- 하이드로 썬더라는 게임에서 사용.
- 아래 스택은 레벨을 불러오고 내리는 데 사용됐고, 위 스택은 매 프레임마다 할당했다 해제하는 임시 메모리 블록으로 사용. (굉장히 성공적이었다고 함)

#### 풀 할당자
- 작은 메모리 블록을 같은 크기로 여러 개 할당하는 경우가 자주 있는데, 이런 패턴엔 풀 할당자가 최선의 선택인 경우가 많음.
- 포인터부분 뭔소리여 ?????????????????????

#### 정렬된 할당자
- 모든 변수와 데이터 객체는 메모리 정렬 조건을 갖는다.
- 실제 요청된 것보다 조금 큰 메모리를 할당하고 블록의 주소를 살짝 조정해서 정렬 맞춘 다음, 조정된 주소를 리턴해주면 됨.
- 보통 추가로 할당할 바이트 수는 정렬 조건의 크기와 같다. (16바이트의 정렬된 메모리 할당을 위해 16바이트를 추가로 할당함. 그러면 15바이트를 조정해야하는 최악의 경우에도 문제 없음)
- 조정값을 알아내려면, 처음 메모리 주소에서 가장 낮은 비트들을 마스킹하고 정렬조건에서 빼면 조정 값이 됨.
	1. 할당된 블록의 원래 주소: 0x50341233
	2. 16바이트 정렬 조건일 경우의 마스크: (16-1) = 15 = 0x0000000F
	3. 0x50341233 & 0x0000000F = 0x00000003 = 3바이트만큼 조정해야함
	4. (정렬 조건 - 벗어난 값) = (16 - 3) = 13 = 0xD를 주소에 더함.
	5. 최종 정렬된 주소: 0x50341233 + 0xD = 0x50341240
- 어떤 경우이건 최소한 한 바이트는 조정됨 (???????????????? 왜????)
- 그래서 정렬된 주소의 바로 앞 바이트에 얼마나 조정되었는지 값 저장해놓고 나중에 해제할 때 활용하자

#### 단일 프레임과 이중 버퍼 메모리 할당자
---
### 메모리 단편화
- 힙 할당, 해제를 반복하다보면 전체 여유 공간은 충분하지만 연속된 빈 공간이 없어서 할당에 실패할 경우가 반드시 생김.

#### 스택 할당자와 풀 할당자로 단편화 예방
- 스택 할당자는 언제나 연속적으로 할당되고, 해제는 반대 순서로 이뤄져서 단편화가 없음.
- 풀 할당자는 단편화될 순 있지만, 블록의 크기가 모두 똑같기 때문에 할당 실패하는 일은 안생김.

#### 조각 모음과 재배치
- 아이디어와 구현 자체는 쉬움. 블록 사이에 공간이 있으면, 공간을 없애고 뒤에 오는 블록들을 붙여주면 됨.
- 문제는... 해당 블록이 이미 사용중이었을 경우, 댕글링 포인터가 되기 때문에 문제가 됨.
- 그래서 해당 블록을 가리키는 포인터를 모두 찾아 새로 이동한 주소를 가리키게 해야하는데, 이 과정을 포인터 재배치(Pointer Relocation)라고 함.
- 근데 해당 블록을 가리키는 포인터를 찾기란 쉽지 않은데... 그래서 바닐라 포인터 말고 스마트 포인터, 핸들 등을 사용해야 함.
- 스마트 포인터는 포인터를 래핑한 클래스이기 때문에 재배치 관련 코드를 삽입할 수 있기 때문.
- **재배치할 수 없는 메모리 블록이 일부 존재할 수 있음(서드파티 라이브러리나 스마트 포인터 등을 사용하지 않는 경우..)**
- 이런 케이스일 경우, 재배치 가능한 영역이 아닌, 아예 별도의 영역을 할당하고 여기서 메모리 할당하게 하도록 하는 것.

##### 조각 모음으로 인한 성능 저하 분산하기
- 조각 모음은 메모리를 복사해야 하기 때문에 굉장히 느릴 수 있음.
- 한 번에 전부 할 필욘 없고, 한 프레임에 최대 8개나 16개의 적은 수의 블록만 이동하게 하면 된다.

## 컨테이너
- 다양한 형태의 자료구조를 의미
	- 배열(array): 순서가 있는 연속적인 요소들에 인덱스로 접근. 길이는 보통 컴파일할 때 정적으로 결정
	- 동적 배열(dynamic array): 런타임에 길이가 변할 수 있는 배열(std::vector)
	- 연결 리스트(linked list): 순서가 있는 요소들의 모음이지만, 연속된 공간에 저장된 것은 아님 (std::list)
	- 스택(stack): LIFO
	- 큐(queue): FIFO
	- 덱(deque): double-ended queue. 배열의 양 끝에서 삽입하고 제거 가능 (std::deque)
	- 우선순위 큐(priority queue): 넣을 땐 순서가 상관없지만, 뺄 때는 우선순위에 따른 순서대로 빠짐. (std::priority_queue)
	- 트리(tree): 요소들이 계층 구조로 구분된 컨테이너. 각 노드는 부모가 1개이거나 없고 0개 이상의 자식을 가짐. 특수한 DAG라고 볼 수 있다.
	- 이진 검색 트리(BST): 각 노드는 최대 두 개의 자식을 가지고, 자식들이 속성에 따라 명확한 기준에 의해 정렬되는 트리. (red-black tree, splay tree, SVL tree, ...)
	- 이진 힙(binary heap): 이진 검색 트리 + 두 가지 기준. (트리 중간에 빈 공간이 없고, 리프 노드는 왼쪽에서 오른쪽으로 채워져야 함. 그리고 힙 속성)
	- 사전(dictionary): 키-값 쌍으로 이뤄진 테이블. 키가 주어지면 해당 값을 빠르게 검색 가능. (std::map, std::hash_map)
	- 셋(set): 정해진 기준에 의해 중복 요소가 없게 보장.
	- 그래프(graph): 노드들의 집합으로, 단방향 혹은 양방향으로 노드들이 연결돼 임의의 패턴을 이룸.
	- 방향성 비순환 그래프(DAG, Directed acyclic graph): 단방향으로 연결된 노드 집합. 사이클이 없다.

### 컨테이너 동작
1. 삽입(insert): 컨테이너에 새 요소 추가.
2. 제거(remove): 컨테이너에서 요소 하나 제거.
3. 순차적 접근(sequential access): 컨테이너의 각 요소들에 미리 정해진 고유한 순서에 따라 접근
4. 임의 접근(random access): 컨테이너의 요소들에 임의로 접근
5. 검색(Find): 컨테이너에서 특정 조건을 만족하는 요소 검색
6. 정렬(sort): 주어진 기준에 따라 컨테이너의 내용물 정렬
