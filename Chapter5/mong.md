## 5.4 문자열

### 5.4.1 문자열의 문제점

> 생각해 볼 문제
* C와 C++에서 STL에서 제공 되는 string을 사용하지 않기로 했다면 직접 구현 해야 한다.
* 현지화/국제화
  * 각 언어 별 폰트/글자 정렬 지원
* 게임 엔진 내부적으로도 문자열을 사용
  * 리소스 파일 이름
  * 객체 id
* 근본적으로 런타임에 문자열 처리하는 것은 느리다.

### 5.4.2 문자열 클래스

> 장점
* 문자열 클래스를 사용하면 문자열 처리하기 편하다.

> 단점
* 잘 드러나지 않는 비용이 종종 있다.
  * 문자열 객체를 부주의하게 사용할 경우 C 스타일 글자 배열(char*)를 사용할 때보다 오버헤드가 생길 수 있다.
  * 문자열 복사 과정에 동적 메모리 할당이 생길 수 있다.
  
> 고려할 사항
* 런타임 성능이 좋은가?
* 문자열 버퍼를 읽기 전용으로 취급하는가?
* copy on write 최적화를 지원하는가?

> 문자열 클래스 사용 예
* Path 클래스
  * 시스템 경로 저장
  * 경로 내용으로 확장자 등 정보를 가져올 수 있다.
  * 운영체제에 따른 처리
  
### 5.4.3 고유 식별자

> 생각해 볼 문제
* 가상 게임 월드에 있는 물체들은 어떤 식으로든 고유하게 구분할 방법이 있어야 한다.
* 게임을 구성하는 자원(메시, 머터리얼, 텍스처, 오디오 클립, 애니메이션)들도 고유하게 구분할 수 있어야 한다.

> 고유 식별자
* 문자열 사용하는 것이 자연스럽다.
* 공유 식별자들끼리 비교하는 속도가 매우 중요하다.

#### 5.4.3.1 해시 문자열 ID

> 장점
* 해시 함수를 사용하면 문자열을 거의 고유한 정수로 바꿀 수 있다.
* 정수와 똑같이 비교할 수 있기 때문에 비교 연산이 빠르다.

> 단점
* 다른 해시 시스템처럼 문자열 해시도 충돌이 발생할 수 있다.
  * 하지만 해시 함수를 잘 고르면 충돌이 발생하지 않게 만드는 것도 가능하다.
  
#### 5.4.3.2 몇 가지 구현 아이디어

* 중요한 것은 해시 값을 언제 계산할지 결정하는 것이다.
* 문자열 id를 사용하는 대부분의 게임 엔진들은 런타임에 해시 값을 계산하지 않는다.
* 문자열 id를 사용하는 경우 원래 문자열을 보관하는 이유는 디버그 과정에서 사람이 읽을 가능성을 대비해서이다.

> interning
* 문자열에서 문자열 id를 만드는 과정
* 문자열의 해시 값을 구하는 동시에 전역 문자열 테이블에 문자열 추가하는 경우가 일반적이다.
* 시간이 오래 걸린다.

### 5.4.4 현지화

#### 5.4.4.1 유니코드

> ANSI 문자열
* 단순히 알파벳만 사용 살 경우는 문제 없다
* 하지만 이보다 더 많은 문자를 가진 언어에 대응하기는 어렵다

> 유니코드
* ANSI의 한계를 극복하고자 나왔다
* 한 가지 표준을 지칭하는 말이 아니다
* 연관된 표준의 모음으로 이 중 나에게 맞는 표준을 찾아야 한다
* 일반적으로 uft-8 utf-16을 사용한다

> utf-8
* MBCS 
  * 한 문자가 1바이트 혹은 그 이상의 공간을 차지한다
  * 따라서 문자열이 차지하는 바이트 수와 문자열의 문자 수는 일치하지 않는다
* 장점
  * ANSI 인코딩과 호환 된다
    * 멀티바이트의 첫 바이트 가장 높은 비트가 1이기 때문(128~255)
    * 표준 ANSI 문자 코드는 128 보다 작기 때문에 ANSI 문자열도 올바른 utf-8이 된다
  
