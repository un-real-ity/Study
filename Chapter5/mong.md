## 5.4 문자열

### 5.4.1 문자열의 문제점

> 생각해 볼 문제
* C와 C++에서 STL에서 제공 되는 string을 사용하지 않기로 했다면 직접 구현 해야 한다.
* 현지화/국제화
  * 각 언어 별 폰트/글자 정렬 지원
* 게임 엔진 내부적으로도 문자열을 사용
  * 리소스 파일 이름
  * 객체 id
* 근본적으로 런타임에 문자열 처리하는 것은 느리다.

### 5.4.2 문자열 클래스

> 장점
* 문자열 클래스를 사용하면 문자열 처리하기 편하다.

> 단점
* 잘 드러나지 않는 비용이 종종 있다.
  * 문자열 객체를 부주의하게 사용할 경우 C 스타일 글자 배열(char*)를 사용할 때보다 오버헤드가 생길 수 있다.
  * 문자열 복사 과정에 동적 메모리 할당이 생길 수 있다.
  
> 고려할 사항
* 런타임 성능이 좋은가?
* 문자열 버퍼를 읽기 전용으로 취급하는가?
* copy on write 최적화를 지원하는가?

> 문자열 클래스 사용 예
* Path 클래스
  * 시스템 경로 저장
  * 경로 내용으로 확장자 등 정보를 가져올 수 있다.
  * 운영체제에 따른 처리
  
### 5.4.3 고유 식별자

> 생각해 볼 문제
* 가상 게임 월드에 있는 물체들은 어떤 식으로든 고유하게 구분할 방법이 있어야 한다.
* 게임을 구성하는 자원(메시, 머터리얼, 텍스처, 오디오 클립, 애니메이션)들도 고유하게 구분할 수 있어야 한다.

#

> 고유 식별자
* 문자열 사용하는 것이 자연스럽다.
* 공유 식별자들끼리 비교하는 속도가 매우 중요하다.

#### 5.4.3.1 해시 문자열 ID

> 장점
* 해시 함수를 사용하면 문자열을 거의 고유한 정수로 바꿀 수 있다.
* 정수와 똑같이 비교할 수 있기 때문에 비교 연산이 빠르다.

> 단점
* 다른 해시 시스템처럼 문자열 해시도 충돌이 발생할 수 있다.
  * 하지만 해시 함수를 잘 고르면 충돌이 발생하지 않게 만드는 것도 가능하다.
  
#### 5.4.3.2 몇 가지 구현 아이디어

* 중요한 것은 해시 값을 언제 계산할지 결정하는 것이다.
* 문자열 id를 사용하는 대부분의 게임 엔진들은 런타임에 해시 값을 계산하지 않는다.
* 문자열 id를 사용하는 경우 원래 문자열을 보관하는 이유는 디버그 과정에서 사람이 읽을 가능성을 대비해서이다.

> interning
* 문자열에서 문자열 id를 만드는 과정
* 문자열의 해시 값을 구하는 동시에 전역 문자열 테이블에 문자열 추가하는 경우가 일반적이다.
* 시간이 오래 걸린다.

### 5.4.4 현지화

#### 5.4.4.1 유니코드

> ANSI 문자열
* 단순히 알파벳만 사용 살 경우는 문제 없다
* 하지만 이보다 더 많은 문자를 가진 언어에 대응하기는 어렵다

> 유니코드
* ANSI의 한계를 극복하고자 나왔다
* 한 가지 표준을 지칭하는 말이 아니다
* 연관된 표준의 모음으로 이 중 나에게 맞는 표준을 찾아야 한다
* 일반적으로 uft-8 utf-16을 사용한다

> utf-8
* MBCS 
  * 한 문자가 1바이트 혹은 그 이상의 공간을 차지한다
  * 따라서 문자열이 차지하는 바이트 수와 문자열의 문자 수는 일치하지 않는다
* 장점
  * ANSI 인코딩과 호환 된다
    * 멀티바이트의 첫 바이트 가장 높은 비트가 1이기 때문(128~255)
    * 표준 ANSI 문자 코드는 128 보다 작기 때문에 ANSI 문자열도 올바른 utf-8이 된다
> utf-16
* utf-8 보다 간단하지만 더 비싼 방법을 사용한다
* 각 문자는 정확히 16비트를 사용한다
  * 따라서 차지하는 바이트를 2로 나누면 정확히 문자 수가 나온다

> 윈도우 환경에서 유니코드
* wchar_t
  * utf-16 문자열을 다루는 타입
  * 관련 함수 및 변수는 w wcs W 접두사 접미사가 붙는다
* char 
  * ANSI와 utf-8 문자열을 다루는 타입
  * 관련 함수 및 변수는 딱히 붙는 접두사 접미사가 없다
* TCHAR
  * 캐릭터 셋에 무관하게 코드를 작성할 수 있도록 하는 타입
  * typedef를 통해 ANSI를 모드 일 때는 char로 utf-16 모드 일 때는 whar_t로 컴파일 된다
  * 관련 함수와 변수는 t tcs T 접두사 접미사 붙는다
  
# 6장 리소스 시스템과 파일 시스템

게임 엔진은 다양한 미디어를 불러오고 관리할 수 있어야 한다.
사용할 수 있는 메모리가 한정 되기 때문에 관리가 필요하다.
따라서 거의 모든 게임 엔진은 리소스 매니저가 존재한다.
리소스 매니저는 파일 시스템에 많이 밀접하다.
하지만 운영체제에서 파일 시스템 API를 그대로 사용하지 않고 wrap해서 사용한다.
* 엔진이 여러 플랫폼을 지원하면 플랫폼마다 API가 다르고
* 운영체제의 파일 시스템 API가 게임 엔진에 필요한 기능을 지원하지 못하는 경우가 있기 때문이다.

## 6.1 파일 시스템

> 게임 엔진 파일 시스템 API 필요 기능
* 파일 이름과 경로를 다루는 기능
* 파일들을 열고 닫고 읽고 쓰는 기능
* 디렉토리를 검색하는 기능
* 비동기 파일 I/O 요청하는 기능 (스트리밍)

### 6.1.1 파일 이름과 경로

> 경로(path)
* 파일 시스템 안에서 디렉토리 위치를 나타내는 문자열
* 근복적인 구조는 같지만 표현 방식은 운영체제마다 다를 수 있다.

#### 6.1.1.1 운영체제에 따른 차이

> 구분자
* 유닉스와 맥OS X: /
* DOS와 구버전 윈도우: \
* 최근 윈도우: 상관 없음
* 맥OS 8,9: :

> 볼륨 지정자
* 유닉스와 유닉스 계열
  * 볼륨마다 개별적인 디렉토리 구조를 가질 수 없다.
  * 모든 파일 시스템은 하나의 통합된 구조
  * 로컬 디스크 드라이브나 네트워크 드라이브 등은 mount해서 메인 디렉토리 구조의 하부 트리로 보이도록 한다.
  * 따라서 유닉스 경로에는 볼륨 지정자 X
* 윈도우
  * 로컬 디스크: :을 붙여 나타낸다. (C:)
  * 네트워크 공유 경로: 로컬 디스크처럼 표현하거나 \\
