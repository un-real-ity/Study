## 5.4 문자열

### 5.4.1 문자열의 문제점

> 생각해 볼 문제
* C와 C++에서 STL에서 제공 되는 string을 사용하지 않기로 했다면 직접 구현 해야 한다.
* 현지화/국제화
  * 각 언어 별 폰트/글자 정렬 지원
* 게임 엔진 내부적으로도 문자열을 사용
  * 리소스 파일 이름
  * 객체 id
* 근본적으로 런타임에 문자열 처리하는 것은 느리다.

### 5.4.2 문자열 클래스

> 장점
* 문자열 클래스를 사용하면 문자열 처리하기 편하다.

> 단점
* 잘 드러나지 않는 비용이 종종 있다.
  * 문자열 객체를 부주의하게 사용할 경우 C 스타일 글자 배열(char*)를 사용할 때보다 오버헤드가 생길 수 있다.
  * 문자열 복사 과정에 동적 메모리 할당이 생길 수 있다.
  
> 고려할 사항
* 런타임 성능이 좋은가?
* 문자열 버퍼를 읽기 전용으로 취급하는가?
* copy on write 최적화를 지원하는가?

> 문자열 클래스 사용 예
* Path 클래스
  * 시스템 경로 저장
  * 경로 내용으로 확장자 등 정보를 가져올 수 있다.
  * 운영체제에 따른 처리
  
### 5.4.3 고유 식별자

> 생각해 볼 문제
* 가상 게임 월드에 있는 물체들은 어떤 식으로든 고유하게 구분할 방법이 있어야 한다.
* 게임을 구성하는 자원(메시, 머터리얼, 텍스처, 오디오 클립, 애니메이션)들도 고유하게 구분할 수 있어야 한다.

#

> 고유 식별자
* 문자열 사용하는 것이 자연스럽다.
* 공유 식별자들끼리 비교하는 속도가 매우 중요하다.

#### 5.4.3.1 해시 문자열 ID

> 장점
* 해시 함수를 사용하면 문자열을 거의 고유한 정수로 바꿀 수 있다.
* 정수와 똑같이 비교할 수 있기 때문에 비교 연산이 빠르다.

> 단점
* 다른 해시 시스템처럼 문자열 해시도 충돌이 발생할 수 있다.
  * 하지만 해시 함수를 잘 고르면 충돌이 발생하지 않게 만드는 것도 가능하다.
  
#### 5.4.3.2 몇 가지 구현 아이디어

* 중요한 것은 해시 값을 언제 계산할지 결정하는 것이다.
* 문자열 id를 사용하는 대부분의 게임 엔진들은 런타임에 해시 값을 계산하지 않는다.
* 문자열 id를 사용하는 경우 원래 문자열을 보관하는 이유는 디버그 과정에서 사람이 읽을 가능성을 대비해서이다.

> interning
* 문자열에서 문자열 id를 만드는 과정
* 문자열의 해시 값을 구하는 동시에 전역 문자열 테이블에 문자열 추가하는 경우가 일반적이다.
* 시간이 오래 걸린다.

### 5.4.4 현지화

#### 5.4.4.1 유니코드

> ANSI 문자열
* 단순히 알파벳만 사용 살 경우는 문제 없다
* 하지만 이보다 더 많은 문자를 가진 언어에 대응하기는 어렵다

> 유니코드
* ANSI의 한계를 극복하고자 나왔다
* 한 가지 표준을 지칭하는 말이 아니다
* 연관된 표준의 모음으로 이 중 나에게 맞는 표준을 찾아야 한다
* 일반적으로 uft-8 utf-16을 사용한다

> utf-8
* MBCS 
  * 한 문자가 1바이트 혹은 그 이상의 공간을 차지한다
  * 따라서 문자열이 차지하는 바이트 수와 문자열의 문자 수는 일치하지 않는다
* 장점
  * ANSI 인코딩과 호환 된다
    * 멀티바이트의 첫 바이트 가장 높은 비트가 1이기 때문(128~255)
    * 표준 ANSI 문자 코드는 128 보다 작기 때문에 ANSI 문자열도 올바른 utf-8이 된다
> utf-16
* utf-8 보다 간단하지만 더 비싼 방법을 사용한다
* 각 문자는 정확히 16비트를 사용한다
  * 따라서 차지하는 바이트를 2로 나누면 정확히 문자 수가 나온다

> 윈도우 환경에서 유니코드
* wchar_t
  * utf-16 문자열을 다루는 타입
  * 관련 함수 및 변수는 w wcs W 접두사 접미사가 붙는다
* char 
  * ANSI와 utf-8 문자열을 다루는 타입
  * 관련 함수 및 변수는 딱히 붙는 접두사 접미사가 없다
* TCHAR
  * 캐릭터 셋에 무관하게 코드를 작성할 수 있도록 하는 타입
  * typedef를 통해 ANSI를 모드 일 때는 char로 utf-16 모드 일 때는 whar_t로 컴파일 된다
  * 관련 함수와 변수는 t tcs T 접두사 접미사 붙는다
  
# 6장 리소스 시스템과 파일 시스템

게임 엔진은 다양한 미디어를 불러오고 관리할 수 있어야 한다.
사용할 수 있는 메모리가 한정 되기 때문에 관리가 필요하다.
따라서 거의 모든 게임 엔진은 리소스 매니저가 존재한다.
리소스 매니저는 파일 시스템에 많이 밀접하다.
하지만 운영체제에서 파일 시스템 API를 그대로 사용하지 않고 wrap해서 사용한다.
* 엔진이 여러 플랫폼을 지원하면 플랫폼마다 API가 다르고
* 운영체제의 파일 시스템 API가 게임 엔진에 필요한 기능을 지원하지 못하는 경우가 있기 때문이다.

## 6.1 파일 시스템

> 게임 엔진 파일 시스템 API 필요 기능
* 파일 이름과 경로를 다루는 기능
* 파일들을 열고 닫고 읽고 쓰는 기능
* 디렉토리를 검색하는 기능
* 비동기 파일 I/O 요청하는 기능 (스트리밍)

### 6.1.1 파일 이름과 경로

> 경로(path)
* 파일 시스템 안에서 디렉토리 위치를 나타내는 문자열
* 근복적인 구조는 같지만 표현 방식은 운영체제마다 다를 수 있다.

#### 6.1.1.1 운영체제에 따른 차이

> 구분자
* 유닉스와 맥OS X: /
* DOS와 구버전 윈도우: \
* 최근 윈도우: 상관 없음
* 맥OS 8,9: :

> 볼륨 지정자
* 유닉스와 유닉스 계열
  * 볼륨마다 개별적인 디렉토리 구조를 가질 수 없다.
  * 모든 파일 시스템은 하나의 통합된 구조
  * 로컬 디스크 드라이브나 네트워크 드라이브 등은 mount해서 메인 디렉토리 구조의 하부 트리로 보이도록 한다.
  * 따라서 유닉스 경로에는 볼륨 지정자 X
* 윈도우
  * 로컬 디스크: :을 붙여 나타낸다. (C:)
  * 네트워크 공유 경로: 로컬 디스크처럼 표현하거나 \\
  
> 확장자
* 파일 이름과 확장자 사이에는 .를 찍어서 구분한다.

> 파일 이름
* 파일 이름과 디렉토리 이름에 금지된 문자: 콜론(:) 빈칸( )

> 현재 작업 디렉토리
* CWD, Current Working directory (=PWD, Presen working directory)
* CWD를 지정하는 명령어는 cd(change directory) 이다.
* 유닉스
  * 오직 하나의 CWD만 존재한다.
* 윈도우
  * 각 볼륨마다 CWD가 있다.
  * 다중 볼륨을 지원하기 때문에 현재 작업 볼륨이라는 개념도 있다.
  * 현재 볼륨을 지정하는 명령어는 [드라이브명]:이다.
* 콘솔
  * 미리 정의된 경로를 사용해 다중 볼륨을 나타낸다.

#### 6.1.1.2 절대 경로와 상대 경로

모든 경로는 파일 시스템의 어떤 위치로부터 상대적으로 나타낸 것이다.
* 절대경로: 루트 디렉토리에 상대적으로 표현 된 경로
* 상대경로: 파일 시스템 계층에서 다른 디렉토리에 상대적으로 표현 된 경로

#### 6.1.1.3 검색 경로

* 경로: 파일 시스템 계층 안에 있는 파일이나 디렉토리 하나의 위치를 나타내는 문자열
* 검색 경로: 경로들의 리스트를 담고 있는 문자열. 세미콜론 등의 특수한 문자로 구분 되고 어떤 파일을 찾을 때 검색할 위치를 나타내는 용도로 쓰인다.
* 런타임에 자원을 검색하는 일은 시간이 걸리는 일이다.
* 일반적으로 자원의 경로를 미리 알지 못하는 상황은 거의 없다.

#### 6.1.1.4 경로 API

* 경로를 처리하는 일이 단순한 문자열 처리하는 것보다 훨씬 복잡하다.
  * 디렉토리와 파일 이름, 확장자 분리
  * 경로 중복되면 명확하게 만들기
  * 절대 경로와 상대 경로 전환하기
* 이런 일들을 도와줄 수 있는 API가 있으면 큰 도움이 된다.
* 윈도우는 이런 종류의 API를 제공한다.
* 하지만 여러 플렛폼을 지원하는 게임 엔진을 만들 경우 특정 플렛폼에 특화된 API는 사용할 수 없다.
* 이러한 이유는 API를 만들거나 각 플렛폼의 API를 감싸는 계층을 만들어 사용한다.

### 6.1.2 기본 파일 I/O

* 표준 C 라이브러리에는 파일 열기/읽기/쓰기 API에 두 종류가 있다. 
* 버퍼를 사용하는 방식과 사용하지 않는 방식 두 가지로 나누어 제공한다.
* 모든 파일 I/O API는 버퍼라는 데이테 블록이 필요하다.
* '버퍼'는 프로그램과 디스크 파일 사이를 오가는 데이터의 출발점 혹은 도착점을 말한다.
* 파일 I/O API가 버퍼를 사용한다는 말은 API가 알아서 입력 출력 데이터 버퍼를 관리한다는 뜻이다.
* 버퍼를 사용하지 않는다는 말은 데이터 버퍼 할당 관리는 프로그래머 몫이라는 말이다.
* 파일 I/O API는 stream I/O API 라고 불리기도 하는데 이 API들은 디스크의 파일을 바이트 스트림처럼 보이게 추상화 역할도 하기 때문이다.
* 유닉스에서 버퍼를 사용하지 않는 C 라이브러리 I/O 함수는 운영체제의 고유 함수다.
* 윈도우에서는 표준 C 라이브러리 함수 대신 고유의 로우 파일 시스템 함수를 제공한다.

#### 6.1.2.1 운영체제의 함수를 감싸는 경우와 그렇지 않은 경우

* 게임 엔진을 만들 때 표준 C 라이브러리의 파일 I/O 함수를 사용할 수도 있고 아니면 운영체제의 고유 API를 사용할 수도 있다,
* 대부분 파일 I/O API를 감싸는 형태로 I/O 함수 라이브러리를 구현한다.

> I/O API 감싸면 좋은 점
* 서로 다른 플랫폼에 유연하게 대처
* 엔진에서 실제 필요한 기능들만 갖게 단순화
* 확장 기능을 지원 할수 있다.

#### 6.1.2.2 동기적 파일 I/O

* 표준 C 라이브러리의 파일 I/O 함수는 모두 동기적으로 동작한다.
* 동기적: I/O를 요청한 프로그램은 데이터가 완전히 이동될 때까지 기다려야 한다.

### 6.1.3 비동기적 파일 I/O

* streaming: 메인 프로그램이 정상적으로 돌아가는 동안 뒤에서 데이터를 불러오는 것을 의미한다.
* streaming을 지원하려면 비동기 파일 I/O 라이브러리를 황용해야 한다.
* 비동기 파일 I/O 라이브러리를 원래 지원하는 운영체제도 있다. ex) 윈도우, Playstation
* 하지만 이식성을 위해서는 시스템 API를 감싸게 만드는 편이 좋다.
* 비동기 I/O 라이브러리는 요청한 후 I/O 동작이 완료되기를 기다리는 기능도 지원한다.
* 비동기 I/O 라이브러리 중에는 비동기 연산이 얼마나 걸리지 예상 시간을 알 수 있는 기능을 제공하기도 한다.

#### 6.1.3.1 우선순위

* 파일 I/O는 실시간 시스템이며 다른 것들과 마찬가지로 정해진 시간 안에 마쳐야 한다.
* 그렇기 때문에 비동기 I/O 에는 우선순위가 있어야 한다.
* 따라서 우선순위가 높은 요청이 제한 시간 안에 완료 될 수 있도록 우선순위가 낮은 요청은 잠시 정지시킬 수 있어야 한다.

#### 6.1.3.2 비동기 파일 I/O의 동작 방법

* 비동기 파일 I/O는 I/O 요청을 별도의 스레드에서 처리하는 방식으로 동작한다.
* I/O 스레드는 큐에서 요청을 뽑아 동기적 I/O 함수를 사용해 순차적으로 처리한다.
* 작업이 완료 되면 메인 스레드가 지정한 콜백 함수를 호출해 요청이 완료 됐음을 알린다.
* 이렇게 별도의 스레드를 사용하면 모든 동기 연산을 비동기 연산으로 바꿀 수 있다.

## 6.2 리소스 매니저

게임은 다양한 리소스로 만들어진다.
게임에서 사용하는 많은 리소스들은 관리가 필요하다.
형태는 다양하지만 게임 엔진에는 리소스 매니저가 존재한다.

> 리소스 매니저
* 자원을 만들고 게임에서 사용할 수 있게끔 변환하는 오프라인 툴 체인 관리
* 런타임에 리소스 관리 - 게임에서 사용 되기 전에 미리 메모리에 불러오고 필요 없을 때 메모리에서 내리는 일 담당
* 중앙 집중적 하부 시스템으로 만들 수도 있고 여러 하부 시스템으로 분리 되어 만들어질 수도 있다.

### 6.2.1 오프라인 리소스 관리와 툴 체인

#### 6.2.1.1 자원의 리비전 컨트롤

> 데이터 크기로 인한 문제
* 아트 자원을 리비전 컨트롤로 관리하면 가장 큰 문제는 엄청난 데이터 양이다.
* 대부분의 소수 컨트롤 시스템이 중앙 저장소에서 사용자 로컬 머신으로 파일 카피하는 방식이기 때문에 자원 파일의 크기는 중요한 문제이다.

# 7 게임 루프와 리얼타임 시뮬레이션

게임은 실시간이고 동적이며 상호적인 컴퓨터 시뮬레이션이다.
따라서 게임에서 시간이라는 개념은 중요한 역할이고 게임에서 시간이 어떻게 활용되는지 반드시 잘 이해하고 있어야 한다.
* 리얼타임
* 게임 시간
* 애니메니션의 로컬 타임라인
* 함수를 실행하는데 걸린 시간

## 7.1 렌더링 루프

정지 화면을 스크린에 빠르게 연속적으로 보여주기 위해서는 루프를 써야 한다.
이런 루프를 렌더 루프라고 부른다.

## 7.2 게임 루프

게임은 상호작용하는 다양한 하부 시스템으로 이뤄진다.
대부분 엔진 하부 시스템은 게임이 돌아가는 동안 주기적으로 업데이트 해야 한다.
얼마나 자주 업데이트 해줘야 하는지는 하부 시스템 마다 다르다.

> 엔진 하부 시스템 예
* 장치 I/O
* 렌더링
* 애니메이션
* 충돌 감지 및 처리
* 강체 역학 시뮬레이션
* 멀티플레이어 네트워크
* 오디오

가장 단순한 방법으로 엔진 하부 시스템을 업데이트 한다고 생각하면 모든 하부 시스템이 한 루프에서 주기적으로 실행 될 것이다.
이 때 이 루프가 게임 루프이다.

## 7.3 게임 루프 구조의 형태

### 7.3.1 윈도우 메시지 펌프

윈도우 플렛폼에서 돌아가는 게임들은 엔진 하부 시스템들 뿐 아니라 운영체제에서 오는 메세지들도 처리해야 한다.
따라서 윈도우 게임에는 메시지 펌프라는 코드가 존재한다.
기본적으로 윈도우 메시지는 오는 대로 처리하고 더 이상 처리할 윈도우 메시지가 없을 때 게임 엔진을 처리하는 방식을 사용한다.
이와 같이 게임 루프를 구현하면 게임 렌더링과 시뮬레이션보다 윈도우 메시지들이 우선 처리된다.
