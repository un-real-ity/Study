# Resources and the File Systems

게임엔 아주 다양한 종류의 에셋이 쓰인다. 보통 메모리가 많이 부족하기 때문에 게임 엔진은 각 미디어 파일이 메모리 상에 항상 딱 한 카피만 올라가 있음을 보장해야 할 필요가 있다.

보통 이런 관리를 위해 리소스 매니저(resource manager)를 구현해서 쓴다.

리소스 매니저는 (당연히) 파일 시스템을 아주 많이 사용하기 때문에, 파일 시스템 관련 API를 잘 래핑해야 할 필요가 있다

## File System

게임엔진의 File system API는 보통 아래와 같은 것들을 다룬다.

- 파일 이름, 경로 조작
- 각각의 파일을 읽고 쓰고 열고 닫는 것
- 디렉토리의 컨텐츠 스캐닝
- 비동기 I/O 요청 처리(스트리밍)

### File Names and Paths

운영 체제, 시스템마다 경로를 표현하는 포맷이 다르다. 하지만 핵심적인 구조는 유사하다. volume/directory1/.../directoryN/file-name 같은 구조를 가짐.

#### 운영체제별 차이점

- UNIX는 /를 구분자로 쓴다. 윈도우즈는 백슬래시(\\)를 구분자로 씀. 요즘 버전은 둘다 됨
- 맥 OS 8, 9는 콜론(:)을 구분자로 쓴다. 근데 BSD UNIX 기반 운영체제라서 /도 지원함
- 몇몇 파일 시스템은 대소문자 구분을 안하고(windows) 어떤 애들은 함(linux).
- UNIX 계열은 볼륨 별로 별도의 파일 체계를 가지지 않는다. 모두가 한 파일 체계 내의 sub directory 구조로 되어있을 뿐
- 윈도우즈는 볼륨을 따로 구분한다. 콜론으로 끝나는 한 글자짜리 알파벳(C:, D: 등)은 볼륨 지시자. 원격 네트워크 디렉토리는 백슬래시 두개(\\\\)로 시작하는 공유 폴더, 리소스 이름
- DOS... 는 알 필요가 있는지? 
- 윈도우즈에서 마지막 . 이후 문자는 확장자로 인식
- 몇몇 글자는 디렉토리, 혹은 파일 이름에 사용 불가 윈도우즈에선 볼륨 지시자말곤 콜론 사용 불가능.
- UNIX, windows 모두 현재 작업 디렉토리(CWD - current working directory 혹은 PWD - present working directory)라는 개념이 있음. 윈도우즈는 볼륨마다 CWD가 따로다. 현재 작업중인 볼륨 정보도 관리.
- 콘솔의 경우 여러 볼륨을 나타내는 미리 정의된 경로 접두사를 종종 사용함.

#### 절대 / 상대 경로

파일 시스템에서 모든 경로는 특정 경로에 대해 상대적인 위치를 나타낸다. 이 기준 위치가 파일 시스템의 루트를 기준으로 하면 절대 경로, 그렇지 않으면 상대경로라고 부름.

윈도우즈, 유닉스 모두 경로 구분자로 시작하면 절대 경로, 아니면 상대 경로임.

윈도우즈의 경우는 볼륨을 지정하는게 추가적으로 있다

#### 탐색 경로

경로는 특정 파일, 폴더의 위치를 가리키는 말이고, 탐색 경로는 콜론이나 세미콜론 등으로 구분된, 파일을 찾기 위한 경로를 말한다(환경 변수의 path 등을 생각해 보자). 몇몇 게임 엔진들은 리소스 파일들을 찾기 위해 탐색 경로를 사용한다.

#### 경로 API

경로는 일반적인 문자열 보다 많이 복잡하다. 그래서 경로 관련한 기능들을 구현하면 도움이 많이 된다. 윈도우즈는 기본적으로 path 관련 API들을 많이 제공하는데(shlwapi.dll, shlwapi.h), 당연히 윈도우즈에서만 사용가능하다는게 문제. 크로스플랫폼 고려해서 구현할 때는 엔진 요구사항에 맞춰서 필요한 것만 잘 래핑해서 쓰자(혹은 직접 구현하자)

#### 기본 파일 IO

C언어의 로우 레벨 기본 IO 함수 일일히 적을 필요는 없을 것 같으니 패스. 필요하면 직접 문서 찾아서 봅시다

Buffered / Unbufferd API의 구분이 있다. 버퍼드 API는 API가 알아서 버퍼를 관리하는거고, 언버퍼드 API는 API가 사용할 버퍼를 내가 직접 제공해줘야 하는 것.

IO API를 래핑하면 최소 세 가지의 장점이 있다.

1. 엔진 프로그래머가 모든 타겟 플랫폼에 대해 동일한 동작을 보장하게 할 수 있다.
2. API가 엔진에 필요한 기능들만 갖게 되므로 심플해진다.
3. 확장된 기능을 제공해줄 수 있다. 커스텀 래퍼니까 필요하다면 네트워크상의 파일을 가져오는 API 같은 것들을 일관된 인터페이스를 유지하면서 쉽게 추가해줄 수 있게 됨

#### 동기 File IO

C 라이브러리의 파일 IO는 동기 함수이다. 즉, IO 끝날 때까지 프로그램이 블락된다.

### 비동기 File IO

스트리밍은 메인 프로그램이 계속 동작하는 와중에 백그라운드에서 데이터를 읽어들이는 행동을 말한다. 많은 게임이 심리스, 로딩 화면 없는 게임 경험을 제공하기 위해 스트리밍을 지원한다.

스트리밍 지원하려면 비동기 IO가 필수적이다. 비동기 IO 지원하는 API 써도 되고, 직접 작성해도 되고 그건 뭐 방법 나름. 멀티스레드 쓰면 어쨌든 항상 비동기 구현은 가능하다. 

몇몇 비동기 IO 라이브러리는 비동기 연산 끝날때까지 얼마나 기다릴건지를 지정할 수 있음(그 기간 끝나도 완료 안 되면 일단 진행할 수 있게)

#### 우선순위

비동기 IO 간에 우선순위가 필요할 수 있다. 우선순위에 맞춰서 우선순위 높은 비동기 연산부터 처리해주는 기능(우선순위 낮은거 잠깐 멈추고) 같은게 있으면 도움이 될 수 있음

## 리소스 매니저

리소스 매니저는 두 종류의 서로 다르지만 연관되어있는 컴포넌트로 구성된다.

1. 에셋을 만들고 엔진에 적합한 형태로 변형하는 오프라인 툴 체인
2. 런타임에 리소스를 관리하고 게임에 필요한 걸 메모리에 올리고 필요없어진건 내리는 작업을 하는 컴포넌트

### 오프라인 리소스 관리 & 툴 체인

#### 에셋 리비전 컨트롤

에셋들은 크기가 아주 커서 리비전 컨트롤이 어렵다. 너티독은 UNIX의 심볼릭 링크를 이용했음. master 파일의 symbolic link를 일반적으로 사용하다가, 실제로 편집을 할때 해당 파일만 복사해서 가져오는 식(copy on write 같은 느낌??). 아주 잘 동작했는데 시스템 밑단부터 직접 만들어야 됨.. 윈도우즈의 경우 junction이라고 심볼릭 링크랑 비슷한 기능 있는데 이걸로도 만들 수 있지 않을까 한다고

#### 리소스 데이터베이스

리소스 DB는 다음과 같은 기본 기능들을 제공해야 한다

- 여러 종류의 리소스들을 되도록 일관된 형태로 다룰 수 있는 기능
- 새로운 리소스 만들기
- 리소스 지우기
- 리소스를 확인하고 수정하기
- 리소스를 디스크상의 한 장소에서 다른 장소로 옮기기
- 리소스들 끼리의 교차 참조. 이 기능은 리소스 빌딩 및 런타임 로딩 모두에 쓰임
- DB내의 참조 무결성 유지(지우거나 리소스 이동시 참조 관계 처리)
- 리비전 히스토리 유지. 누가 왜 고쳤는지 로그랑 같이
- 여러가지 방식의 검색, 쿼리 기능이 있으면 더 좋다

#### 예시

*언리얼 엔진4*

UnrealEd로 거의 모든 리소스를 관리. 가장 큰 장점은 UnrealEd가 엔진의 일부분이라는 것. 그래서 에셋들을 만들자마자 바로 정확히 인게임에서 어떻게 보일지 확인 가능.

또다른 장점은 one-stop shopping이 가능하다는 것. 언리얼 Ed의 generic browser는 개발자가 엔진에서 사용되는 모든 에셋에 접근 가능하게 해줌. 모든 종류의 리소스에 대해 일관된 인터페이스를 가지는 것도 장점. 검색도 쉽다

언리얼은 명시적으로 리소스를 import 해서 쓰기 때문에 다른 엔진보다 에러에 좀 더 강하다. 

반대급부로, 모든 리소스가 적은 개수의 큰 파일에 나뉘어 들어가는 식으로 되어있는 구조에서 오는 단점도 있다. 이 파일들은 이진파일이라 리비전 컨트롤이 쉽지않다.

#### Asset Conditioning Pipeline

여러 도구로 생성한 게임 에셋들은 보통 엔진에서 그대로 가져다 쓸 수 없어서 변환 작업이 필요하다. 이런 역할을 Asset Conditioning Pipleline(이하 ACP)가 해 줌. 보통 아래 세 가지 단계를 거친다.

1. Exporters : 우리가 조작할 수 있는 형태로 에셋 형식을 수정하는 단계
2. Resource Compilers : 엔진에서 쓸 수 있게 하기 위해 변형을 가하는 단계. 텍스쳐 비트맵을 압축하거나 하는 등
3. Resource Linkers : 가끔 여러 리소스를 합쳐서 하나로 만드는게 유리한 경우가 있다. 이런 것들 한 세트로 묶어주는 과정

리소스끼리 종종 내부적인 의존성을 가지는 경우가 있다. 이런 의존성은 리소스의 로딩 순서에 영향을 줌. 추가로, 특정 에셋이 변경되었을 때 어떤 에셋들을 다시 갱신해줘야 하는지 정보랑도 연관이 있다. 

리소스 변경의 경우 데이터 변경 뿐 아니라 데이터 포맷 변경도 포함되는데, 포맷을 버전 번호 붙여가지고 다 관리하는 방법이 있고 그냥 포맷 바꿀 때 기존 에셋들도 전부다 새 포맷 맞춰서 한 번에 업그레이드해주는 방법이 있음. 후자가 더 나은 거 같다고 함(포맷 바꾸는게 자주 있는 일도 아닌데 번호 붙여서 코드 다 관리하면 쓸데없이 복잡해짐). 상용 엔진 기준으로는 좀 다를 듯

에셋 빌드를 위한 도구를 직접 제작하는 경우도 있고 make 같이 잘 알려진 도구를 쓰는 경우도 있다. 무슨 방법을 쓰든 이 시스템의 안정성에 신경을 많이 써야 함.

### 런타임 리소스 관리

#### 런타임 리소스 매니저의 역할

- 메모리 상에 같은 리소스는 하나만 올라가있게 유지하기
- 리소스의 수명(lifetime) 관리
- 필요한 리소스 로딩, 불필요한 리소스 언로딩
- composite resource 로딩 관리. composite resource는 여러 리소스의 집합으로 이루어진 리소스를 말함(3D model 같은 것- mesh, material, texture 등 여러가지로 구성되어있으니)
- 참조 무결성 유지. 내부 무결성(한 리소스 내에서의 참조 무결성- composite resource에서 얘가 필요한게 다 로딩 잘 되어있는가), 외부 무결성(리소스 끼리의 참조 무결성)
- 로딩된 리소스의 메모리 사용량 관리, 각 리소스가 제대로 된 메모리 위치에 저장되고 있는지 보장
- 로딩된 후에 커스텀한 처리 과정 허용(리소스 타입에 따라).
- 하나의 일관성 있는 인터페이스 제공.
- 스트리밍

#### 리소스 파일, 폴더 조직화
몇몇 엔진들은 리소스를 몇개의 나뉘어진 'loose' 파일들로 관리한다. 이 파일들은 일반적으로 사용자 편의성을 위한 트리 구조의 폴더 안에 만들어진다. 엔진은 일반적으로 리소스 위치를 별로 신경쓰지 않지만 사람들은 폴더 구조가 있어야 리소스를 관리하기가 쉽기 때문

어떤 엔진들은 모든 리소스를 하나의 파일로 관리한다. zip 같은 거. 이건 로딩 시간 이득이 있다.

#### 리소스 파일 포맷

많은 게임 엔진 프로그래머들이 여러 이유로 고유한 파일포맷을 만들려고 한다. 표준 포맷이 엔진에서 필요한 모든 정보를 담고 있지 않은 경우에는 필수적이기도 하다. 런타임 로딩 시간을 줄이기 위해 오프라인 처리 작업을 하고 싶어서 새로운 포맷을 만들기도 함. 

#### 리소스 GUID

게임 내부의 리소스는 GUID(globally unique identifier)가 필요하다(당연히). 일반적으로는 파일 경로인데 이걸 쓸 수 없는 경우도 있음(리소스가 파일별로 분리되지 않은 엔진도 있으므로). 128비트 해시코드 같은 걸 쓸 수도 있다

#### 리소스 레지스트리

항상 같은 리소스는 하나만 메모리에 떠 있다는 것을 보장하기 위해 로딩된 메모리의 레지스트리를 유지할 필요가 있다. 제일 간단한 구현은 딕셔너리(키-값 구조).

리소스가 없을 때 불러오는 과정이 문제인데, 리소스가 없으면 빡로딩하는 구현이 있고 에러를 내는 구현이 있고 백그라운드에서 로딩하는 구현이 있다. 빡로딩은 게임 한참 플레이 중에 일어나면 렉을 유발시킬 수 있으므로 안하는게 좋음.

로딩 화면 띄우고 로딩 다 한 다음에 인게임에서는 로딩 안하는 방법이랑 비동기 로딩해서 로딩화면 안 쓰는 두가지가 방법일텐데 후자가 당연히 좀 더 어려움. 근데 요즘 게임은 거의 대부분 후자를 택하죠?

#### 리소스 수명

리소스의 수명은 리소스가 처음 메모리에 올라온 시점부터 어떤 이유로 다시 내려가는 시점까지의 기간을 말한다. 각각의 리소스들은 수명에 관한 요구조건이 있다.

- 몇몇 리소스들은 반드시 게임이 처음 시작될 때 로딩이 되어야 한다. 그리고 게임 내내 계속 메모리 상에 존재해야 한다.
- 특정 게임 레벨과 같은 수명을 가지는 리소스.
- 인게임 시네마틱 같은 건 게임 레벨보다 더 짧은 수명을 가짐.
- 배경음, 풀스크린 무비 같은 건 재생될 때 바로바로 스트리밍된다. 이런 애들은 라이프타임을 정확히 규정하기가 애매함

에셋을 불러오는 시점을 정의하긴 쉬운데(그 에셋이 필요한 시점이 곧 불러오는 시점이므로), 다시 내리는 시점을 정의하긴 애매하다. 어떤 리소스들은 여러 레벨에 걸쳐서 사용되기도 하기 때문.

한가지 방법은 리소스에 대한 레퍼런스 카운트를 유지하는 것. 0 -> 1 되면 로딩, 1 -> 0 되면 언로딩

#### 리소스 메모리 관리

리소스 관리는 메모리 관리랑 아주 연관이 깊다. 리소스 로딩되면 결국 메모리에 올라가니까. 그래서 게임엔진의 메모리 관리 시스템 디자인은 리소스 매니저랑 아주 강하게 묶여있다. 

*힙 기반 리소스 할당*

메모리 파편화 무시하고 그냥 힙 쓰는 것이 하나의 방법. 그냥 가상 메모리를 지원하는 개인 컴퓨터에서만 돌아간다고 생각하고 만드는 거면 이게 베스트.

그게 아니면 주기적인 조각모음 해줘야 함. 앞장에서 했다

*스택 기반 리소스 할당*

스택 할당자는 다음과 같은 조건이 만족되면 쓸 수 있다.

- 게임이 선형적이고 레벨 집중적이다.(로딩화면 보고, 레벨 불러오고, 로딩화면 보고, 레벨 불러오고, ...)
- 각 레벨이 완전히 메모리에 올라갈 수 있다

dobule ended queue 쓰면 레벨 할당이랑 임시적으로 할당 필요한 애들이랑 구분해서 쓸 수 있으니 좀 유용할 수 있다.

*풀 기반 리소스 할당*

또 다른 방법은 같은 사이즈로 잘라 놓은 chunk를 쓰는 것이다. 물론 같은 사이즈로 자른 chunk만 가지고 리소스 관리가 가능해야 한다는 조건이 필요.

각각의 청크는 보통 특정한 게임 레벨과 연관된다(associated). 가장 간단한 방법은 각 레벨을 청크들의 링크드리스트로 나타내는 것. 이런 식으로 하면 각 청크의 lifetime을 관리하기가 쉽다.

청크 쓰는건 용량 낭비가 좀 있음. 리소스 사이즈가 정확히 청크의 배수가 될 수는 없으니, 마지막 청크 일부는 낭비가 되기 때문.

*리소스 청크 할당자*

청크 메모리 낭비의 영향을 제한하는 방법중 하나는 청크의 사용되지 않는 부분을 활용하는 특별한 메모리 할당자를 만드는 것이다. 

구현하긴 쉬운데, 사용되지 않는 메모리를 포함하는 모든 청크의 링크드 리스트를 유지하기만 하면 된다. 그리고 이 부분에 필요하면 메모리 할당을 하는 것.

문제는 이 청크가 할당 해제되면 어떻게 하는가? 간단한 해결책은 해당 할당의 수명이 기존에 할당된 청크의 수명보다 작을 때만 할당하는 것. 그러면 어차피 수명이 더 짧으니까 고려할 필요가 없음

*Sectioned Resource Files*

일반적인 리소스 파일은 하나에서 네 개정도의 섹션으로 구성될 수 있다. 메인 램으로 가야하는 섹션, 비디오 램으로 가야하는 섹션, 로딩 중에만 필요하고 로딩 끝나면 필요없는 임시적인 섹션, 디버깅용 섹션 등등.

이걸 잘 활용한 예시는 [Granny SDK's file system](http://www.radgametools.com)에서 확인할 수 있다고 함.

#### Composite Resource 와 참조 무결성

리소스 간의 참조 관계는 보통 방향 그래프로 나타낼 수 있음.

내부 참조(한 리소스 내의 여러 오브젝트들 간의 참조)와 외부 참조(서로 다른 리소스들간의 참조)는 좀 다른 방식으로 구현되기 때문에 서로 구분이 필요하다.

#### 리소스간의 교차 참조 처리

리소스 매니저 만들 때 구현 측면에서 제일 힘든 부분 중 하나가 리소스 오브젝트간의 참조 관리 및 참조 무결성 유지다. 

*GUIDs as Cross-Referrences*

각각의 참조 관계를 참조되는 오브젝트의 GUID를 포함하는 문자열 혹은 해시코드로 표현하는 건 좋은 접근법 중 하나. 이를 위해선 런타임 리소스 매니저가 글로벌 리소스 룩업 테이블을 관리해야 한다. 리소스가 메모리에 올라오면, 그 오브젝트에 대한 포인터가 GUID를 키로 해서 글로벌 테이블에 저장되는 방식.

*Pointer Fix-Up Tables*

데이터 오브젝트를 바이너리 파일에 저장할 때 자주 사용되는 다른 접근 방법 중 하나는 포인터를 파일 오프셋으로 변형하는 것이다. 이렇게 저장하고 나면 각각의 데이터들이 연속된 파일 상에 존재하게 되고, 모든 포인터를 파일 상에서의 오프셋으로 변환해서 표현할 수 있다.

이렇게 저장한 파일을 다시 불러와서 사용할 땐 파일 오프셋을 다시 포인터로 바꾸는 과정이 필요한데(메모리상에 로딩했으므로) 이 과정을 pointer fix-up이라고 부른다. 이 과정은 오프셋 위치만 어디어디 있는지 알면 파일 로딩한 포인터 위치에서 해당 오프셋만큼 더해주면 되기 때문에 아주 간단하다. 하지만 어느어느 오프셋을 불러와야하는지 정보를 모르면 당연히 불가능하므로 파일에 저장할 때 이 정보를 파일에 추가해서 저장한다.

*C++ 오브젝트를 바이너리 이미지로 저장하기: 생성자*
바이너리 이미지에서 C++ 오브젝트 불러올 때 간과할 수 있는 중요한 단계가 바로 그 오브젝트의 생성자 호출을 보장하는 것이다. 

이 단계를 해결하는 두가지 일반적인 방법이 있다.

1. 생성자 호출이 필요없는 POD 객체만 바이너리 파일에 저장하는 것(가상 함수가 없고, 아무 동작도 수행하지 않는 생성자를 쓰는 객체)
2. non-POD에 대해 추가적으로 각각이 어떤 클래스인지 정보도 같이 저장하는 것. 그 다음에 로딩할 때 얘네들에 대해선 placement new 이용해서 생성자 호출해주기.

[ipkn/dumpable](https://github.com/ipkn/dumpable) 도 참고해볼 만한 프로젝트

*Handling External References*

내부 참조만 하는 리소스에 대해서는 위 두가지 방법 다 잘 동작한다. 하지만, 외부 참조가 있는 경우 좀 개선된 접근 방법이 필요하다.

외부 참조가 있는 경우 그 오브젝트에 대한 GUID / file offset 뿐만 아니라 해당 파일의 경로도 필요하다.

파일들 로딩 -> 이 파일들이 참조하는 다른 리소스들 파일 경로 보고 로딩 -> 메모리 상에 로딩 끝나면 다시 한 번 순회하면서 룩업 테이블 보고 참조 관계 메모리 기준으로 갱신

#### Post-Load Initialization

이상적으로는 오프라인 툴 작업이 끝나면 모든 리소스가 사용가능한 형태인게 좋다. 하지만, 현실적으로 이게 항상 가능한 것은 아니다. 그래서 로딩하고 난 후 몇가지 후처리가 필요할 수 있다.

- 반드시 후처리가 필요한 경우. 예를 들어, PC에서 3D 메시의 정점 및 인덱스 정보는 메인 램에 로딩 되지만, 렌더링될려면 비디오 램에 전송되어야 한다. 이건 DirectX 버퍼를 만들고 복사하고 읽고 하는 등등의 작업이 어쩔 수 없이 필요함.
- 혹은 후처리 안 해도 되는데 편의상 하는 경우. 예를 들어, 엔진에서 쓰는 곡선 라이브러리에 호의 정확한 길이를 계산하는 기능을 추가하길 원한다고 하자. 이 값 저장할 수 있게 툴을 고치는 것보단 런타임에 계산하는 코드 추가하는게 더 편하다


리소스마다 로딩후 후처리 혹은 언로딩 전에 마지막 처리(tear-down)가 필요할 수도 있고 아닐 수도 있다. 그래서 리소스 매니저는 일반적으로 이걸 리소스마다 정의할 수 있게 만들어 둔다. 