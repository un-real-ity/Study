# 게임 루프와 리얼타임 시뮬레이션
- 게임 엔진이 다뤄야 할 시간?
  - 리얼타임
  - 게임 시간
  - 애니메이션의 로컬 타임라인
  - 함수 실행에 걸린 실제 CPU 주기
  - 등등.....

## 렌더링 루프
OS의 GUI는 대부분 정적이라 작은 부분들만이 모양을 바꿈.
- 그래서 스크린을 전부 다시 그리는게 아니라, 바뀐 일부분만을 다시 그림. (사각형 무효화 - Rectangle invalidation)
- 이건 2D에서도 쓰이는 기법.

하지만.... 3D에선 거의 매 순간 모든 스크린이 변하기 때문에 사용할 수 없음.
- 3D는 영화처럼 정지화면을 빠르게 스왑해서 움직임처럼 보이게 함.
- 그래서 빠르게 루프를 계속 돌려야 하는데, 이를 **렌더링 루프**라고 부름.

## 게임 루프
게임은 상호작용하는 다양한 하부 시스템으로 이뤄짐 (장치 I/O, 렌더링, 애니메이션, 물리 등)
- 대부분의 하부 시스템은 게임이 실행중일 때, 주기적으로 업데이트 해줘야함.
- 애니메이션은 통상 30Hz, 60Hz
- 동적 시뮬레이션은 더 자주(ex. 120Hz)
- AI 등의 하이레벨 시스템 - 초당 1,2번 등등

단순한 방법으로 하부 시스템을 업데이트 한다고 하면, 루프 하나에서 모든 업데이트를 처리하면 된다.
그래서 이 루프를 **게임 루프** 라고 부른다.

```cpp
// 예시 - Pong 게임
void main() {
	initGame();
	while (true) { // 게임 루프
		readHumanInterfaceDevices();
		if (quitButtonPressed()) break;

		movePaddles();
		moveBall();
		colideAndBounceBall();
	
		if (ballImpactedSide(LEFT_PLAYER)) {
			incrementScore(RIGHT_PLAYER);
			resetBall();
		} else if (ballImpactedSide(RIGHT_PLAYER)) {
			incrementScore(LEFT_PLAYER);
			resetBall();
		}

		renderPlayField();
	}
}
```

## 게임 루프 구조의 형태
### 윈도우 메세지 펌프
윈도우 플랫폼 게임은 엔진 하부 시스템의 메세지뿐만 아니라 OS 메세지도 처리해야함.
윈도우 메세지는 오는대로 족족 처리하고, 더 처리할 메세지가 없으면 게임 엔진에 대한 처리를 함.

```cpp
while (true) {
	// 윈도우 메세지 처리하기
	MSG msg;
	while(PeekMessage(&msg, NULL, 0, 0) > 0) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	
	// 처리할 윈도우 메세지가 없을 때 게임 루프 돌리기
	RunOneIterationOfGameLoop();
}
```

이런 방식은 윈도우 메세지가 우선적으로 처리되기 때문에, 창 이동이나 크기 변경을 할 동안에 게임은 멈춰있다.

### 콜백 주도 프레임워크
엔진 프레임워크는 게임 루프는 이미 짜여있지만, 거의 비어있다.
비어있는 부분을 사용자(프로그래머)가 콜백 함수로 넘겨줘서 완성하는 구조.

### 이벤트 기반 업데이트
대부분의 게임 엔진엔 이벤트 시스템이 있어서 하부 시스템들은 특정 이벤트를 구독(subscribe)해서 이벤트가 발생될 때 처리하게 됨.
일부 엔진은 이벤트 시스템을 활용해 주기적으로 하부 시스템을 업데이트하도록 구현하기도 함.
- 이렇게 하려면 현재 시점보다 미래에 이벤트를 보낼 수 있는 기능이 필요

## 가상 타임라인
### 실시간
CPU의 정밀 타임 레지스터 값으로 측정.

### 게임 시간
보통 상황에서 게임 시간 === 실시간임.
게임을 일시정지 -> 게임 시간 멈추기
슬로우 모션 -> 게임 시간 천천히 업데이트

게임 시간을 정지하거나 느리게 할 수 있으면 디버깅할 때 유용하다.

### 로컬 타임라인과 글로벌 타임라인
애니메이션이나 오디오를 느리게 재생하거나 빠르게 재생하려면, 로컬 타임라인을 글로벌 타임라인에 매핑할 때 재생률(시간 척도)를 조절해서 매핑하면 됨.

## 시간을 측정하는 방법과 처리하는 방법
### 프레임 레이트와 속도의 관계
```
다음 위치 = 현재 위치 + 위치 변화 = 현재 위치 + (속도 * dt)
```
이것은 명시적 오일러(Explicit Euler)법이라는 수치 적분의 단순한 형태.
단순하거나 복잡하거나 관계 없이 물체의 속도는 델타 시간(dt)에 의존한다고 해도 틀린 말이 아님.
그래서 dt를 결정하는 것은 아주 중요한 문제

#### 초창기 CPU 종속적 게임
초창기 게임은 실제 시간이 얼마나 흘렀는지에 따름이 아닌, 프레임당 미터로 직접 지정함.
그래서 하드웨어 퍼포먼스에 따라 물체의 속도가 다르게 나타났음.

#### 경과 시간에 따른 업데이트
게임이 CPU 속도에 영향 받지 않으려면 dt가 필요함.
- dt = (프레임 시작할 때의 CPU 정밀 타이머) - (프레임 끝날 때의 CPU 정밀 타이머)

하지만 이 방법은 k 프레임의 dt를 (k+1)프레임의 dt에 대한 예측 값으로 사용한다는 문제가 있다.
예측하지 못한 일이 생겨 다음 프레임이 현재 프레임보다 훨씬 짧거나 길어질 수도 있다.
- 이를 프레임 레이트 스파이크(Spike)라고 부름
- 게임 물리 시뮬레이션은 33.3ms에 한 번씩 업데이트된다고 가정.
  - 우연히 프레임이 떨어져 57ms에 한번 실행되었음.
  - 이 실수를 보완하려고 다음 프레임에 물리 시뮬레이션을 2번 돌리는 실수를 할 수 있다.
  - 이는 다음 프레임의 dt에도 영향을 줄 수 있고, 악순환이 반복.

#### 이동 평균 사용 ???????
- 그리는 데 오래 걸리는 물체들이 많은 쪽으로 카메라가 향하고 있음.
- 다음 프레임에도 같은 방향을 바라보고 있을 가능성이 아주 크다
- 그래서 적은 수의 프레임 시간을 평균내서 다음 프레임의 dt로 예측.
- 프레임 레이트가 변하는 상황에도 대처 가능하며, 스파이크로 인한 부작용도 줄어듬.
- 평균을 내는 구간이 길어질수록 프레임 레이트 변화에 즉각 대응하기도 어려워지지만, 스파이크의 부작용도 줄어듬

#### 프레임 레이트 조절
이전 프레임의 dt로 다음 프레임 dt를 예측하는 것이 문제라면, 거꾸로 생각.
- 다음 프레임의 시간을 예측하는 것 대신, 모든 프레임의 시간을 고정시킨다. (60FPS가 목표라면 프레임당 33.3ms로 고정)
- 프레임이 목표 시간보다 일찍 끝나면, 목표시간까지 메인 스레드를 재움.
- 프레임이 목표 시간보다 늦게 끝나면, 그냥 감수하고 한 프레임 더 기다린다.

이 방법은 실제 게임의 프레임과 목표 시간이 비슷할 때에만 잘 동작한다.
그래서 프레임 시간이 어떻게 되더라도 모든 엔진 시스템이 잘 동작하게 설계하는 것이 좋다.

일부 엔진 시스템(대표적으로 물리)는 일정 간격으로 업데이트했을 때 최적의 성능을 내기 때문에 일정하게 유지하도록 해주는 것이 좋음.

### 정밀 타이머로 실제 시간 측정
- time() (운영체제가 제공하는 C 라이브러리 함수)
  - 1970년 1월 1일 자정부터 현재까지 경과한 시간을 초 단위로 리턴.
  - 최대 정밀도가 1초라 게임에서 쓰기엔 무리.

- CPU 정밀 타이머
  - 현대 CPU는 다 가지고 있음
  - 보통 프로세서가 처음 켜지거나 리셋된 시점부터 경과한 CPU 주기 수를 하드웨어 레지스터에 저장하는 방식으로 구현.
  - 3GHz 프로세서를 예로 들면, 초당 30억번 타이머가 증가 (즉, 정밀도 1/30억 = 0.333ns)
  - 펜티엄 계열 - rdtsc 명령어
  - Win32 API
    - QueryPerformanceCounter() - 카운터 레지스터 읽어오기
    - QueryPerformanceFrequency() - 초당 몇 번 타이머 증가시키는지 리턴

#### 정밀 클록의 불일치
일부 멀티코어 프로세서는 코어마다 정밀타이머가 독립적이라 그 값이 점점 벌어질 가능성이 있다.

### 시간 단위와 클록 변수
1. 어떤 시간 단위를 사용할 것인가? (s, ms, 하드웨어 주기 등)
2. 어떤 데이터 타입을 사용? (64비트 int, 32bit float 등)

#### 64비트 정수 클록
저장 공간만 감당할 수 있다면 제일 정밀하고 좋음.

#### 32비트 정수 클록
높은 정밀도와, 상대적으로 짧은 시간 간격을 측정할 경우 사용 (하드웨어 주기 단위).

#### 32비트 부동소수 클록
상대적으로 짧은 dt를 저장할 때 사용. 한 프레임 내에서만 사용하는 것이 일반적.


### 중단점과 시간
디버깅을 위해 중단점을 걸고, 다시 코드를 실행시키면 엄청나게 커진 dt때문에 하부 시스템이 오작동할 수 이씅ㅁ.
간단하게 미리 정한 한계(ex 0.1초)를 넘으면 중단점이 걸린걸로 간주하고 dt를 1/30초나 1/60초로 강제 설정하는걸로 해결 가능.

## 멀티프로세서 게임 루프
### SIMD (Single Instruction, Multiple Data)
[개요를 잘 설명한 글](https://stonzeteam.github.io/SIMD-%EB%B3%91%EB%A0%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/)

동시에 여러개의 데이터에 동일한 연산을 수행.
- 게임에선 float 4개를 병렬로 계산하는걸 제일 많이 씀


### 분기와 결합
멀티코어를 활용하는 방안으로 분할정복(Divide & Conquer) 알고리즘을 적용할 수 있다.
- 분기/결합(fork/join) 방식이라고 부름.
  1. 어떤 일을 작은 단위로 쪼갠다
  2. 여러 개의 코어에 분배(fork)
  3. 작업이 끝나면 결과를 합침(join)


### 하부 시스템마다 스레드 하나씩 두기
특정 하부 시스템을 별도의 스레드로 돌림.
어느정도 분리된 역할을 반복적으로 맡아서 하는 하부 시스템에 적합함. (렌더링, 물리, 애니메이션, 오디오 등)

### 잡 ???????????????
하부 시스템을 멀티스레드로 분리하는 방식의 문제점은, 각 스레드가 비교적 큰 단위의 작업을 처리한다는 점임.
어느 한 스레드에서 늦게 일을 끝내면, 다른 스레드들의 진행도 멈출 수 있다.
- 그래서 작업을 여러 개의 독립적인 잡으로 나눔.

## 네트워크 멀티플레이어 게임 루프
### 클라이언트-서버 모델
네트워크 레이턴시를 고려해서 클라이언트에서 움직임을 예측해서 미리 잘 보여주도록 하는 것이 관건.
데디케이트 서버 설명이........???????

### P2P
참여하는 모든 클라이언트가 각자 할당받은 특정 객체에 대해서 서버 역할을 함.
클라이언트가 나가면 객체의 관리 주체가 바뀔 수 있기 때문에 구현이 까다롭다.
