# 7 게임 루프와 리얼타임 시뮬레이션

게임은 실시간이고 동적이며 상호적인 컴퓨터 시뮬레이션이다.
따라서 게임에서 시간이라는 개념은 중요한 역할이고 게임에서 시간이 어떻게 활용되는지 반드시 잘 이해하고 있어야 한다.
* 리얼타임
* 게임 시간
* 애니메니션의 로컬 타임라인
* 함수를 실행하는데 걸린 시간

## 7.1 렌더링 루프

정지 화면을 스크린에 빠르게 연속적으로 보여주기 위해서는 루프를 써야 한다.
이런 루프를 렌더 루프라고 부른다.

## 7.2 게임 루프

게임은 상호작용하는 다양한 하부 시스템으로 이뤄진다.
대부분 엔진 하부 시스템은 게임이 돌아가는 동안 주기적으로 업데이트 해야 한다.
얼마나 자주 업데이트 해줘야 하는지는 하부 시스템 마다 다르다.

> 엔진 하부 시스템 예
* 장치 I/O
* 렌더링
* 애니메이션
* 충돌 감지 및 처리
* 강체 역학 시뮬레이션
* 멀티플레이어 네트워크
* 오디오

가장 단순한 방법으로 엔진 하부 시스템을 업데이트 한다고 생각하면 모든 하부 시스템이 한 루프에서 주기적으로 실행 될 것이다.
이 때 이 루프가 게임 루프이다.

## 7.3 게임 루프 구조의 형태

### 7.3.1 윈도우 메시지 펌프

윈도우 플렛폼에서 돌아가는 게임들은 엔진 하부 시스템들 뿐 아니라 운영체제에서 오는 메세지들도 처리해야 한다.
따라서 윈도우 게임에는 메시지 펌프라는 코드가 존재한다.
기본적으로 윈도우 메시지는 오는 대로 처리하고 더 이상 처리할 윈도우 메시지가 없을 때 게임 엔진을 처리하는 방식을 사용한다.
이와 같이 게임 루프를 구현하면 게임 렌더링과 시뮬레이션보다 윈도우 메시지들이 우선 처리된다.

### 7.3.2 콜백 주도 프레임워크

엔진 하부 시스템과 외부 게임 미들웨어 패키지들은 대부분 라이브러리 형태다.
라이브러리를 사용하면 프로그래머는 선택의 폭이 넓어지지만 어떻게 사용할지 프로그래머가 반드시 잘 이해하고 있어야 한다.

프레임워크로 되어 있는 엔진이나 미들웨어 패키지도 있다.
프레임워크를 통해 구현할 경우 전체적인 흐름은 프레임워크에 의해 정해져 있기 때문에 프로그래머가 영향을 거의 줄 수 없거나 손 댈 수 없을 수 있다.
프레임워크 기반 렌더링 엔진이나 게임 엔진은 게임 루프가 이미 짜여져 있다.
하지만 루프 안은 비어 있다.
이 비어 있는 부분을 채워넣기 위해 콜백 함수를 짠다.

### 7.3.3 이벤트 기반 업데이트

게임에서 이벤트랑 게임의 상태나 주변 환경 상태에서 관심을 가질 만한 변화가 생겼음을 나타낸다.
> 이벤트의 예
* 조이패드의 입력
* 폭발이 일어난 경우
* 적 캐릭터가 플레이어 캐릭터를 발견하는 순간

대부분의 게임 엔진에는 이벤트 시스템이 있다.
엔진 하부 시스템들은 이벤트 시스템을 통해 관심 있는 이벤트를 등록했다가 이벤트가 발생하면 처리하면 된다.
일부 엔진들은 이벤트 시스템을 활용해 주기적으로 하부 시스템을 업데이트하게 구현하기도 한다.

## 7.4 가상 타임라인

### 7.4.1 실시간

CPU의 정밀 타임 레지스터 값으로 측정하는 값이 실시간 타임라인 시간이라면 타임라인의 원점은 CPU가 파워가 처음 들어온 순간 리셋된 순간으로 정의하고 단위는 CPU cycle이다. CPU cycle은 초 단위로 쉽게 변환할 수 있다.

### 7.4.2 게임 시간

타임라인은 실시간만 있지 않다.
필요한 만큼 다른 타임 라인을 정의할 수 있다.
실시간 타임라인과 별개인 게임 시간 타임라인을 정의할 수 있다.
보통 상황에는 게임 시간과 실시간은 일치하지만 한 타임라인을 다른 타임라인에 상대적인 형태로 변경하면 게임을 멈추게 하거나 느리게 하거나 빠르게 하거나 가능하다.
더 보완하면 게임 시간을 한 단계씩 진행하게도 구현할 수 있다.
게임이 정지 되어 있어도 게임 루프는 계속 돌아가고 있다.

### 7.4.3 로컬 타임라인과 글로벌 타임라인

애니메이션 클립이나 오디오 클립에 로컬 타임라인 이라는 것을 둘 수 있다.
이 로컬 타임라인을 글로벌 타임라인(실시간 or 게임 시간)에 어떻게 mapping 하는지에 따라 클립의 재생과 속도를 제어할 수 있다.

## 7.5 시간을 측정하는 방법과 처리하는 방법

### 7.5.1 프레임 레이트와 시간 델타

리얼타임 게임에서 fram rate란 정지 3D 프레임을 연속적으로 얼마나 빨리 보여주는지를 나타내는 말이다.
게임과 영상 산업에서 fram rate를 frames per second(= FPS = 초당 프레임 수)로 나타낸다.
이 때 두 프레임 사이에 시간이 얼마나 흘렀는지는 델타, 델타 시간으로 나타낸다.

> 예
* 30FPS로 렌더링하면 델타 시간은 1/30초이다.

### 7.5.2 프레임 레이트와 속도의 관계

어떤 물체가 어떤 속력으로 움직일 때 물체의 현재 위치를 구하려면 다음과 같이 구하면 된다.
X2 = X1 + 델타X = X1 + v델타t
식을 보면 위치를 구하려면 경과된 프레임 시간 델타t가 필요하다.
따라서 게임 내 물체들은 프레임 시간 델타t에 의존적이다.
때문에 델타t를 정하는 것은 중요한 문제이다.

#### 7.5.2.1 초창기 CPU 종속적인 게임

처음 게임이 나왔을 때는 게임 루프 간에 실제 시간이 얼마나 흘렀는지 재보지 않았다.
델타t를 무시하고 프레임당 움직이는 속도를 지정했다.
이렇게 되면 물체들의 속도는 게임이 돌아가는 하드웨어에 의해 frame rate가 어떻게 변화는지에 따라 달라진다.
따라서 이런 게임들은 CPU 종속적인 게임이라 할 수 있다.

#### 7.5.2.2 경과 시간에 따른 업데이트

게임이 CPU 속도에 영향 받지 않으려면 어떻게든 델타t 측정해야 한다.

> 측정 방법
* 프레임이 시작할 때 CPU의 정밀 타이머를 읽고
* 프레임이 끝날 때 다시 CPU 정밀 타이머를 읽는다.
* 두 값의 차를 구하면 델타t를 측정할 수 있다.

이렇게 구한 델타t를 필요한 곳에 사용하면 된다.
여기서 한 가지 중요한 문제점이 있다.

> 프레임 레이트 스파이크
* k프레임 시간을 측정한 델타t를 다음 k+1프레임 시간에 대한 예측 값으로 사용한다는 점이다.
* k프레임 시간으로 k+1프레임을 예측한 값이니 정확하다는 보장이 없다.
* 실제 k+1프레임 시간이 예측한 값보다 길어지거나 짧아질 수도 있다.
* 이 같은 현상을 프레임 레이트 스파이크라고 한다.

#### 7.5.2.3 이동 평균 이용

적은 수의 프레임 시간을 평균 내서 다음 프레임의 델타t 예측 값으로 사용하는 것도 합리적인 방법이다.

> 장점
* 프레임 레이트가 변하는 상황을 대처할 수 있다.
* 순간적인 성능 스파이크로 인한 부작용도 줄어든다.
* 평균을 내는 구간이 길어지면 프레임 레이트 변화에 대응하기 힘들지만 스파이크의 부작용도 적어진다.

#### 7.5.2.4 프레임 레이트 조절

> 프레임 시간 고정
* 이전 프레임의 델타t로 다음 프레임 시간을 예측하는데 오차가 생긴다면
* 다음 프레임의 시간을 추측하는 대신 모든 프레임 시간을 고정 하는 방법도 생각해 볼 수 있다.
* 위 같은 방식은 게임 프레임이 평균적으로 고정 프레임 시간과 비슷한 경우에만 동작한다.
* 프레임 시간이 들쭉날쭉하면 게임 품질은 심각하게 저하 될 수 있다.

> 프레임 레이트 조절
* 현재 프레임 시간을 측정하고 측정된 값이 
  * 고정 된 시간보다 짧은 경우는 고정 프레임 시간이 채워질 때까지 메인 스레드를 잠들게 한다.
  * 고정 된 시간보다 긴 경우는 그냥 감수하고 한 프레임을 더 기다린다.

> 프레임 레이트가 일정하면 좋은 점
* 물리 시뮬레이션에 쓰이는 적분 모듈 같은 경우 일정한 간격으로 업데이트 했을 때 최적의 성능을 낸다.
* 테어링 방지
  * 테어링: 비디오 버퍼를 업데이트 하는 빈도와 모니터 재생 빈도가 다를 경우 생기는 현상
* 녹화 및 재생 기능의 안정성이 높아진다.
  * 프레임 레이트가 일정하지 않으면 정확한 순서대로 진행 되지 않을 수도 있다.

### 7.5.3 정밀 타이머로 실제 시간 측정

> 표준 C 라이브러리 - time()
* 정밀도 1초
* 정밀도가 충분치 않다.

> CPU 정밀 타이머
* 프로세서가 처음 켜지거나 리셋된 시점부터 경과한 CPU 주기 수를 하드웨어 레지스터에 저장한다.
* 정밀도가 CPU 주기 단위기 때문에 게임에 쓰기에 적합하다.
* 마이크로프로세서마다 운영체제마다 정밀 타이머 값을 얻어오는 방법은 다르다.
* CPU의 정밀 타이머 레지스터의 크기는 대부분 64비트라 다시 0으로 돌아가는 시점은 195년 뒤이다.

#### 7.5.3.1 정밀 클록의 불일치

정밀 타이머를 사용해 시간을 측정하더라도 때에 따라서는 정확하지 않을 수도 있다.
멀티코어 프로세서는 코어마다 정밀 타이머가 독립적이라 그 값이 점점 벌어질 수도 있다.

### 7.5.4 시간 단위와 클록 변수

