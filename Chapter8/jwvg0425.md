# Human Interface Devices

게임엔진이 어떻게 입력 기기로부터 데이터를 읽고 처리하는지 알아보자. 출력 기기에 어떻게 데이터 보내는지도 알아 보자

## HID의 종류

조이패드, 키보드, wii 리모트 컨트롤러, 스티어링 휠 등 매우 다양하다

## HID 인터페이스

### 폴링

게임 패드, 조이스틱 등으로부터의 입력은 주기적인 하드웨어 폴링으로 받는다. 즉, 게임 루프에서 매 프레임마다 현재 기기 상태를 읽어 오는 것.

마이크로소프트 XInput API가 좋은 예시인데, 매 프레임마다 게임은 `XInputGetState()` 함수를 호출해서 입력 상태를 폴링해온다. 

### 인터럽트

몇몇 HID는 컨트롤러 상태가 바뀔때만 게임 엔진에 데이터를 전송한다. 마우스같은게 대표적인데, 거의 항상 가만히 멈춰 있는데 계속 입력을 받고 있으면 비효율적이기 때문. 이런 종류의 입력 기기는 하드웨어 인터럽트를 이용해서 컴퓨터와 통신한다. 인터럽트는 하드웨어에서 발생되는 전기 신호인데, 이 신호는 CPU가 일시적으로 메인 프로그램의 실행을 중지하고 인터럽트 소스 런타임(ISR)이라고 불리는 작은 코드 조각을 실행하게 만든다. HID의 경우 ISR은 단순히 기기의 상태를 읽고 이후 처리를 위해 저장한 것 정도의 그친다.

### 무선 기기

듀얼 쇼크3 같은 블루투스 기기는 단순한 방식으로 입력을 받을 수 없다. 대신에, 입력 기기와 블루투스 프로토콜을 이용해서 통신해야한다. 소프트웨어에서 HID에 인풋 데이터를 보내줄 것을 요청하거나, 출력 데이터를 전송해주어야 한다. 이런 통신은 보통 게임 엔진의 메인 루프와 별도로 돌아가는 스레드에서 처리하거나, 최소한 메인 루프에서 호출할 수 있는 간단한 인터페이스로 캡슐화된다. 그래서 게임 프로그래머 입장에서는 다른 기기랑 무선 기기를 딱히 구분할 필요가 없다.

## 입력 종류

입력 기기는 아주 다양한 종류가 있지만 기기로부터 받은 입력의 종류는 한정된 몇 카테고리로 분류할 수 있다.

### 디지털 버튼

거의 모든 입력 기기가 디지털 버튼을 몇 개씩은 달고 있다. 이 버튼들은 누름 / 뗌 딱 두 가지 상태중 하나만 가진다. 소프트웨어에서 버튼의 상태는 보통 1비트로 표현된다. 0은 보통 뗌(up), 1은 누름(down)을 나타냄. 경우에 따라 반대일 수도 있다(구현하기 나름).

기기에 있는 모든 버튼의 상태를 부호 없는 정수형 변수 하나에 전부 다 담는게 일반적이다. 각각의 버튼 상태는 비트 연산으로 가져옴.

### 아날로그 축, 버튼

아날로그 입력은 특정 범위의 값 중 하나를 가질 수 있는 입력이다(보통 0~1사이의 실수). 이런 입력은 보통 조이스틱의 x,y축 혹은 버튼이 얼마나 눌렸는가 등을 표현하는데 쓰인다. 

정확히 말해서 아날로그 입력은 게임 엔진에서 쓰일 땐 아날로그가 아니다. 아날로그 입력은 보통 전자화(digitized)되는데, 이 말은 곧 입력이 양자화되어 정수로 저장된다는 뜻이다. 예를 들어, 아날로그 입력은 16비트 정수 -32768 ~ 32767 사이의 값으로 저장될 수 있다. 어떤 범위, 어떤 크기의 정수로 저장될 지도 제각각일 수 있음

### 상대 축(Relative Axes)

아날로그 버튼, 조이스틱 등등은 0의 위치가 명확하다(입력 값이 절대적이다). 반면에, 상대적인 입력을 받는 기기들도 있다. 이런 기기의 경우 값 0이 나타내는 위치가 명확하지 않다. 대신, 이 값은 이전 입력 값과 현재 입력 값의 차이를 나타내는데 쓰인다. 마우스 등이 대표적인 예시.

### 가속도계(Accelerometers)

몇몇 기기는 가속 센서를 가지고 있다. 컨트롤러 움직이면 움직이는 속도와 방향에 따라 입력을 받을 수 있음.

### 위모트, 듀얼 쇼크 등에서의 3D 방향

몇몇 기기는 플레이어가 들고 있는 조이패드가 3차원 상에서 어느 방향을 향하고 있는지를 입력 받을 수 있다. 

### 카메라

키넥트, IR 센서 등등

## 출력 종류

### 럼블(Rumble)

진동

### Force-Feedback

플레이어 입력에 저항. 스티어링 휠 같은 것

### 오디오

오디오는 보통 독립적인 엔진 시스템으로 동작한다. 몇몇 HID는 오디오 시스템에서 활용할만한 출력을 제공. 듀얼쇼크 같은 거에 달려있는 오디오 장치 등

### 기타 입출력

암튼 머 이상한 거 많음

## 게임 엔진 HID 시스템

게임 엔진에서는 당연히 HID 입력을 직접적으로 가져다 쓰지 않는다. HID 입력을 게임에서 가져다 쓰기 좋은 형태로 잘 가공해서 씀. 추가적으로 게임엔진들은 보통 HID 입력을 추상화해서 게임에서 HID 입력을 간접적으로 참조하게 해주는 레이어를 중간에 둔다(입력과 키 매핑 바꿀 수 있게)

### 일반적인 요구 사항

- 데드 존
- 아날로그 시그널 필터링
- 이벤트 감지
- 버튼 시퀀스 감지, 버튼 조합(chord) 등
- 제스쳐 감지
- 멀티 플레이어용 다중 HID 관리
- 멀티플랫폼 HID 서포트
- 컨트롤러 인풋 리매핑
- 컨텍스트 센서티브한 입력
- 일시적으로 몇몇 입력을 비활성화 할 수 있는 기능

### 데드 존

트리거, 조이스틱 축 같은 아날로그 입력 장치들은 미리 정의된 최소 입력값 I_min과 I_max가 있다. 그리고 이 장치들에 손을 안 댔을 때(기본 상태)에 해당하는 기본 값 I0이 있다. 트리거같은 경우 보통 I0 = I_min = 0이고, 조이스틱 축 처럼 음의 방향 양의 방향이 모두 있는 입력 장치의 경우 I0은 I_min과 I_max의 중간값인 경우가 많음. 이 때 이 장치들은 아날로그 장치이기 때문에 건드리지 않아도 값이 미묘하게 변하는 문제가 있다. 그래서 이 미묘하게 변하는 값에 게임이 민감하게 반응하면 안되니까, 데드존을 줘서 데드존 사이의 입력값은 전부 I0(해당 입력 장치를 건드리지 않음)으로 취급하는 방법을 많이 쓴다. 즉, 데드존 범위가 x면 I0 - x ~ I0 + x 사이의 값은 전부 I0로 취급하는 식.

### 아날로그 시그널 필터링

아날로그 입력에서 신호에 끼는 노이즈는 데드존이 아니라도 문제가 될 수 있다. 이런 노이즈로 인한 부자연스러운 입력을 방지하기 위해 간단한 low-pass filter를 쓰는게 해결책이 될 수 있다.

현재 시간 t에 따른 필터링되지 않은 입력값을 u(t)라고 하고, 필터링된 입력 값을 f(t)라고 하자. 이 때 f(t)값은 아래와 같은 공식으로 정의할 수 있다.

f(t) = (1-a) * f(t - dt) + a * u(t)

dt는 프레임 간의 시간 간격 값이다. 이 때 a값은 보통 어떤 상수 RC에 대해 dt / (RC + dt) 로 정의한다. 간단히 봐서 이번 프레임의 입력을 그대로 가져다 쓰는게 아니라, 이전 프레임의 필터링된 입력을 일정 비율만큼은 유지시켜줘서 값이 자연스럽게 변하게 만들어 주는 것이다.


또 다른 방법으로는 이동 평균을 쓰는 방법이 있다. 만약 3프레임간의 입력값의 평균을 사용하고 싶다면 원형 큐에 항상 제일 최신 입력 값을 3개 저장해두고 그 값의 평균을 사용하면 된다.


### 입력 이벤트 감지

입력 장치들은 보통 현재 입력 장치의 상태를 전송해주는데, 게임의 경우 종종 입력에 대한 이벤트가 필요한 때가 있다. 이런 이벤트는 버튼을 누른 순간 / 뗀 딱 그 순간에만 발생하는데 이건 단순한 입력 값의 현재 상태만 보고는 알 수 없는 정보다. 어떻게 구현할 수 있는지 알아보자

#### 버튼 업 다운

버튼 상태가 0이면 뗀 상태, 1이면 누른 상태라고 하자. 이전 프레임과 현재 프레임의 상태를 추적하면 버튼을 누르고 떼는 이벤트를 쉽게 추적할 수 있다.

이 때 비트 연산자를 쓰면 구현을 좀 쉽게 할 수 있다. 여러 개의 버튼을 하나의 정수에 저장해서 관리하는 경우(각 비트가 버튼의 상태) 이 정수 값에 xor값을 이용하면 쉽게 구할 수 있다.

```
int buttonState;
int prevButtonState;
int buttonUp; // 이번 프레임에 버튼이 눌림
int buttonDown; // 이번 프레임에 버튼을 뗌

int buttonChange = buttonState ^ prevButtonState;

buttonDown = buttonChange & buttonState; // 상태가 변경된 키 중에 현재 버튼 상태가 1인 것
buttonUp = buttonChange & (~buttonState); // 상태가 변경된 키 중에 현재 버튼 상태가 0인 것
```

#### chords

chord는 동시에 버튼 눌러서 특수한 동작을 발생시키는걸 말한다. 여러 버튼을 누르면 특수한 커맨드 발생하는 예시는 아주 많음. 디버깅 용도로 쓸 수도 있다

chord를 감지하는 건 기본적으로 아주 쉽다. 단순히 여러 버튼의 상태를 감지하다가 원하는 그룹의 키들이 전부 동시에 눌리면 chord가 발생한 것임.

하지만 고려해야 하는 사항이 몇 가지 있다. 하나는, 각 키들이 이미 게임에서 다른 용도로 쓰이고 있는 경우 이에 대한 처리가 별도로 필요하다는 것이다. 또, 사람들이 그렇게 완벽하게 한 프레임에 모든 키를 동시에 누르기는 힘들기 때문에 이 부분에 대해서도 고려가 필요하다.

- chord가 항상 각 버튼을 누른 동작에 추가적으로 뭔가를 더 발생시키는 방식으로 만들어서 해결할 수 있다. 이 경우, L1 =총 발사, L2 = 수류탄 발사면 L1+L2 = 총이랑 수류탄 발사 + 에너지포 발사 와 같이 만드는 것. 이 경우 L1, L2를 어느 순서로 누르든 상관이 없고 고려할게 덜하다
- 버튼이 눌린 이벤트와 그게 실제 게임 이벤트로 처리되는 사이에 텀을 두는 방법이 있다. 예를 들어 버튼 입력이 있고 3프레임 정도 후에 해당 버튼에 대한 게임 이벤트를 처리하게 만들면, 그 사이에 일어난 입력들을 취합해서 chord를 처리하는게 가능하다.
- button이 눌릴 때 chord를 감지하되, 실제 chord 이벤트의 발생은 버튼을 뗀 순간에 트리거시키는 방법이 있다
- 단순 버튼 입력에 대한 이벤트를 발생시키되 chord에 대한 이벤트가 이 이벤트를 선점하게 만들 수 있다.

#### 시퀀스, 제스쳐 감지

버튼이 실제 눌린 시점과 그게 실제로 눌린 것으로 처리되기 까지 사이에 텀을 두는 것은 제스쳐 감지의 특수한 케이스로 볼 수 있다. 제스쳐는 일정 시간에 걸친 플레이어 입력 시퀀스다. 격겜 커맨드같은 거 생각하면 이해하기 편함. 보통 최대 프레임 제한 안에 해당 입력이 모두 순서대로 수행되면 하나의 제스쳐로 인식한다.

보통 입력 히스토리 버퍼를 유지하면서, 제스쳐에 해당하는 입력이 일정 시간 범위 내에 들어오면 그걸 히스토리 버퍼에 쭉 쌓다가 제스쳐에 해당하는 입력이 전부 들어오면 해당 이벤트를 발생시키는 방식으로 구현한다. 그 중간에 이상한 입력이 들어오거나 시간 내에 입력이 들어오지 못하면 버퍼를 날리는 식

*Rapid Button Tapping*

게임에서 한 버튼 갈기는 입력이 필요할 때가 많다. 이런 버튼 입력 주기가 일정 이상이어야 valid한 제스쳐로 인정하는 방식. 이 주기는 이전에 해당 버튼이 눌린 시점을 저장해두면 간단하게 구할 수 있다. 흐른 시간의 역수가 곧 주기이므로, f = 1 / (T_now - T_last) 를 구해서 이 f가 정한 최소 threshold이상인지 확인하면 되기 때문. 혹은 그냥 T_now - T_last < dt_max 인지 확인하는 식으로 바로 해도 된다. 후자가 더 계산량이 적으니 더 좋겠죠??

*Multibutton Sequence*

입력 받아야 하는 키 시퀀스를 만들고, 순서대로 눌렀는지 판별하면 된다. 이 시퀀스에서 지금 어디까지 눌렀는지 순서 상태값 및 제일 첫 키를 누른 시점값을 유지하면 어렵지 않게 구현할 수 있음. 시간 범위 안에 순서대로 키를 잘 눌렀으면 상태를 변경하며 따라가면 되고, 시간 안에 못 눌렀거나 시퀀스에 포함되지 않는 키를 눌렀으면 0번째 상태로 돌아가면 된다.

조이스틱 입력에 의한 제스쳐는 좀 더 복잡할 수 있는데, 이런 건 특정한 상태 경계점을 일종의 버튼 입력처럼 취급하면 구현하기 편하다(4분면으로 나눠서 각 분면에 해당하는 상태를 모두 방문하면 조이스틱을 한 바퀴 돌린 것으로 취급하는 식)

### 멀티 플레이어를 위한 다중 HID 관리

한 PC에 여러 개의 컨트롤러가 붙을 수 있고 각각의 컨트롤러를 서로 다른 플레이어가 사용할 수 있다. 그래서 각 플레이어와 그 플레이어의 입력을 담당하는 HID를 매핑해줄 필요가 있다. 

싱글 플레이라도 입력 장치 연결이 끊어졌다 다시 붙거나 하는 상황들이 있을 수 있기 때문에 신경써줘야 한다. 연결 끊기면 화면에 메시지 띄우고 게임 잠깐 중단하거나 하는 등등의 처리를 해주거나. 입력 장치에 배터리가 있는 경우 배터리 얼마나 남았는지 화면에 표시하거나 혹은 조금 남았을 때 알림을 띄워주거나 하는게 필요할 수도 있다.

### 크로스 플랫폼 HID 시스템

크로스 플랫폼으로 HID를 지원하려면 하드웨어 입력 계층을 추상화한 중간 레이어를 두는게 좋다.

### 인풋 리매핑

입력값을 받는 것과 그 입력 값을 게임 이벤트로 처리하는 것 사이에 중간 레이어를 하나 두면 된다. 물론 아무렇게나 리매핑을 하면 안 되기 때문에 입력 장치를 몇 가지로 카테고리화 해서 호환되는 장치들끼리만 리매핑이 되게 해줘야 한다.

- 디지털 버튼 : 누르고 떼는 두 가지 상태만 있는 거
- 방향이 하나 뿐인 축
- 양방향 축
- 상대 축

### Context-Sensitive Controls

하나의 물리적인 입력이 상황에 따라 다른 동작을 할 수 있다. 공격 키가 NPC 앞에서는 대화 키가 되거나 하는 등등

이런 건 상태 기계로 구현하면 쉽다. 현재 내 상태가 뭔지에 따라 HID 입력을 서로 다르게 처리하는 것이다. 조금 트리키한 부분은 내가 어떤 상태에 속한지 판단하는 부분이다. 예를 들어 플레이어 앞에 무기랑 힐 팩이 모두 있는 경우 사용 버튼을 누르면 뭘 사용하게 할 건가 같은 것. 우선순위 시스템 같은 걸 쓸 수도 있고, 최고의 해결법 같은 건 없으므로 여러번 반복해서 테스트해보고 정해라

이것과 관련된 개념으로 control ownership이 있다. 몇몇 컨트롤은 게임의 특정한 파트가 소유할 수 있다. 예를 들어 어떤 인풋은 플레이어 컨트롤이 소유하고, 어떤 건 카메라 컨트롤이 소유하고 하는 식.

### 인풋 비활성화

입력을 막는 처리가 필요한 경우가 많다. 간단한 방법은 키마다 마스크를 두고 입력이 비활성화 되어 있는 경우 해당 입력을 무시하는 식. 하지만 입력 비활성화는 굉장히 주의해서 다뤄야 한다. 입력 비활성화시켜놓고 다시 활성화하는 걸 빼먹으면 플레이어는 게임 다시 켜기 전까지 아무것도 할 수 없게 되기 때문.

다른 좋은 처리 방법은 입력 자체를 막지 말고 그 입력을 다루는 카메라나 플레이어 입력 코드에서 자체적으로 처리를 하는 것이다. 그러면 게임 엔진의 다른 시스템들은 여기에 영향 받지 않고 요구사항에 맞춰 키 입력을 처리할 수 있기 때문

## 실전 HID

HID 엄청 중요하니까 신경 많이 쓰셈~~~