# Tools for Debugging and Development

게임 개발은 매우 복잡하고 수학적이고 오류가 발생하기 쉬운 일이다. 그러니 게임 개발용, 디버깅용 도구를 잘 만드는 것이 중요함

## 로깅 / 추적(트레이싱)

디버거는 좋지만 디버거로 추적할 수 없는 버그들도 있다. 타이밍에 의존적이라 게임이 풀 스피드로 쌩쌩 돌아갈 때만 발생하는 이슈라거나, 아주 복잡한 이벤트들의 발생 순서와 연관되어 있어 라인 바이 라인으로 쫓아가기 힘들거나, 기타 등등

이럴 땐 로그 찍는 걸로 따라가는게 훨씬 좋다

- C/C++ 콘솔 프로그램이면 printf / fprintf / iostream 등
- Win32 프로그램이면 OutputDebugString(디버그 창에 찍어줌)

게임 엔진에서는 보통 이것보다 좀 더 좋은 로깅 수단을 제공해줌

### Formatted output with OutputDebugString

OutputDebugString이 formatted output을 지원하지 않아서 보통 래핑해서 쓴다. sprintf 계열을 쓰든 뭐 해서..

### Verbosity

vervosity 레벨에 따라 로그가 어디까지 보이게 할 지 지정해주는 기능을 만들어두면 유용하다. 가장 간단한 방법은 현재 verbosity 레벨을 전역 변수로 두고 로그 찍는 함수의 verbosity레벨이 이 값보다 낮을 때만 실제로 출력하는 것

### Channels

로그 출력을 채널로 카테고리 나누는 것도 굉장히 유용하다. 어떤 채널은 애니메이션 관련 로그만, 어떤 채널은 물리 관련 로그만 하는 식으로. 플스3같은 경우는 채널마다 서로 다른 TTY 윈도우에 로그를 찍어서 보여줘서 작업하기 편했다. 윈도우즈에서는 출력창이 하나밖에 없으니 그렇게 할 수 없는데, 이 때도 채널마다 로그 색깔을 다르게 한다거나, 로그 필터 기능을 구현하거나 하는 식으로 해결할 수 있다. 

채널도 구현하기 쉽다. 채널이 32 혹은 64개 이하면 각 채널을 비트마스크로 표현하는 것도 괜찮음

#### Using Redis to Manage TTY Channels

너티독에서는 웹 기반의 커넥터를 사용. redis에 로그 저장하고 웹 브라우저에서 그 로그 볼 수 있는 방식

### Mirroring Output to a File

디버그 아웃풋은 레벨, 채널 구분없이 모든 데이터를 파일에 저장하면 좋다. 이러면 예상치 못한 문제 상황이 발생했을 때 로그 보고 파악하기가 쉬움.

모든 로그가 유실되지 않으려면 로그가 발생할 때마다 그때 그때 파일에 적어줘야 하는데(프로그램이 crash되면 저장 안 해둔 로그는 날아가므로) 문제는 파일에 내용을 적는 연산이 상당히 비싼 연산이라는 것이다. 

그래서 (a) 한 번에 엄청 많은 로그를 찍고 있는 상황이 아니고 (b) 지금 당장 로그 저장하는게 아주 중요한 상황 중 하나일 때만 로그를 저장하는게 좋다. 엔진 설정에서 로그 파일에 저장할지 여부를 켜고 끌 수 있게 해두는 것도 좋음

### Crash Reports

몇몇 게임 엔진은 게임이 죽을 때 크래시 정보에 관한 특별한 출력 혹은 로그 파일을 제공해준다. 대부분의 운영 체제에서 top-level 예외 처리기를 둘 수 있고, 이 예외 처리기는 거의 대부분의 크래시 상황을 잡아낼 수 있다. 이 예외 처리기 내에서 유용한 정보들을 출력해주면 된다(혹은 크래시났다고 이메일을 보내는 것 등도 가능). 

크래시 상황에서 로그 찍으면 좋은 유용한 정보들은 다음과 같다

- 현재 게임 레벨(씬)
- 플레이어 캐릭터의 월드 좌표
- 플레이어의 애니메이션, 액션 상태
- 실행중이던 게임 플레이 스크립트
- 스택 트레이스
- 엔진의 모든 메모리 할당자의 상태
- 크래시가 일어난 순간의 스크린샷

## Debug Drawing Facilities

게임에서 물체의 위치를 정하고 렌더링하는 과정들은 전부 수학적인 도구들을 이용해서 이뤄진다. 그래서 이 과정의 결과를 머릿속으로 상상해내기가 쉽지 않다. 이 때문에 디버깅용으로 대부분의 게임엔진에서는 색칠된 선을 그리거나 간단한 도형, 혹은 3D 텍스트를 그리는 등의 디버깅용 그리기 도구를 지원한다. 이런 도구를 쓰면 디버깅할 때 시간을 많이 아낄 수 있음

### Debug Drawing API

보통 디버깅용 그리기 API는 아래와 같은 요구사항을 만족해야 한다.

- 간단하고 쓰기 쉬울 것
- 아래와 같은 유용한 기본 도형 그리기를 지원할 것
  - 라인 그리기
  - 구(sphere) 그리기
  - 점 찍기(작은 크로스나 구)
  - 좌표축 (보통 x축은 빨강, y축은 초록, z축은 파랑으로 보임)
  - 바운딩 박스
  - formatted text
- 도형들이 어떻게 그려질지에 대한 컨트롤을 유연하게 할 수 있을 것
  - 색깔
  - 선의 두께
  - 구의 반지름
  - 점의 크기, 좌표축의 길이 등
- 월드 스페이스에 그릴지 스크린 스페이스에 그릴지 정하기.
- depth testing을 할지 말지 정해서 그리기
  - depth testing이 켜져있으면 디버깅용으로 그린게 화면상의 물체에 가려서 안 보이게 된다. 
  - 꺼져 있으면 실제 깊이가 어떤지 할기가 힘들지만 가려지지 않으니 찾기 쉬움
- 코드 어디서든 호출할 수 있을 것. 대부분의 엔진이 렌더링을 위한 geometry를 게임 루프의 특수한 위치(보통 각 프레임 종료후)에서만 추가 가능하게 만들기 때문에 디버깅용 API는 그리기 동작을 큐잉하는 등의 처리가 필요함
- 이상적으로는 모든 디버깅용 도형들이 수명(얼마나 오래 화면에 그려질 것인가)을 가지고 있어야 한다.
- 많은 개수의 도형을 그리는 것도 문제 없어야 함. 디버깅 옵션 때문에 게임이 쉽게 플레이 불가능할 정도로 느려지면 안 됨

## In-Game Menus

게임에는 각 서브시스템마다 매우 다양한 설정 값(configure)들이 존재한다. 이 값들을 게임 플레이 중에 수정해서 쓸 수 있으면 개발 과정에서 많은 시간을 아낄 수 있다.

이를 위한 간단하고 편리한 방법은 인게임 메뉴 시스템을 제공하는 것이다. 인게임 메뉴는 아래와 같은 옵션들을 포함할 수 있다.

- 전역 boolean 세팅 토글링
- 전역 정수, 실수 값 조정
- 임의의 함수 호출
- 서브 메뉴(각 옵션들 카테고리화해서 쓰기 쉽게)

간단한 버튼 누르면 인 게임에서 이 메뉴가 나오게 하고(게임은 일시 중지) 여기서 옵션들을 잘 선택해서 디버깅할 수 있으면 좋다

## In-Game Conosle

몇몇 게임 엔진은 메뉴 대신에 인게임에서 쓸 수 있는 콘솔을 제공한다. 콘솔은 메뉴보다 좀 덜 편리하지만 메뉴보다 좀 더 강력하다.

## Debug Cameras and Pausing the Game

카메라를 플레이어 캐릭터에서 분리해서 자유롭게 날아다니는 기능, 게임을 중지하고 재개하고 한 스텝씩 진행시키는 기능등은 굉장히 유용하다. 

슬로 모션도 굉장히 유용한 기능이다. 

## Cheats

개발, 디버깅 과정에서 유저가 치트 쓸 수 있게 하는 것도 중요하다. 유용한 치트의 예시로는 다음과 같은 것들이 있다.

- 무적
- 플레이어에게 무기 주기
- 무한 탄창
- 플레이어 메시 선택(자유 코스튬)

## Screenshots and Movie Capture

또다른 아주 유용한 기능은 스크린샷 뜨는 것. 스크린샷에 대해 아래와 같은 다양한 옵션을 제어할 수 있게 만들고 싶을 수 있다.

- 디버깅 도형들, 텍스트들도 스크린샷에 포함시킬지 여부
- HUD 포함시킬지 여부
- 캡쳐 뜰 해상도. 
- 간단한 카메라 에니메이션(파노라마?)

영상 캡쳐를 지원하는 경우도 있다. 엔진에서 지원 안 해도 외부 소프트웨어로 얼마든지 가능하다.

플스4는 스크린샷, 영상 캡쳐 및 공유를 내장 지원. 플스4는 게임 플레이중에 최근 15분간의 영상을 항상 저장하고 있음. 라이브 스트리밍도 가능.

## In-Game Profiling

게임은 성능이 아주 중요하니 프로파일링도 당연히 중요하다.

인 게임에서 프로파일링은 주로 어떤 코드 블록의 성능을 측정할 것인지를 지정하는 식으로 이루어진다. 프로파일러는 해당 코드블록의 실행 시간을 CPU의 고해상도 타이머를 이용해 측정하고 이를 메모리에 저장한다.

프로파일링 수치를 HUD에 띄우는 것도 일반적. CPU 사이클부터 ms 단위의 실행 시간, 전체 프레임 실행 시간 대비 차지하는 비율 등 다양한 형태로 볼 수 있는 기능도 보통 제공된다.

### Hierarchical Profiling

절차적인 언어로 작성된 프로그램은 함수 호출에 따른 계층 구조를 가진다.

프로그램 디버깅할 때 콜 스택은 호출 트리의 스냅샷만 보여준다. 특히 이 스냅샷은 최상단 호출에서부터 현재 호출까지의 모든 경로를 다 보여주는데, C/C++에서 시작 함수는 보통 main 혹은 WinMain이지만 기술적으로는 이 함수들은 CRT(C 런타임 라이브러리)의 start-up 함수에서 호출된다. 그래서 이 함수가 실행 계층 구조의 진짜 최상위 함수이다. 중단점 걸면 보통 이렇게 보인다.

```
e() <- 현재 실행 함수
b()
a()
main()
_crt_startup() <- 콜 스택 계층 구조 최상단
```

#### Measuring Execution Times Hierarchically

만약 단일 함수의 실행 속도만 측정한다면, 우리가 측정한 시간은 그 함수에서 호출된 다른 모든 함수의 실행 속도까지 포함하게 된다. 프로파일링을 제대로 하려면 이 계층 구조를 나눠서 측정할 수 있어야 한다.

상용 프로파일러는 대부분 자동으로 함수 실행 시간을 측정해줘서 자식 함수 호출까지 포함할지 제외하고 볼지 결정할 수 있게 해준다. 몇몇 프로파일러는 함수 호출횟수까지 기록해줌.

인게임 프로파일링 도구는 보통 이렇게 복잡하지 않고 대부분 수동 측정에 의존한다. 보통 특정 코드 블록의 성능을 측정하고 싶으면 아래와 같은 식으로 PROFILE 같은 매크로를 해당 코드 블록에 넣어주는 식으로 작성한다.

```C++
while (!quitGame)
{
  {
    PROFILE(SID("Poll Joypad"));
    PollJoypad();
  }
  {
    PROFILE(SID("Game Object Update"));
    UpdateGameObjects();
  }
  ...
}
```

PROFILE 매크로는 생성자에서 생성된 시점을 기록하고 파괴자에서 파괴될때까지 걸린 시간 계산해서 기록하는 프로파일러 클래스 객체를 만드는 역할을 한다. 이 프로파일러는 블록 내부에 선언되었으므로 블록이 종료되는 시점에서 해당 블록의 실행 시간을 계산해서 기록할 수 있는 것

이 방법은 간단하지만 위에서 언급한 함수 호출 계층 구조에 대한 정보는 얻을 수 없다는 문제가 있다. 이를 해결할 수 있는 방법 중 하나는 함수의 호출 계층 구조가 어떻게 되는지 코드 상에서 직접 적어주는 것이다.

```C++
ProfilerDeclareSampleBin(SID("Rendering"), nullptr);
  ProfilerDeclareSampleBin(SID("Visibility"), SID("Rendering"));
...
```

이 방법도 여전히 문제가 있다. 모든 함수의 부모가 딱 하나 뿐일 때는 괜찮겠지만 같은 함수를 호출하는 함수가 두 개 이상이 되면 제대로 기록할 수 없다.

이런 문제를 해결할 수 있게 좀 더 복잡한 프로파일링 도구를 만들 수도 있고, 이건 선택의 영역이다.


### Exporting to Excel

몇몇 게임 엔진은 프로파일링 결과를 텍스트 파일로 덤프하는 기능을 제공한다. 이때 csv 파일로 덤프를 뜰 경우 스프레드시트에서 로딩해서 분석하기 편해서 좋다. 

## In-Game Memory Stats and Leak Detection

런타임 퍼포먼스(프레임 레이트)말고도 게임 엔진은 타겟 하드웨어에서 사용가능한 메모리의 제한을 받는다. PC 게임은 덜하지만 그래도 최소한의 스펙에 대한 고민은 필요. 

이런 이유 때문에 대부분의 게임엔진에서는 커스텀 메모리 트래킹 도구를 구현해 둔다. 이 도구는 개발자가 엔진의 각 서브 시스템이 얼마나 메모리를 먹는지, 그리고 메모리 릭이 있는지 등을 확인할 수 있게 해준다.

게임이 실제로 메모리를 얼마나 쓰고 있는지 추적하는 것은 놀라울정도로 트리키한 작업이다. 단순히 malloc, free를 래핑해서 추적하면 되ㄴ은 거 아니냐고 생각할 수 있지만 아래와 같은 이유들 때문에 절대 그렇게 될 수가 없다.

1. 다른 사람의 코드에서 일어나는 메모리 할당을 절대 제어할 수 없음 : 운영체제랑 드라이버랑 게임엔진을 전부다 직접 만드는게 아닌 이상 서드 파티 라이브러리를 써야 하는데 이 라이브러리 내부에서 일어나는 메모리 할당을 마음대로 제어할 수 없다. 좋은 라이브러리들은 메모리 할당에 대한 훅(hook)을 제공해줘서 할당자를 커스텀하게 바꿀 수 있게 해주지만 안 그런 것들도 많기 때문.
2. 서로 다른 종류의 메모리 : 예를 들어, PC는 메인 RAM과 그래픽 카드에서 쓰는 비디오 RAM이 있다. 메인 RAM에서 일어나는 모든 메모리 할당을 다 추적해도, 비디오 RAM의 할당을 다 추적하는 건 거의 불가능. 다이렉트 X 같은 그래픽스 API는 비디오 RAM의 할당 과정에 대한 디테일을 숨기기 때문이다. 콘솔에서는 전부 관리할 수 있어서 좀 더 쉬움
3. 서로 다른 종류의 할당자 : 앞에서 다뤘던 것 같은 다양한 종류의 할당자들을 쓰게 될텐데, 각 할당자는 한 번에 메모리 공간을 크게 잡고 거기서 필요한 만큼 할당해주는 방식이기 때문에 실제로 사용되고 있는 메모리의 양, 상황을 알 수 없음. 할당자 내부에서 별도의 처리가 필요하게 됨

대부분의 게임 팀에서 메모리 트래킹 도구를 만드는데 엄청난 노력을 쏟아붓는다. 잘 만들면 특정 실행 기간동안의 메모리 할당 상황에 대한 디테일한 정보를 덤프 뜨는 것이나 최대 어디까지 메모리를 사용했는지 정보 등등 까지 다 다룰 수 있음. 거기 덧붙여서, 메모리 부족 상황에 도달했을 때 그 상황에 대해 최대한 도움이 되는 정보를 남기는 것 등도 가능.

보통 개발용 PC는 실제로 그 게임이 돌아갈 최소 사양보다 높은 경우가 많기 때문에, 이런 기능이 있으면 최소 사양 메모리보다 게임이 더 많은 메모리를 먹었을 때 거기에 대한 경고를 띄워줄 수 있게 된다. 

그 외에 상황에 따라 만들면 도움이 될만한 다른 예시는 아래와 같은 것이 있다

- 모델 로딩 실패했을 때 실제 오브젝트가 나타나야 할 위치에 3D로 빨간 텍스트 띄우기
- 텍스쳐 로딩 실패했을 때 흉한 분홍색 텍스쳐로 덮기
- 애니메이션 로딩 실패했을 때 이상하거나 웃긴 동작을 취하게 하고 로딩에 실패한 에셋의 이름을 캐릭터 머리 위에 띄우기

좋은 메모리 분석 도구를 제공하기 위한 키는 a. 정확한 정보 b. 편리하고 문제를 명확히 나타내는 방식으로 데이터를 보여주기 c. 발생한 문제의 근본적인 원인을 겨냥할 수 있도록 도와주는 문맥적인 정보를 제공하기 등이 있겠다.
