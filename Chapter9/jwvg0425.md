# Tools for Debugging and Development

게임 개발은 매우 복잡하고 수학적이고 오류가 발생하기 쉬운 일이다. 그러니 게임 개발용, 디버깅용 도구를 잘 만드는 것이 중요함

## 로깅 / 추적(트레이싱)

디버거는 좋지만 디버거로 추적할 수 없는 버그들도 있다. 타이밍에 의존적이라 게임이 풀 스피드로 쌩쌩 돌아갈 때만 발생하는 이슈라거나, 아주 복잡한 이벤트들의 발생 순서와 연관되어 있어 라인 바이 라인으로 쫓아가기 힘들거나, 기타 등등

이럴 땐 로그 찍는 걸로 따라가는게 훨씬 좋다

- C/C++ 콘솔 프로그램이면 printf / fprintf / iostream 등
- Win32 프로그램이면 OutputDebugString(디버그 창에 찍어줌)

게임 엔진에서는 보통 이것보다 좀 더 좋은 로깅 수단을 제공해줌

### Formatted output with OutputDebugString

OutputDebugString이 formatted output을 지원하지 않아서 보통 래핑해서 쓴다. sprintf 계열을 쓰든 뭐 해서..

### Verbosity

vervosity 레벨에 따라 로그가 어디까지 보이게 할 지 지정해주는 기능을 만들어두면 유용하다. 가장 간단한 방법은 현재 verbosity 레벨을 전역 변수로 두고 로그 찍는 함수의 verbosity레벨이 이 값보다 낮을 때만 실제로 출력하는 것

### Channels

로그 출력을 채널로 카테고리 나누는 것도 굉장히 유용하다. 어떤 채널은 애니메이션 관련 로그만, 어떤 채널은 물리 관련 로그만 하는 식으로. 플스3같은 경우는 채널마다 서로 다른 TTY 윈도우에 로그를 찍어서 보여줘서 작업하기 편했다. 윈도우즈에서는 출력창이 하나밖에 없으니 그렇게 할 수 없는데, 이 때도 채널마다 로그 색깔을 다르게 한다거나, 로그 필터 기능을 구현하거나 하는 식으로 해결할 수 있다. 

채널도 구현하기 쉽다. 채널이 32 혹은 64개 이하면 각 채널을 비트마스크로 표현하는 것도 괜찮음

#### Using Redis to Manage TTY Channels

너티독에서는 웹 기반의 커넥터를 사용. redis에 로그 저장하고 웹 브라우저에서 그 로그 볼 수 있는 방식

### Mirroring Output to a File

디버그 아웃풋은 레벨, 채널 구분없이 모든 데이터를 파일에 저장하면 좋다. 이러면 예상치 못한 문제 상황이 발생했을 때 로그 보고 파악하기가 쉬움.

모든 로그가 유실되지 않으려면 로그가 발생할 때마다 그때 그때 파일에 적어줘야 하는데(프로그램이 crash되면 저장 안 해둔 로그는 날아가므로) 문제는 파일에 내용을 적는 연산이 상당히 비싼 연산이라는 것이다. 

그래서 (a) 한 번에 엄청 많은 로그를 찍고 있는 상황이 아니고 (b) 지금 당장 로그 저장하는게 아주 중요한 상황 중 하나일 때만 로그를 저장하는게 좋다. 엔진 설정에서 로그 파일에 저장할지 여부를 켜고 끌 수 있게 해두는 것도 좋음

### Crash Reports

몇몇 게임 엔진은 게임이 죽을 때 크래시 정보에 관한 특별한 출력 혹은 로그 파일을 제공해준다. 대부분의 운영 체제에서 top-level 예외 처리기를 둘 수 있고, 이 예외 처리기는 거의 대부분의 크래시 상황을 잡아낼 수 있다. 이 예외 처리기 내에서 유용한 정보들을 출력해주면 된다(혹은 크래시났다고 이메일을 보내는 것 등도 가능). 

크래시 상황에서 로그 찍으면 좋은 유용한 정보들은 다음과 같다

- 현재 게임 레벨(씬)
- 플레이어 캐릭터의 월드 좌표
- 플레이어의 애니메이션, 액션 상태
- 실행중이던 게임 플레이 스크립트
- 스택 트레이스
- 엔진의 모든 메모리 할당자의 상태
- 크래시가 일어난 순간의 스크린샷

## Debug Drawing Facilities

게임에서 물체의 위치를 정하고 렌더링하는 과정들은 전부 수학적인 도구들을 이용해서 이뤄진다. 그래서 이 과정의 결과를 머릿속으로 상상해내기가 쉽지 않다. 이 때문에 디버깅용으로 대부분의 게임엔진에서는 색칠된 선을 그리거나 간단한 도형, 혹은 3D 텍스트를 그리는 등의 디버깅용 그리기 도구를 지원한다. 이런 도구를 쓰면 디버깅할 때 시간을 많이 아낄 수 있음

### Debug Drawing API

보통 디버깅용 그리기 API는 아래와 같은 요구사항을 만족해야 한다.

- 간단하고 쓰기 쉬울 것
- 아래와 같은 유용한 기본 도형 그리기를 지원할 것
  - 라인 그리기
  - 구(sphere) 그리기
  - 점 찍기(작은 크로스나 구)
  - 좌표축 (보통 x축은 빨강, y축은 초록, z축은 파랑으로 보임)
  - 바운딩 박스
  - formatted text
- 도형들이 어떻게 그려질지에 대한 컨트롤을 유연하게 할 수 있을 것
  - 색깔
  - 선의 두께
  - 구의 반지름
  - 점의 크기, 좌표축의 길이 등
- 월드 스페이스에 그릴지 스크린 스페이스에 그릴지 정하기.
- depth testing을 할지 말지 정해서 그리기
  - depth testing이 켜져있으면 디버깅용으로 그린게 화면상의 물체에 가려서 안 보이게 된다. 
  - 꺼져 있으면 실제 깊이가 어떤지 할기가 힘들지만 가려지지 않으니 찾기 쉬움
- 코드 어디서든 호출할 수 있을 것. 대부분의 엔진이 렌더링을 위한 geometry를 게임 루프의 특수한 위치(보통 각 프레임 종료후)에서만 추가 가능하게 만들기 때문에 디버깅용 API는 그리기 동작을 큐잉하는 등의 처리가 필요함
- 이상적으로는 모든 디버깅용 도형들이 수명(얼마나 오래 화면에 그려질 것인가)을 가지고 있어야 한다.
- 많은 개수의 도형을 그리는 것도 문제 없어야 함. 디버깅 옵션 때문에 게임이 쉽게 플레이 불가능할 정도로 느려지면 안 됨

## In-Game Menus

게임에는 각 서브시스템마다 매우 다양한 설정 값(configure)들이 존재한다. 이 값들을 게임 플레이 중에 수정해서 쓸 수 있으면 개발 과정에서 많은 시간을 아낄 수 있다.

이를 위한 간단하고 편리한 방법은 인게임 메뉴 시스템을 제공하는 것이다. 인게임 메뉴는 아래와 같은 옵션들을 포함할 수 있다.

- 전역 boolean 세팅 토글링
- 전역 정수, 실수 값 조정
- 임의의 함수 호출
- 서브 메뉴(각 옵션들 카테고리화해서 쓰기 쉽게)

간단한 버튼 누르면 인 게임에서 이 메뉴가 나오게 하고(게임은 일시 중지) 여기서 옵션들을 잘 선택해서 디버깅할 수 있으면 좋다

## In-Game Conosle

몇몇 게임 엔진은 메뉴 대신에 인게임에서 쓸 수 있는 콘솔을 제공한다. 콘솔은 메뉴보다 좀 덜 편리하지만 메뉴보다 좀 더 강력하다.

## Debug Cameras and Pausing the Game

카메라를 플레이어 캐릭터에서 분리해서 자유롭게 날아다니는 기능, 게임을 중지하고 재개하고 한 스텝씩 진행시키는 기능등은 굉장히 유용하다. 

슬로 모션도 굉장히 유용한 기능이다. 

## Cheats

개발, 디버깅 과정에서 유저가 치트 쓸 수 있게 하는 것도 중요하다. 유용한 치트의 예시로는 다음과 같은 것들이 있다.

- 무적
- 플레이어에게 무기 주기
- 무한 탄창
- 플레이어 메시 선택(자유 코스튬)

## Screenshots and Movie Capture


## In-Game Profiling

### Hierarchical Profiling

### Exporting to Excel

## In-Game Memory Stats and Leak Detection

